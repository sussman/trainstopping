!% $MAX_ARRAYS=1500
!% $MAX_CLASSES=200
!% $MAX_VERBS=300
!% $MAX_LABELS=10000
!% $MAX_ZCODE_SIZE=50000
!% $MAX_STATIC_DATA=50000
!% $MAX_PROP_TABLE_SIZE=50000
!% $MAX_INDIV_PROP_TABLE_SIZE=20000
!% $MAX_STACK_SIZE=65536
!% $MAX_SYMBOLS=20000

! --------------------------------------------------------------------------
! Generated by NI build:
Constant NI_BUILD_COUNT "4U67";

Array UUID_ARRAY string "UUID://8AA7291E-9709-4B6E-A228-FECE28AABCD5//";

Constant Story SC_0;
Constant Headline SC_1;
Constant Story_Author SC_2;
Serial "070719";


#ifdef TARGET_ZCODE;
	Constant I6_NULL $ffff;
#ifnot;
	Constant I6_NULL $ffffffff;
#endif;

Constant NO_PLACES;
Constant PREFER_HELD;
Constant START_MOVE 1;
Constant HIGHEST_RULEBOOK_NO 356;
Constant I7_OBJECT_TY 58;

[ I7ExtensionVersions;
  print "Standard Rules version 1/061217 by Graham Nelson^";
];


Global location = InformLibrary;
Global sline1;
Global sline2;
Global I7_prompt_text = ">";
Global I7_command;
Global I7_match_snippet;
Global I7_mistake_code;
Global I7_left_sl = SL_Location;
Global I7_right_sl = SL_Score_Moves;
Global I7_box;
Global act_requester;
Global I7_action_deciding_rule;
Global I7_concealed_item;
Global I7_TProp;
Global I7_TSign;
Global I7_suppress_scope_loops;

Constant I7_EMPTY_TEXT "";

Global say__n;
Array I7_CS --> 16;
Array I7_boxes_appeared --> I7_BOXES;

Constant WITHOUT_DIRECTIONS;

 
Global SACK_OBJECT;
Constant RUCKSACK_CLASS = K10_player_s_holdall;
 
  Constant I7_SERIAL_COMMA;  
  Constant I7_LOOKMODE = 2;  


! --- Replacements of library routines ---

#IFDEF DEBUG;
#IFDEF TEST_SCENARIOS_EXIST;
Replace KeyboardPrimitive;
#ENDIF;
#ENDIF;
Replace DrawStatusLine;
Replace BeforeRoutines;
Replace ActionPrimitive;
Replace AfterRoutines;
Replace ObjectIsUntouchable;
Replace AllowPushDir;
Replace ActionsOnSub;
Replace ActionsOffSub;
Replace InvSub;
Replace TakeSub;
Replace RemoveSub;
Replace DropSub;
Replace PutOnSub;
Replace InsertSub;
Replace EatSub;
Replace GoSub;
Replace EnterSub;
Replace ExitSub;
Replace GetOffSub;
Replace LookSub;
Replace ExamineSub;
Replace LookUnderSub;
Replace SearchSub;
Replace ConsultSub;
Replace LockSub;
Replace UnlockSub;
Replace SwitchOnSub;
Replace SwitchOffSub;
Replace OpenSub;
Replace CloseSub;
Replace WearSub;
Replace DisrobeSub;
Replace GiveSub;
Replace ShowSub;
Replace WakeOtherSub;
Replace ThrowAtSub;
Replace AttackSub;
Replace KissSub;
Replace AnswerSub;
Replace TellSub;
Replace AskSub;
Replace AskForSub;
Replace WaitSub;
Replace TouchSub;
Replace WaveSub;
Replace PullSub;
Replace PushSub;
Replace TurnSub;
Replace PushDirSub;
Replace SqueezeSub;
Replace YesSub;
Replace NoSub;
Replace BurnSub;
Replace WakeSub;
Replace ThinkSub;
Replace SmellSub;
Replace ListenSub;
Replace TasteSub;
Replace CutSub;
Replace JumpSub;
Replace TieSub;
Replace DrinkSub;
Replace SorrySub;
Replace StrongSub;
Replace MildSub;
Replace SwingSub;
Replace RubSub;
Replace SetToSub;
Replace WaveHandsSub;
Replace BuySub;
Replace SingSub;
Replace ClimbSub;
Replace SleepSub;
Replace ScoreSub;
Replace QuitSub;
Replace SaveSub;
Replace RestoreSub;
Replace RestartSub;
Replace VerifySub;
Replace VersionSub;
Replace ScriptOnSub;
Replace ScriptOffSub;
Replace LMode3Sub;
Replace LMode2Sub;
Replace LMode1Sub;
Replace PronounsSub;
Replace NotifyOnSub;
Replace NotifyOffSub;
Replace A80_time_checkingSub;


! --- Variables used in printing ---
Global say__c; Global say__p = 1; Global say__pc = 0;
Global I7_caps_mode = false;
Global I7_uninitialised = false;

! --- Properties ---
Property component_parent;
Property component_child;
Property component_sibling;
Property I7_Map_Region;
Property regional_found_in;

! --- Inclusion of library routines ---
Include "Parser";
Include "VerbLib";

Array Protect_I7_Arrays --> 16339 12345;

! --- Attributes ---
Property additive i7_kind;

Attribute initially_carried;
Attribute i7listflag;
Attribute I7_mentioned;

! --- Quantities ---
Constant Q22_entire_game = 1;

Array I7_Globals -->
  (SC_2) ! 1: Q27_story_author
  (SC_1) ! 2: Q28_story_headline
  (I7_EMPTY_TEXT) ! 3: Q29_story_genre
  (SC_3) ! 4: Q30_story_description
  (0) ! 5: Q31_release_number
  (0) ! 6: Q32_story_creation_year
  (selfobj) ! 7: Q33_actor
  (nothing) ! 8: Q34_thing_implicitly_taken
  (O99_bluff) ! 9: Q35_room_gone_from
  (nothing) ! 10: Q36_room_gone_to
  (nothing) ! 11: Q37_door_gone_through
  (nothing) ! 12: Q38_vehicle_gone_by
  (nothing) ! 13: Q39_thing_gone_with
  (nothing) ! 14: Q40_container_exited_from
  (##Wait) ! 15: Q41_room_describing_action
  (0) ! 16: Q42_visibility_level_count
  (nothing) ! 17: Q43_visibility_ceiling
  I6_NULL
  ; ! extent 18 words


! --- Activities ---
Constant V0_printing_the_name_of_some = 0;
Constant V1_listing_contents_of_somet = 1;
Constant V2_grouping_together_somethi = 2;
Constant V3_constructing_the_status_l = 3;
Constant V4_listing_nondescript_items = 4;
Constant V5_deciding_the_scope_of_som = 5;
Constant V6_supplying_a_missing_noun = 6;
Constant V7_supplying_a_missing_secon = 7;
Constant V8_reading_a_command = 8;
Constant V9_deciding_whether_all_incl = 9;
Constant V10_printing_the_player_s_ob = 10;
Constant V11_amusing_a_victorious_pla = 11;
Constant V12_printing_the_banner_text = 12;
Constant V13_printing_the_plural_name = 13;
Constant V14_deciding_the_concealed_p = 14;
Constant V15_printing_a_refusal_to_ac = 15;
Constant V16_printing_the_announcemen = 16;
Constant V17_printing_the_name_of_a_d = 17;
Constant V18_printing_the_description = 18;
Constant V19_printing_room_descriptio = 19;
Constant V20_printing_a_parser_error = 20;
Constant V21_implicitly_taking_someth = 21;
Constant V22_starting_the_virtual_mac = 22;
Constant V23_clarifying_the_parser_s_ = 23;
Constant V24_asking_which_do_you_mean = 24;
Constant V25_writing_a_paragraph_abou = 25;

Array Activity_before_rulebooks -->
  35
  38
  41
  44
  47
  50
  53
  56
  59
  62
  65
  68
  71
  74
  77
  80
  83
  86
  89
  92
  95
  98
  101
  104
  107
  110
  I6_NULL;

Array Activity_when_rulebooks -->
  36
  39
  42
  45
  48
  51
  54
  57
  60
  63
  66
  69
  72
  75
  78
  81
  84
  87
  90
  93
  96
  99
  102
  105
  108
  111
  I6_NULL;

Array Activity_after_rulebooks -->
  37
  40
  43
  46
  49
  52
  55
  58
  61
  64
  67
  70
  73
  76
  79
  82
  85
  88
  91
  94
  97
  100
  103
  106
  109
  112
  I6_NULL;

Array Activity_atb_rulebooks ->
  0
  0
  0
  0
  0
  1
  0
  0
  0
  1
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  1
  1
  0
  $ff;


! --- Variable used in debugging ---
Global debug_rules = 0;
Global debug_scenes = 0;

! --- Variables and arrays used in action processing ---
Attribute pushable; Global move_pushing;
Global move_from; Global move_to;
Global move_by; Global move_through;

Constant RS_CAPACITY = 666;
Global   rulechange_sp = 0;
Array    rulechange_stack --> RS_CAPACITY;
Global   los_rv = false;
Array    scene_started --> (1+2);
Array    scene_ended --> (1+2);
Array    scene_status --> (1+2);
Array    scene_endings --> (1+2);
Array    scene_latest_ending --> (1+2);

Constant Relation_Implicit	-1;
Constant Relation_OtoO		1;
Constant Relation_OtoV		2;
Constant Relation_VtoO		3;
Constant Relation_VtoV		4;
Constant Relation_Sym_OtoO	5;
Constant Relation_Sym_VtoV	6;
Constant Relation_Equiv		7;
Constant Relation_ByRoutine	8;

Array RelationList -->
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  door_to Relation_OtoV "Leading-through relates one room (called the other side) to various doors"
  0 Relation_Implicit "--"
  with_key Relation_OtoV "Lock-fitting relates one thing (called the matching key) to various things"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  0 Relation_Implicit "--"
  I6_NULL;


! --- Variable used by choose objects mechanism ---
Global cobj_flag = 0;
[ I7ResetChooseObjects; cobj_flag = 0; rfalse; ];

! --- Printing routines ---

[ I7_Kind_Name k;
  if (k == K1_room) print "room";
  if (k == K2_thing) print "thing";
  if (k == K3_direction) print "direction";
  if (k == K4_door) print "door";
  if (k == K5_container) print "container";
  if (k == K6_supporter) print "supporter";
  if (k == K7_backdrop) print "backdrop";
  if (k == K8_person) print "person";
  if (k == K9_region) print "region";
  if (k == K10_player_s_holdall) print "player's holdall";
  if (k == K11_device) print "device";
  if (k == K24_animal) print "animal";
  if (k == K25_man) print "man";
  if (k == K26_woman) print "woman";
  if (k == K27_player_character) print "player-character";
  if (k == K30_vehicle) print "vehicle";
];

Constant RBNO_0 = "allow access";
Constant RBNO_1 = "deny access";
Constant RBNO_2 = "persuasion succeeds";
Constant RBNO_3 = "persuasion fails";
Constant RBNO_4 = "there is sufficient light";
Constant RBNO_5 = "there is insufficient light";
Constant RBNO_6 = "it is very likely";
Constant RBNO_7 = "it is likely";
Constant RBNO_8 = "it is possible";
Constant RBNO_9 = "it is unlikely";
Constant RBNO_10 = "it is very unlikely";
[ I7_RulebookOutcomePrintingRule rbno;
  print (string) rbno; rfalse;
];


Object I7_property_numberspace_forcer
;




! --- Object tree ---
Class K0_kind 
 with vector 0
;

Class K1_room 
class K0_kind
 
  with n_to 0, ne_to 0, e_to 0, se_to 0, s_to 0, sw_to 0, w_to 0, nw_to 0,
  u_to 0, d_to 0, in_to 0, out_to 0,
 
 with vector 0
  has light
  has ~visited
  with plural "rooms"
;

Class K2_thing 
class K0_kind
 
  with before [;
      PushDir: AllowPushDir(); rtrue;
  ],
  with add_to_scope I7_ScopeParts,
  with component_parent nothing, component_sibling nothing, component_child nothing,
 
  with describe [ o; if (self has I7_mentioned ) rtrue; say__p = 0;  
CarryOutActivity( V25_writing_a_paragraph_abou , self); if (say__p) {
give self I7_mentioned; rtrue; } ],  
 with vector 0
  has ~light
  has ~edible
  has ~transparent
  has ~concealed
  has ~static
  has ~scenery
  has ~clothing
  has ~workflag
 with action_bitmap 0 0 0 0 0 0
;

Class K3_direction 
class K0_kind
  class CompassDirection,  
 with vector 0
  has ~workflag
  with plural "directions"
 with p10_opposite nothing,
 with p11_inform_property I7_EMPTY_TEXT,
 with p12_inform_object I7_EMPTY_TEXT,
;

Class K4_door 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has static
  has ~pushable
  has door
  has ~open
  has openable
  has ~lockable
  has ~locked
  with plural "doors"
;

Class K5_container 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has container
  has open
  has ~openable
  has ~lockable
  has ~locked
  with plural "containers"
;

Class K6_supporter 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has transparent
  has static
  has supporter
  with plural "supporters"
;

Class K7_backdrop 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has static
  has scenery
  with plural "backdrops"
;

Class K8_person 
class K2_thing
with i7_kind K2_thing
 with vector 0
 with capacity 100
  has animate
  has ~female
  has ~neuter
  with plural "persons"
;

Class K9_region 
class K0_kind
 with vector 0
  with plural "regions"
;

Class K10_player_s_holdall 
class K5_container
with i7_kind K5_container
 with vector 0
  has ~static
  has openable
  with plural "player's holdalls"
;

Class K11_device 
class K2_thing
with i7_kind K2_thing
 with vector 0
  has switchable
  has ~on
  with plural "devices"
;

Class K24_animal 
class K8_person
with i7_kind K8_person
 with vector 0
  with plural "animals"
;

Class K25_man 
class K8_person
with i7_kind K8_person
 with vector 0
  has male
  has ~female
  has ~neuter
  with plural "mans"
;

Class K26_woman 
class K8_person
with i7_kind K8_person
 with vector 0
  has female
  has ~neuter
  with plural "women"
;

Class K27_player_character 
class K8_person
with i7_kind K8_person
 
  with before NULL, after NULL, life NULL, each_turn NULL,
       time_out NULL, before_implicit NULL,
       parse_name 0,
       orders 0, number 0,
  has  proper transparent,
 
 with vector 0
 with description SC_4
  with plural "player-characters"
;

Class K30_vehicle 
class K5_container
with i7_kind K5_container
  with before [; Go: return 1; ],  
 with vector 0
  has enterable
  has static
  with plural "vehicles"
;

Object Value_Property_Holder
;
Object n_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link ne_obj,
  with name 'n//' 'north', door_dir n_to,  
 with vector 0
 with p10_opposite s_obj
  with short_name "north"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object ne_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link nw_obj,
  with name 'ne' 'northeast', door_dir ne_to,  
 with vector 0
 with p10_opposite sw_obj
  with short_name "northeast"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object nw_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link s_obj,
  with name 'nw' 'northwest', door_dir nw_to,  
 with vector 0
 with p10_opposite se_obj
  with short_name "northwest"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object s_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link se_obj,
  with name 's//' 'south', door_dir s_to,  
 with vector 0
 with p10_opposite n_obj
  with short_name "south"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object se_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link sw_obj,
  with name 'se' 'southeast', door_dir se_to,  
 with vector 0
 with p10_opposite nw_obj
  with short_name "southeast"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object sw_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link e_obj,
  with name 'sw' 'southwest', door_dir sw_to,  
 with vector 0
 with p10_opposite ne_obj
  with short_name "southwest"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object e_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link w_obj,
  with name 'e//' 'east', door_dir e_to,  
 with vector 0
 with p10_opposite w_obj
  with short_name "east"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object w_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link u_obj,
  with name 'w//' 'west', door_dir w_to,  
 with vector 0
 with p10_opposite e_obj
  with short_name "west"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object u_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link d_obj,
  with name 'u//' 'up', door_dir u_to,  
 with vector 0
 with p10_opposite d_obj
  with short_name "up"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object d_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link in_obj,
  with name 'd//' 'down', door_dir d_to,  
 with vector 0
 with p10_opposite u_obj
  with short_name "down"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object in_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link out_obj,
  with name 'in//' 'inside', door_dir in_to,  
 with vector 0
 with p10_opposite out_obj
  with short_name "inside"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object out_obj "" Compass
class K3_direction
with i7_kind K3_direction
  with K3_Link nothing,
  with name 'out//' 'outside', door_dir out_to,  
 with vector 0
 with p10_opposite in_obj
  with short_name "outside"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object selfobj ""
class K27_player_character
with i7_kind K27_player_character
  with K27_Link nothing,
  with K8_Link nothing,
  with K2_Link O96_hat,
 with name 'yourself' 
 with vector 0
  has concealed
  with short_name "yourself"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object -> O96_hat ""
class K5_container
with i7_kind K5_container
  with K5_Link nothing,
  with K2_Link O97_pocketwatch,
 with name 'hat' 
 with vector 0
  has worn clothing
 with description SC_5
 with capacity 1
  has ~static
  with short_name "hat"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object -> O97_pocketwatch ""
class K2_thing
with i7_kind K2_thing
  with K2_Link O98_train_schedule,
 with name 'pocketwatch' 'watch//' 
 with parse_name Parse_Name_GV82
 with vector 0
 with description text_routine_0
  with short_name "pocketwatch"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object -> O98_train_schedule ""
class K2_thing
with i7_kind K2_thing
  with K2_Link nothing,
 with name 'train' 'schedule' 
 with vector 0
 with description SC_6
  with short_name "train schedule"
  with list_together 0,
 with action_bitmap 0 0 0 0 0 0
;

Object O99_bluff ""
class K1_room
with i7_kind K1_room
  with K1_Link nothing,
 with name 'bluff' 
 with vector 0
 with description SC_7
  with short_name "Bluff"
  with list_together 0,
;

Constant K0_First = n_obj;
Constant K1_First = O99_bluff;
Constant K2_First = selfobj;
Constant K3_First = n_obj;
Constant K4_First = nothing;
Constant K5_First = O96_hat;
Constant K6_First = nothing;
Constant K7_First = nothing;
Constant K8_First = selfobj;
Constant K9_First = nothing;
Constant K10_First = nothing;
Constant K11_First = nothing;
Constant K24_First = nothing;
Constant K25_First = nothing;
Constant K26_First = nothing;
Constant K27_First = selfobj;
Constant K30_First = nothing;


! --- Property metadata ---
Array property_metadata --> 
    "map region" K1_room I6_NULL
    "description" K1_room K2_thing I6_NULL
    "printed name" K1_room K2_thing I6_NULL
    "initial appearance" K2_thing I6_NULL
    "printed plural name" K2_thing I6_NULL
    "inventory listing" K2_thing I6_NULL
    "indefinite article" K2_thing I6_NULL
    "matching key" K2_thing I6_NULL
    "other side" K4_door I6_NULL
    "carrying capacity" K5_container K6_supporter K8_person I6_NULL
    "opposite" K3_direction I6_NULL
    "inform property" K3_direction I6_NULL
    "inform object" K3_direction I6_NULL
    "lighted" K1_room K1_room K2_thing I6_NULL
    "visited" K1_room I6_NULL
    "enterable" K2_thing I6_NULL
    "lit" K2_thing K1_room K2_thing I6_NULL
    "edible" K2_thing I6_NULL
    "transparent" I6_NULL
    "undescribed" I6_NULL
    "fixed in place" K2_thing I6_NULL
    "scenery" K2_thing I6_NULL
    "wearable" K2_thing I6_NULL
    "handled" K2_thing I6_NULL
    "pushable between rooms" K2_thing I6_NULL
    "an inform library door" K2_thing I6_NULL
    "an inform library container" K2_thing I6_NULL
    "an inform library supporter" K2_thing I6_NULL
    "inform library switchable" K2_thing I6_NULL
    "an inform library animate object" K2_thing I6_NULL
    "an inform library male" K2_thing I6_NULL
    "marked for listing" K2_thing K3_direction I6_NULL
    "mentioned" K2_thing I6_NULL
    "initially carried" K2_thing I6_NULL
    "open" K4_door K5_container I6_NULL
    "openable" K4_door K5_container I6_NULL
    "lockable" K4_door K5_container I6_NULL
    "locked" K4_door K5_container I6_NULL
    "switched on" K11_device I6_NULL
    "female" K8_person I6_NULL
    "neuter" K8_person I6_NULL
    "specification" I6_NULL
    "score for visiting" I6_NULL
    "score" I6_NULL
    "worn" I6_NULL
    ;

Array attribute_offsets --> (50 + 59);
#IFDEF TARGET_ZCODE;
Array property_offsets --> (100 + 59);
#IFNOT; ! TARGET_ZCODE
Array property_offsets -->
	(100 + 59 + INDIV_PROP_START - 48);
#ENDIF; ! TARGET_ZCODE
[ CreatePropertyOffsets i;
  for (i=0: i<109: i++) attribute_offsets-->i = -1;
  for (i=0: i<159: i++) property_offsets-->i = -1;
  attribute_offsets-->light = 43;
  attribute_offsets-->visited = 48;
  attribute_offsets-->enterable = 51;
  attribute_offsets-->light = 54;
  attribute_offsets-->edible = 59;
  attribute_offsets-->transparent = 62;
  attribute_offsets-->concealed = 64;
  attribute_offsets-->static = 66;
  attribute_offsets-->scenery = 69;
  attribute_offsets-->clothing = 72;
  attribute_offsets-->moved = 75;
  attribute_offsets-->pushable = 78;
  attribute_offsets-->door = 81;
  attribute_offsets-->container = 84;
  attribute_offsets-->supporter = 87;
  attribute_offsets-->switchable = 90;
  attribute_offsets-->animate = 93;
  attribute_offsets-->male = 96;
  attribute_offsets-->workflag = 99;
  attribute_offsets-->I7_mentioned = 103;
  attribute_offsets-->initially_carried = 106;
  attribute_offsets-->open = 109;
  attribute_offsets-->openable = 113;
  attribute_offsets-->lockable = 117;
  attribute_offsets-->locked = 121;
  attribute_offsets-->on = 125;
  attribute_offsets-->female = 128;
  attribute_offsets-->neuter = 131;
  property_offsets-->I7_Map_Region = 0;
  property_offsets-->description = 3;
  property_offsets-->short_name = 7;
  property_offsets-->initial = 11;
  property_offsets-->plural = 14;
  property_offsets-->invent = 17;
  property_offsets-->article = 20;
  property_offsets-->with_key = 23;
  property_offsets-->door_to = 26;
  property_offsets-->capacity = 29;
  property_offsets-->p10_opposite = 34;
  property_offsets-->p11_inform_property = 37;
  property_offsets-->p12_inform_object = 40;
  property_offsets-->p55_specification = 134;
  property_offsets-->score = 136;
  property_offsets-->score = 138;
  property_offsets-->worn = 140;
];





[ PrintTableName T;
	switch(T) {

		default: print "** No such table **";
	}
];




Global parameter_object;


! Definitions of non-inline "To..." phrases

! From the Standard Rules
! To say contents of ( O - an object ):
[ PHR_411 
    t_0 ! Call parameter 'O' = OBJECT_TY
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence]
        I7WriteListFrom(child(t_0), 8);  
   rfalse;
];
! From the Standard Rules
! To say no line break -- running on:
[ PHR_266 ;
      ! phrase 1
      ! [1: do nothing]
        ;  
   rfalse;
];
! From the Standard Rules
! To say the contents of ( O - an object ):
[ PHR_412 
    t_0 ! Call parameter 'O' = OBJECT_TY
    ;
      ! phrase 1
      ! [1: list the contents of o , as a sentence , using the definite article]
        I7WriteListFrom(child(t_0), 264);  
   rfalse;
];
! Definitions of rule phrases


! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-processing (B0_action_processing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! The first action-processing rule:
! --- now the mid-placed rules ---
! Rule 2/7: PA_R
!   === which is equally specific with ===
! Rule 3/7: CR_R
! --- now the last-placed rules ---
! Rule 4/7 ! A last action-processing rule:
!   === which is equally specific with ===
! Rule 5/7 ! A last action-processing rule:
!   === which is equally specific with ===
! Rule 6/7 ! A last action-processing rule:
!   === which is equally specific with ===
! Rule 7/7 ! A last action-processing rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The first action-processing rule:
[ R_17 ;
      ! phrase 1
      ! [1: abide by the before rules]
        if (ProcessRulebook(1)) rtrue;  
   rfalse;
];
! From the Standard Rules
! A last action-processing rule:
[ R_18 ;
      ! phrase 1
      ! [1: abide by the instead rules]
        if (ProcessRulebook(2)) rtrue;  
   rfalse;
];
! From the Standard Rules
! A last action-processing rule:
[ R_19 ;
      ! phrase 1
      ! [1: abide by the non-player character action rule]
        if (ProcessRulebook(I7_NPCA)) rtrue;  
   rfalse;
];
! From the Standard Rules
! A last action-processing rule:
[ R_20 ;
      ! phrase 1
      ! [1: abide by the action-specific rules]
        if (ProcessRulebook(6)) rtrue;  
   rfalse;
];
! From the Standard Rules
! A last action-processing rule:
[ R_21 ;
      ! phrase 1
      ! [1: rule succeeds]
        RulebookSucceeds(); rtrue;  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Before (B1_before)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last before rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last before rule:
[ R_15 ;
      ! phrase 1
      ! [1: abide by i6 gamepreroutine]
        if (GamePreRoutine()~=0) rtrue;  
      ! phrase 2
      ! [2: abide by i6 orders property]
        if (RunRoutines(player,orders)~=0) rtrue;  
      ! phrase 3
      ! [3: abide by i6 location before]
        if (location~=0 && RunRoutines(location,before)~=0) rtrue;  
      ! phrase 4
      ! [4: abide by i6 react_before property]
        scope_reason=REACT_BEFORE_REASON; parser_one=0;SearchScope(ScopeCeiling(player),player,0); scope_reason=PARSING_REASON; if (parser_one~=0) rtrue;  
      ! phrase 5
      ! [5: abide by i6 object before]
        if (inp1>1 && RunRoutines(inp1,before)~=0) rtrue;  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: After (B3_after)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The first after rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The first after rule:
[ R_16 ;
      ! phrase 1
      ! [1: abide by i6 gamepostroutine]
        if (GamePostRoutine()~=0) rtrue;  
      ! phrase 2
      ! [2: abide by i6 location after]
        if (location~=0 && RunRoutines(location,after)~=0) rtrue;  
      ! phrase 3
      ! [3: abide by i6 react_after property]
        scope_reason=REACT_AFTER_REASON; parser_one=0;SearchScope(ScopeCeiling(player),player,0); scope_reason=PARSING_REASON; if (parser_one~=0) rtrue;  
      ! phrase 4
      ! [4: abide by i6 object after]
        if (inp1>1 && RunRoutines(inp1,after)~=0) rtrue;  
      ! phrase 5
      ! [5: continue the action]
        rfalse;  
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Action-specific (B6_action_specific)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last action-specific rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last action-specific rule:
[ R_22 ;
      ! phrase 1
      ! [1: cause the action to take place]
        _I6_ActionPrimitive(); rtrue;  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Turn sequence (B9_turn_sequence)
! ----------------------------------------------------------------------------------------------------
! Rule 1/9 ! A first turn sequence rule:
!   === which is equally specific with ===
! Rule 2/9 ! A first turn sequence rule:
! --- now the mid-placed rules ---
! Rule 3/9: I7ResetChooseObjects
!   === which is equally specific with ===
! Rule 4/9: ProcessI7Timers
!   === which is equally specific with ===
! Rule 5/9: TS1_R
!   === which is equally specific with ===
! Rule 6/9: TS4_R
! --- now the last-placed rules ---
! Rule 7/9 ! A last turn sequence rule:
!   === which is equally specific with ===
! Rule 8/9: TS5_R
!   === which is equally specific with ===
! Rule 9/9: TS6_R
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! A first turn sequence rule:
[ R_11 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
        ProcessRulebook(32);  
   rfalse;
];
! From the Standard Rules
! A first turn sequence rule:
[ R_10 ;
      ! phrase 1
      ! [1: consider the every turn rules]
        ProcessRulebook(24);  
   rfalse;
];
! From the Standard Rules
! A last turn sequence rule:
[ R_12 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
        ProcessRulebook(32);  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: When play begins (B22_when_play_begins)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! The first when play begins rule:
! --- now the mid-placed rules ---
! Rule 2/3 ! When play begins:
!   === which is equally specific with ===
! Rule 3/3 ! When play begins:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The first when play begins rule:
[ R_9 ;
      ! phrase 1
      ! [1: consider the scene changing rules]
        ProcessRulebook(32);  
   rfalse;
];
! When play begins:
[ R_550 ;
      ! phrase 1
        #ifndef I7_ECONOMY; if (debug_rules>1) print "@31  [1: say the story description]^"; #endif;
      say__c=0; say__p=1;  print (I7_string) (I7_Globals-->3);   .L_Say0;
   rfalse;
];
! When play begins:
[ R_551 ;
      ! phrase 1
        #ifndef I7_ECONOMY; if (debug_rules>1) print "@31  [1: change the time of day to 9:10 am]^"; #endif;
        the_time = 550;  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Every turn (B24_every_turn)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Every turn when a random chance of 1 in 20 succeeds:
! ----------------------------------------------------------------------------------------------------
! Every turn when a random chance of 1 in 20 succeeds:
[ R_554 ;
   if ((((  (random(20) <= 1)  )))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_554);
      ! phrase 1
        #ifndef I7_ECONOMY; if (debug_rules>1) print "@31  [1: say ~A distant wind blows, echoing over the valley.~]^"; #endif;
      say__c=0; say__p=1;  print (I7_string) SC_8;   new_line; .L_Say1;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_554, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: does the player mean (B30_does_the_player_mean)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Does the player mean taking something which is carried by the player ( this is the very unlikely to mean taking what's already carried rule ):
[ R_14 ;
   if ((action ==##Take) &&  (actor==player) && ((noun ofclass K2_thing) && (player == I7_CarriedBy(noun)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_14);
      ! phrase 1
      ! [1: it is very unlikely]
      RulebookSucceeds(true, RBNO_10); rtrue;

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_14, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Setting action variables (B31_setting_action_variables)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Setting action variables for taking ( this is the standard set taking variables rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Rule for setting action variables for going ( this is the standard set going variables rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Setting action variables for looking ( this is the determine visibility ceiling rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Setting action variables for exiting:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Setting action variables for taking ( this is the standard set taking variables rule ):
[ R_30 ;
   if ((action ==##Take)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_30);
      ! phrase 1
      ! [1: if the i6 parser asks for an implicit take , now the thing implicitly taken is the noun]
        if (  (onotheld_mode==1)  ) {   (MStack-->MstVO(20001,0)) = noun;     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_30, true);
   rfalse;
];
! From the Standard Rules
! Rule for setting action variables for going ( this is the standard set going variables rule ):
[ R_79 
    t_0 ! Local variable e.g. 'carriage' = OBJECT_TY
    t_1 ! Local variable e.g. 'target' = OBJECT_TY
    t_2 ! Local variable e.g. 'direction D' = OBJECT_TY
    ;
   if ((action ==##Go)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_79);
      ! phrase 1
      ! [1: now the thing gone with is the i6-pushdir item]
        (MStack-->MstVO(20007,4)) = move_pushing;  
      ! phrase 2
      ! [2: now the room gone from is the location of the actor]
        (MStack-->MstVO(20007,0)) =   I7_Location(actor)  ;  
      ! phrase 3
      ! [3: if the actor is in an enterable vehicle ( called the carriage ) , now the vehicle gone by is the carriage]
        if (((t_0=I7_InWhat(actor)) && (I7_InWhat(actor) ofclass K30_vehicle) && (I7GetEitherOr(I7_InWhat(actor),enterable)))) {   (MStack-->MstVO(20007,3)) = t_0;     }
      ! phrase 4
      ! [4: let the target be nothing]
        t_1 = nothing;  
      ! phrase 5
      ! [5: if the noun is a direction begin]
        if ((noun ofclass K3_direction))   {
         ! phrase 6
         ! [6: let direction d be the noun]
           t_2 = noun;  
         ! phrase 7
         ! [7: let the target be the room-or-door direction d from the room gone from]
           t_1 = (Resolver_0(t_2,(MStack-->MstVO(20007,0)), "source", 1234));  
         ! phrase 8
         ! [8: otherwise]
         } else {

         ! phrase 9
         ! [9: if the noun is a door , let the target be the noun]
           if ((noun ofclass K4_door)) {   t_1 = noun;     }
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: if the target is a door begin]
        if ((t_1 ofclass K4_door))   {
         ! phrase 12
         ! [12: now the door gone through is the target]
           (MStack-->MstVO(20007,2)) = t_1;  
         ! phrase 13
         ! [13: now the target is the other side of the target from the room gone from]
           t_1 = (Resolver_1(t_1,(MStack-->MstVO(20007,0)), "source", 1241));  
         ! phrase 14
         ! [14: end if]
         }

      ! phrase 15
      ! [15: now the room gone to is the target]
        (MStack-->MstVO(20007,1)) = t_1;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_79, true);
   rfalse;
];
! From the Standard Rules
! Setting action variables for looking ( this is the determine visibility ceiling rule ):
[ R_111 ;
   if ((action ==##Look)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_111);
      ! phrase 1
      ! [1: calculate visibility ceiling at low level]
        I7_Calculate_VC();  
      ! phrase 2
      ! [2: now the visibility level count is the visibility ceiling count calculated]
        (MStack-->MstVO(20011,1)) =   visibility_levels  ;  
      ! phrase 3
      ! [3: now the visibility ceiling is the visibility ceiling calculated]
        (MStack-->MstVO(20011,2)) =   visibility_ceiling  ;  
      ! phrase 4
      ! [4: now the room-describing action is the looking action]
        (MStack-->MstVO(20011,0)) = ##Look;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_111, true);
   rfalse;
];
! From the Standard Rules
! Setting action variables for exiting:
[ R_99 ;
   if ((action ==##Exit)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_99);
      ! phrase 1
      ! [1: now the container exited from is the holder of the actor]
        (MStack-->MstVO(20009,0)) =   (I7_Holder(actor))  ;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_99, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: Scene changing (B32_scene_changing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last scene changing rule:
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last scene changing rule:
[ R_13 ;
      ! phrase 1
      ! [1: run scene change machinery]
        I7_SceneChange();  
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: before Printing the name (B35_before_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Before printing the name of a thing ( called the item being printed ) ( this is the make named things mentioned rule ):
[ R_25 
    t_0 ! Local variable e.g. 'item being printed' = OBJECT_TY
    ;
   if ((t_0 = parameter_object, ((parameter_object ofclass K2_thing)))) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_25);
      ! phrase 1
      ! [1: now the item being printed is mentioned]
        I7SetEitherOr(t_0,I7_mentioned);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_25, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Printing the name (B36_for_printing_the_name)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last for printing the name rule ( this is the standard name printing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last for printing the name rule ( this is the standard name printing rule ):
[ R_23 ;
      ! phrase 1
      ! [1: cause the description to take place]
        I6_PSN__(parameter_object);  
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Listing contents (B39_for_listing_contents)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! The last for listing contents rule ( this is the standard contents listing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! The last for listing contents rule ( this is the standard contents listing rule ):
[ R_24 ;
      ! phrase 1
      ! [1: cause the listing to take place]
        I7_WLF(child(parameter_object), 0);  
      RulebookSucceeds(); rtrue;
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Supplying a missing noun (B54_for_supplying_a_missing_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Rule for supplying a missing noun while smelling ( this is the ambient odour rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Rule for supplying a missing noun while listening ( this is the ambient sound rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Rule for supplying a missing noun while going ( this is the block vaguely going rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Rule for supplying a missing noun while smelling ( this is the ambient odour rule ):
[ R_235 ;
   if (((((action ==##Smell) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_235);
      ! phrase 1
      ! [1: change the noun to the location]
        noun = real_location;  
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_235, true);
   rfalse;
];
! From the Standard Rules
! Rule for supplying a missing noun while listening ( this is the ambient sound rule ):
[ R_236 ;
   if (((((action ==##Listen) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_236);
      ! phrase 1
      ! [1: change the noun to the location]
        noun = real_location;  
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_236, true);
   rfalse;
];
! From the Standard Rules
! Rule for supplying a missing noun while going ( this is the block vaguely going rule ):
[ R_237 ;
   if (((((action ==##Go) &&  (actor==player))))) { ! Runs only while condition holds
   if (debug_rules) DB_Rule(R_237);
      ! phrase 1
      ! [1: say ~You'll have to say which compass direction to go in.~]
      say__c=0; say__p=1;  print (I7_string) SC_9;   new_line; .L_Say2;
      RulebookSucceeds(); rtrue;
   } ! Runs only while condition holds
   else if (debug_rules > 1) DB_Rule(R_237, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: for Deciding the concealed possessions (B78_for_deciding_the_conceal)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Rule for deciding the concealed possessions of player:
! ----------------------------------------------------------------------------------------------------
! Rule for deciding the concealed possessions of player:
[ R_552 ;
   if ((parameter_object == player)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_552);
      ! phrase 1
        #ifndef I7_ECONOMY; if (debug_rules>1) print "@31  [1: if the particular possession is inside the hat and the player wears the hat , yes]^"; #endif;
      ! [2: otherwise no]
        if (((O96_hat == I7_InWhat(I7_concealed_item))) && ((player == I7_WornBy(O96_hat)))) {   rtrue;     }
      ! phrase 3
      ! [3: otherwise no]
        else {   rfalse;     }
      RulebookSucceeds(); rtrue;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_552, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking inventory (B114_carry_out_taking_invent)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Carry out taking inventory ( this is the print empty inventory rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Carry out taking inventory ( this is the print standard inventory rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Carry out taking inventory ( this is the use inventory to set pronouns rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out taking inventory ( this is the print empty inventory rule ):
[ R_26 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_26);
      ! phrase 1
      ! [1: if the first thing held by the player is nothing , stop the action with library message taking inventory action number 1]
        if ((  (child(player))   == nothing)) {   return GL__M(##Inv,1,noun);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_26, true);
   rfalse;
];
! From the Standard Rules
! Carry out taking inventory ( this is the print standard inventory rule ):
[ R_27 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_27);
      ! phrase 1
      ! [1: issue library message taking inventory action number 2]
        GL__M(##Inv,2,noun);  
      ! phrase 2
      ! [2: say ~:[line break]~]
      say__c=0; say__p=1;  print (I7_string) SC_10;    new_line;   .L_Say3;
      ! phrase 3
      ! [3: list the contents of the player , with newlines , indented , including contents , giving inventory information , with extra indentation]
        I7WriteListFrom(child(player), 8215);  
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_27, true);
   rfalse;
];
! From the Standard Rules
! Carry out taking inventory ( this is the use inventory to set pronouns rule ):
[ R_28 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_28);
      ! phrase 1
      ! [1: set pronouns from possessions of the player]
        I7_NoticeHeld();  
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_28, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking inventory (B115_report_taking_inventory)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking inventory ( this is the report other people taking inventory rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor taking inventory ( this is the report other people taking inventory rule ):
[ R_29 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_29);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] looks through [possessive for the actor] possessions.~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_11;  (Resolver_2(actor, "source", 824));  print (I7_string) SC_12;   new_line; .L_Say4;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_29, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking (B116_check_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/11 ! Check an actor taking ( this is the avoid unnecessary implicit taking rule ):
!   === which is equally specific with ===
! Rule 2/11 ! Check an actor taking ( this is the can't take yourself rule ):
!   === which is equally specific with ===
! Rule 3/11 ! Check an actor taking ( this is the can't take other people rule ):
!   === which is equally specific with ===
! Rule 4/11 ! Check an actor taking ( this is the can't take component parts rule ):
!   === which is equally specific with ===
! Rule 5/11 ! Check an actor taking ( this is the can't take people's possessions rule ):
!   === which is equally specific with ===
! Rule 6/11 ! Check an actor taking ( this is the can't take what you're inside rule ):
!   === which is equally specific with ===
! Rule 7/11 ! Check an actor taking ( this is the can't take what's already taken rule ):
!   === which is equally specific with ===
! Rule 8/11 ! Check an actor taking ( this is the can't take scenery rule ):
!   === which is equally specific with ===
! Rule 9/11 ! Check an actor taking ( this is the can't take what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 10/11 ! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
!   === which is equally specific with ===
! Rule 11/11 ! Check an actor taking ( this is the can't exceed carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor taking ( this is the avoid unnecessary implicit taking rule ):
[ R_31 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_31);
      ! phrase 1
      ! [1: if the thing implicitly taken is a thing carried by the actor , stop the action]
        if ((((MStack-->MstVO(20001,0)) ofclass K2_thing) && (actor == I7_CarriedBy((MStack-->MstVO(20001,0)))))) {   rtrue;     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_31, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take yourself rule ):
[ R_32 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_32);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message taking action number 2 for the noun]
        if ((actor == noun)) {   return GL__M(##Take,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_32, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take other people rule ):
[ R_33 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_33);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message taking action number 3 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Take,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_33, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take component parts rule ):
[ R_34 
    t_0 ! Local variable e.g. 'whole' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_34);
      ! phrase 1
      ! [1: if the noun is part of something ( called the whole ) , stop the action with library message taking action number 7 for the whole]
        if (((t_0=(noun.component_parent)) && ((noun.component_parent) ofclass K2_thing))) {   return GL__M(##Take,7,t_0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_34, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take people's possessions rule ):
[ R_35 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    t_1 ! Local variable e.g. 'H' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_35);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 2
      ! [2: let h be the not-counting-parts holder of the noun]
        t_1 =   (OIU_Parent(noun))  ;  
      ! phrase 3
      ! [3: while h is not nothing and h is not the local ceiling begin]
        while ((~~((t_1 == nothing))) && (~~((t_1 == t_0))))   {
         ! phrase 4
         ! [4: if h is a person , stop the action with library message taking action number 6 for h]
           if ((t_1 ofclass K8_person)) {   return GL__M(##Take,6,t_1);     }
         ! phrase 5
         ! [5: let h be the not-counting-parts holder of h]
           t_1 =   (OIU_Parent(t_1))  ;  
         ! phrase 6
         ! [6: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_35, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take what you're inside rule ):
[ R_36 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_36);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message taking action number 4 for the noun]
        if ((t_0 == noun)) {   return GL__M(##Take,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_36, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take what's already taken rule ):
[ R_37 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_37);
      ! phrase 1
      ! [1: if the actor is carrying the noun , stop the action with library message taking action number 5 for the noun]
        if ((actor == I7_CarriedBy(noun))) {   return GL__M(##Take,5,noun);     }
      ! phrase 2
      ! [2: if the actor is wearing the noun , stop the action with library message taking action number 5 for the noun]
        if ((actor == I7_WornBy(noun))) {   return GL__M(##Take,5,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_37, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take scenery rule ):
[ R_38 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_38);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message taking action number 10 for the noun]
        if ((I7GetEitherOr(noun,scenery))) {   return GL__M(##Take,10,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_38, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't take what's fixed in place rule ):
[ R_39 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_39);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message taking action number 11 for the noun]
        if ((I7GetEitherOr(noun,static))) {   return GL__M(##Take,11,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_39, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the use player's holdall to avoid exceeding carrying capacity rule ):
[ R_40 
    t_0 ! Local variable e.g. 'sack' = OBJECT_TY
    t_1 ! Local variable e.g. 'transferred item' = OBJECT_TY
    t_2 ! Local variable e.g. '?-1,-1?' = OBJECT_TY
    t_3 ! Local variable e.g. '?-1,-1?' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_40);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor begin]
        if ((  (Prop_0(actor))   >= AccessProp(actor,capacity)))   {
         ! phrase 2
         ! [2: if the actor is carrying a player's holdall ( called the sack ) begin]
           if ((Prop_1(actor)&& (t_0=I7_CS-->0)))   {
            ! phrase 3
            ! [3: let the transferred item be nothing]
              t_1 = nothing;  
            ! phrase 4
            ! [4: repeat with the possible item running through things carried by the actor begin]
              for (t_2=Prop_2(actor,0), t_3=Prop_2(actor,t_2): t_2: t_2=t_3, t_3=Prop_2(actor,t_3))   {
               ! phrase 5
               ! [5: if the possible item is not lit and the possible item is not the sack , let the transferred item be the possible item]
                 if ((~~((I7GetEitherOr(t_2,light)))) && (~~((t_2 == t_0)))) {   t_1 = t_2;     }
               ! phrase 6
               ! [6: end repeat]
               }

            ! phrase 7
            ! [7: if the transferred item is not nothing begin]
              if (~~((t_1 == nothing)))   {
               ! phrase 8
               ! [8: issue library message taking action number 13 for the transferred item]
                 GL__M(##Take,13,t_1);  
               ! phrase 9
               ! [9: silently try the actor trying inserting the transferred item into the sack]
                 @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Insert, t_1, t_0);; @pull keep_silent;  
               ! phrase 10
               ! [10: if the transferred item is not in the sack , stop the action]
                 if (~~((t_0 == I7_InWhat(t_1)))) {   rtrue;     }
               ! phrase 11
               ! [11: end if]
               }

            ! phrase 12
            ! [12: end if]
            }

         ! phrase 13
         ! [13: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_40, true);
   rfalse;
];
! From the Standard Rules
! Check an actor taking ( this is the can't exceed carrying capacity rule ):
[ R_41 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_41);
      ! phrase 1
      ! [1: if the number of things carried by the actor is at least the carrying capacity of the actor , stop the action with library message taking action number 12 for the actor]
        if ((  (Prop_3(actor))   >= AccessProp(actor,capacity))) {   return GL__M(##Take,12,actor);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_41, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking (B117_carry_out_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking ( this is the standard taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor taking ( this is the standard taking rule ):
[ R_42 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_42);
      ! phrase 1
      ! [1: now the actor carries the noun]
        I7_Move(noun,actor);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_42, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking (B118_report_taking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor taking ( this is the don't report successful implicit takes rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor taking ( this is the standard report taking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor taking ( this is the don't report successful implicit takes rule ):
[ R_43 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_43);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: end any i6 parser implicit take]
           notheld_mode=onotheld_mode;  
         ! phrase 3
         ! [3: if the thing implicitly taken is not nothing , stop the action]
           if (~~(((MStack-->MstVO(20001,0)) == nothing))) {   rtrue;     }
         ! phrase 4
         ! [4: end if]
         }

      ! phrase 5
      ! [5: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_43, true);
   rfalse;
];
! From the Standard Rules
! Report an actor taking ( this is the standard report taking rule ):
[ R_44 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_44);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking action number 1 for the noun]
        if ((actor == player)) {   GL__M(##Take,1,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] picks up [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_13;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say5;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_44, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Removing it from (B119_check_removing_it_from)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor taking ( this is the can't take component parts rule ):
!   <<< I - Number of aspects constrained <<<
! Rule 2/4 ! Check an actor removing something from ( this is the can't remove what's not inside rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor removing something from ( this is the can't remove from people rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor removing something from ( this is the convert remove to take rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove what's not inside rule ):
[ R_45 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_45);
      ! phrase 1
      ! [1: if the holder of the noun is not the second noun , stop the action with library message removing it from action number 2 for the noun]
        if (~~((  (I7_Holder(noun))   == second))) {   return GL__M(##Remove,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_45, true);
   rfalse;
];
! From the Standard Rules
! Check an actor removing something from ( this is the can't remove from people rule ):
[ R_46 
    t_0 ! Local variable e.g. 'owner' = OBJECT_TY
    ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_46);
      ! phrase 1
      ! [1: if the holder of the noun is a person ( called the owner ) , stop the action with library message taking action number 6 for the owner]
        if (((t_0=  (I7_Holder(noun))  ) && (  (I7_Holder(noun))   ofclass K8_person))) {   return GL__M(##Take,6,t_0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_46, true);
   rfalse;
];
! From the Standard Rules
! Check an actor removing something from ( this is the convert remove to take rule ):
[ R_47 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_47);
      ! phrase 1
      ! [1: convert to the taking action on the noun]
        return GVS_Convert(##Take,noun,0);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_47, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Dropping (B122_check_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor dropping ( this is the can't drop yourself rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor dropping ( this is the can't drop what's already dropped rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor dropping ( this is the can't drop what's not held rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor dropping ( this is the can't drop clothes being worn rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor dropping ( this is the can't drop yourself rule ):
[ R_48 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_48);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message putting it on action number 4]
        if ((noun == actor)) {   return GL__M(##PutOn,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_48, true);
   rfalse;
];
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's already dropped rule ):
[ R_49 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_49);
      ! phrase 1
      ! [1: if the noun is in the holder of the actor , stop the action with library message dropping action number 1 for the noun]
        if ((  (I7_Holder(actor))   == I7_InWhat(noun))) {   return GL__M(##Drop,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_49, true);
   rfalse;
];
! From the Standard Rules
! Check an actor dropping ( this is the can't drop what's not held rule ):
[ R_50 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_50);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
        if ((actor == I7_CarriedBy(noun))) {   rfalse;     }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
        if ((actor == I7_WornBy(noun))) {   rfalse;     }
      ! phrase 3
      ! [3: stop the action with library message dropping action number 2 for the noun]
        return GL__M(##Drop,2,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_50, true);
   rfalse;
];
! From the Standard Rules
! Check an actor dropping ( this is the can't drop clothes being worn rule ):
[ R_51 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_51);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
           GL__M(##Drop,3,noun);  
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_51, true);
   rfalse;
];
! From the Standard Rules
! Check an actor dropping ( this is the can't drop if this exceeds carrying capacity rule ):
[ R_52 
    t_0 ! Local variable e.g. 'H' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_52);
      ! phrase 1
      ! [1: let h be the holder of the actor]
        t_0 =   (I7_Holder(actor))  ;  
      ! phrase 2
      ! [2: if h is a room , continue the action]
        if ((t_0 ofclass K1_room)) {   rfalse;     }
      ! phrase 3
      ! [3: if h provides the property carrying capacity begin]
        if (  (I7_Provides(t_0, false,capacity))  )   {
         ! phrase 4
         ! [4: if h is a supporter begin]
           if ((t_0 ofclass K6_supporter))   {
            ! phrase 5
            ! [5: if the number of things on h is at least the carrying capacity of h begin]
              if ((  (Prop_4(t_0))   >= AccessProp(t_0,capacity)))   {
               ! phrase 6
               ! [6: if the actor is the player , say ~There is no more room on [the H].~]
                 if ((actor == player)) { say__c=0; say__p=1;  print (I7_string) SC_15;    print (the) t_0;    print (I7_string) SC_14;   new_line; .L_Say6;   }
               ! phrase 7
               ! [7: stop the action]
                 rtrue;  
               ! phrase 8
               ! [8: end if]
               }

            ! phrase 9
            ! [9: otherwise if h is a container]
              } else if ((t_0 ofclass K5_container)) {  
            ! phrase 10
            ! [10: if the number of things in h is at least the carrying capacity of h begin]
              if ((  (Prop_5(t_0))   >= AccessProp(t_0,capacity)))   {
               ! phrase 11
               ! [11: if the actor is the player , say ~There is no more room in [the H].~]
                 if ((actor == player)) { say__c=0; say__p=1;  print (I7_string) SC_16;    print (the) t_0;    print (I7_string) SC_14;   new_line; .L_Say7;   }
               ! phrase 12
               ! [12: stop the action]
                 rtrue;  
               ! phrase 13
               ! [13: end if]
               }

            ! phrase 14
            ! [14: end if]
            }

         ! phrase 15
         ! [15: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_52, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Dropping (B123_carry_out_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor dropping ( this is the standard dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor dropping ( this is the standard dropping rule ):
[ R_53 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_53);
      ! phrase 1
      ! [1: now the noun is in the holder of the actor]
        I7_Move(noun,  (I7_Holder(actor))  );  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_53, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Dropping (B124_report_dropping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor dropping ( this is the standard report dropping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor dropping ( this is the standard report dropping rule ):
[ R_54 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_54);
      ! phrase 1
      ! [1: if the actor is the player , issue library message dropping action number 4 for the noun]
        if ((actor == player)) {   GL__M(##Drop,4,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] puts down [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_17;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say8;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_54, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Putting it on (B125_check_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor putting something on ( this is the convert put to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor putting something on ( this is the can't put what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor putting something on ( this is the can't put something on itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor putting something on ( this is the can't put onto something being carried rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor putting something on ( this is the can't put clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor putting something on ( this is the convert put to drop where possible rule ):
[ R_55 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_55);
      ! phrase 1
      ! [1: if the second noun is down or the actor is on the second noun , convert to the dropping action on the noun]
        if (((second == d_obj)) || ((second == I7_OnWhat(actor)))) {   return GVS_Convert(##Drop,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_55, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put what's not held rule ):
[ R_56 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_56);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
        if ((actor == I7_CarriedBy(noun))) {   rfalse;     }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
        if ((actor == I7_WornBy(noun))) {   rfalse;     }
      ! phrase 3
      ! [3: stop the action with library message putting it on action number 1 for the noun]
        return GL__M(##PutOn,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_56, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put something on itself rule ):
[ R_57 
    t_0 ! Local variable e.g. 'noun-CPC' = OBJECT_TY
    t_1 ! Local variable e.g. 'second-CPC' = OBJECT_TY
    t_2 ! Local variable e.g. 'transfer ceiling' = OBJECT_TY
    ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_57);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
        t_0 =   OIU_Core(noun)  ;  
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
        t_1 =   OIU_Core(second)  ;  
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
        t_2 =   (OIU_CommonAncestor(t_0, t_1))  ;  
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message putting it on action number 2 for the noun]
        if ((t_2 == t_0)) {   return GL__M(##PutOn,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_57, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto what's not a supporter rule ):
[ R_58 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_58);
      ! phrase 1
      ! [1: if the second noun is not a supporter , stop the action with library message putting it on action number 3 for the second noun]
        if ((Prop_6(second))) {   return GL__M(##PutOn,3,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_58, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put onto something being carried rule ):
[ R_59 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_59);
      ! phrase 1
      ! [1: if the actor encloses the second noun , stop the action with library message putting it on action number 4 for the second noun]
        if ((I7_IndirectlyContains(actor,second))) {   return GL__M(##PutOn,4,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_59, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put clothes being worn rule ):
[ R_60 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_60);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message putting it on action number 5 for the noun]
           GL__M(##PutOn,5,noun);  
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_60, true);
   rfalse;
];
! From the Standard Rules
! Check an actor putting something on ( this is the can't put if this exceeds carrying capacity rule ):
[ R_61 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_61);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
        if (  (I7_Provides(second, false,capacity))  )   {
         ! phrase 2
         ! [2: if the number of things on the second noun is at least the carrying capacity of the second noun , stop the action with library message putting it on action number 6 for the second noun]
           if ((  (Prop_7(second))   >= AccessProp(second,capacity))) {   return GL__M(##PutOn,6,second);     }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_61, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Putting it on (B126_carry_out_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor putting something on ( this is the standard putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor putting something on ( this is the standard putting rule ):
[ R_62 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_62);
      ! phrase 1
      ! [1: now the noun is on the second noun]
        I7_Move(noun,second);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_62, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Putting it on (B127_report_putting_it_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor putting something on ( this is the concise report putting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor putting something on ( this is the standard report putting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor putting something on ( this is the concise report putting rule ):
[ R_63 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_63);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message putting it on action number 7 for the noun]
        if (((actor == player)) && (  (multiflag==1)  )) {   return GL__M(##PutOn,7,noun);     }
      ! phrase 2
      ! [2: otherwise continue the action]
        else {   rfalse;     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_63, true);
   rfalse;
];
! From the Standard Rules
! Report an actor putting something on ( this is the standard report putting rule ):
[ R_64 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_64);
      ! phrase 1
      ! [1: if the actor is the player , issue library message putting it on action number 8 for the noun]
        if ((actor == player)) {   GL__M(##PutOn,8,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] puts [the noun] on [the second noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_18;    print (the) noun;    print (I7_string) SC_19;    print (the) second;    print (I7_string) SC_14;   new_line; .L_Say9;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_64, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Inserting it into (B128_check_inserting_it_into)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor inserting something into ( this is the can't insert what's not held rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor inserting something into ( this is the can't insert something into itself rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor inserting something into ( this is the convert insert to drop where possible rule ):
[ R_65 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_65);
      ! phrase 1
      ! [1: if the second noun is down or the actor is in the second noun , convert to the dropping action on the noun]
        if (((second == d_obj)) || ((second == I7_InWhat(actor)))) {   return GVS_Convert(##Drop,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_65, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert what's not held rule ):
[ R_66 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_66);
      ! phrase 1
      ! [1: if the actor is carrying the noun , continue the action]
        if ((actor == I7_CarriedBy(noun))) {   rfalse;     }
      ! phrase 2
      ! [2: if the actor is wearing the noun , continue the action]
        if ((actor == I7_WornBy(noun))) {   rfalse;     }
      ! phrase 3
      ! [3: stop the action with library message inserting it into action number 1 for the noun]
        return GL__M(##Insert,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_66, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert something into itself rule ):
[ R_67 
    t_0 ! Local variable e.g. 'noun-CPC' = OBJECT_TY
    t_1 ! Local variable e.g. 'second-CPC' = OBJECT_TY
    t_2 ! Local variable e.g. 'transfer ceiling' = OBJECT_TY
    ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_67);
      ! phrase 1
      ! [1: let the noun-cpc be the component parts core of the noun]
        t_0 =   OIU_Core(noun)  ;  
      ! phrase 2
      ! [2: let the second-cpc be the component parts core of the second noun]
        t_1 =   OIU_Core(second)  ;  
      ! phrase 3
      ! [3: let the transfer ceiling be the common ancestor of the noun-cpc with the second-cpc]
        t_2 =   (OIU_CommonAncestor(t_0, t_1))  ;  
      ! phrase 4
      ! [4: if the transfer ceiling is the noun-cpc , stop the action with library message inserting it into action number 5 for the noun]
        if ((t_2 == t_0)) {   return GL__M(##Insert,5,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_67, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into closed containers rule ):
[ R_68 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_68);
      ! phrase 1
      ! [1: if the second noun is a closed container , stop the action with library message inserting it into action number 3 for the second noun]
        if (((second ofclass K5_container) && (I7GetEitherOr(second,open)==false))) {   return GL__M(##Insert,3,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_68, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert into what's not a container rule ):
[ R_69 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_69);
      ! phrase 1
      ! [1: if the second noun is not a container , stop the action with library message inserting it into action number 2 for the second noun]
        if ((Prop_8(second))) {   return GL__M(##Insert,2,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_69, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert clothes being worn rule ):
[ R_70 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_70);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message inserting it into action number 6 for the noun]
           GL__M(##Insert,6,noun);  
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_70, true);
   rfalse;
];
! From the Standard Rules
! Check an actor inserting something into ( this is the can't insert if this exceeds carrying capacity rule ):
[ R_71 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_71);
      ! phrase 1
      ! [1: if the second noun provides the property carrying capacity begin]
        if (  (I7_Provides(second, false,capacity))  )   {
         ! phrase 2
         ! [2: if the number of things in the second noun is at least the carrying capacity of the second noun , stop the action with library message inserting it into action number 7 for the second noun]
           if ((  (Prop_9(second))   >= AccessProp(second,capacity))) {   return GL__M(##Insert,7,second);     }
         ! phrase 3
         ! [3: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_71, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Inserting it into (B129_carry_out_inserting_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor inserting something into ( this is the standard inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor inserting something into ( this is the standard inserting rule ):
[ R_72 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_72);
      ! phrase 1
      ! [1: now the noun is in the second noun]
        I7_Move(noun,second);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_72, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Inserting it into (B130_report_inserting_it_int)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor inserting something into ( this is the concise report inserting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor inserting something into ( this is the standard report inserting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor inserting something into ( this is the concise report inserting rule ):
[ R_73 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_73);
      ! phrase 1
      ! [1: if the actor is the player and the i6 parser is running multiple actions , stop the action with library message inserting it into action number 8 for the noun]
        if (((actor == player)) && (  (multiflag==1)  )) {   return GL__M(##Insert,8,noun);     }
      ! phrase 2
      ! [2: otherwise continue the action]
        else {   rfalse;     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_73, true);
   rfalse;
];
! From the Standard Rules
! Report an actor inserting something into ( this is the standard report inserting rule ):
[ R_74 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_74);
      ! phrase 1
      ! [1: if the actor is the player , issue library message inserting it into action number 9 for the noun]
        if ((actor == player)) {   GL__M(##Insert,9,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] puts [the noun] into [the second noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_18;    print (the) noun;    print (I7_string) SC_20;    print (the) second;    print (I7_string) SC_14;   new_line; .L_Say10;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_74, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Eating (B131_check_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor eating ( this is the can't eat unless edible rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor eating ( this is the can't eat unless edible rule ):
[ R_75 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_75);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not edible , stop the action with library message eating action number 1 for the noun]
        if (((Prop_10(noun))) || (~~((I7GetEitherOr(noun,edible))))) {   return GL__M(##Eat,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_75, true);
   rfalse;
];
! From the Standard Rules
! Check an actor eating ( this is the can't eat clothing without removing it first rule ):
[ R_76 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_76);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
           GL__M(##Drop,3,noun);  
         ! phrase 3
         ! [3: try the actor trying taking off the noun]
           I7_TryAction(0, actor, ##Disrobe, noun, 0);;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_76, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Eating (B132_carry_out_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor eating ( this is the standard eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor eating ( this is the standard eating rule ):
[ R_77 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_77);
      ! phrase 1
      ! [1: remove the noun from play]
        I7_Remove(noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_77, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Eating (B133_report_eating)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor eating ( this is the standard report eating rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor eating ( this is the standard report eating rule ):
[ R_78 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_78);
      ! phrase 1
      ! [1: if the actor is the player , issue library message eating action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Eat,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] eats [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_21;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say11;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_78, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Going (B134_check_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/5 ! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
!   === which is equally specific with ===
! Rule 2/5 ! Check an actor going ( this is the can't go through concealed doors rule ):
!   === which is equally specific with ===
! Rule 3/5 ! Check an actor going ( this is the can't go through closed doors rule ):
!   === which is equally specific with ===
! Rule 4/5 ! Check an actor going ( this is the determine map connection rule ):
!   === which is equally specific with ===
! Rule 5/5 ! Check an actor going ( this is the can't go that way rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor going ( this is the can't travel in what's not a vehicle rule ):
[ R_80 
    t_0 ! Local variable e.g. 'H' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_80);
      ! phrase 1
      ! [1: let h be the holder of the actor]
        t_0 =   (I7_Holder(actor))  ;  
      ! phrase 2
      ! [2: if h is the room gone from , continue the action]
        if ((t_0 == (MStack-->MstVO(20007,0)))) {   rfalse;     }
      ! phrase 3
      ! [3: if h is the vehicle gone by , continue the action]
        if ((t_0 == (MStack-->MstVO(20007,3)))) {   rfalse;     }
      ! phrase 4
      ! [4: stop the action with library message going action number 1 for h]
        return GL__M(##Go,1,t_0);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_80, true);
   rfalse;
];
! From the Standard Rules
! Check an actor going ( this is the can't go through concealed doors rule ):
[ R_81 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_81);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is undescribed , stop the action with library message going action number 2 for the room gone from]
        if ((~~(((MStack-->MstVO(20007,2)) == nothing))) && ((I7GetEitherOr((MStack-->MstVO(20007,2)),concealed)))) {   return GL__M(##Go,2,(MStack-->MstVO(20007,0)));     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_81, true);
   rfalse;
];
! From the Standard Rules
! Check an actor going ( this is the can't go through closed doors rule ):
[ R_82 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_82);
      ! phrase 1
      ! [1: if the door gone through is not nothing and the door gone through is closed begin]
        if ((~~(((MStack-->MstVO(20007,2)) == nothing))) && ((I7GetEitherOr((MStack-->MstVO(20007,2)),open)==false)))   {
         ! phrase 2
         ! [2: if the noun is up , stop the action with library message going action number 3 for the door gone through]
           if ((noun == u_obj)) {   return GL__M(##Go,3,(MStack-->MstVO(20007,2)));     }
         ! phrase 3
         ! [3: if the noun is down , stop the action with library message going action number 4 for the door gone through]
           if ((noun == d_obj)) {   return GL__M(##Go,4,(MStack-->MstVO(20007,2)));     }
         ! phrase 4
         ! [4: stop the action with library message going action number 5 for the door gone through]
           return GL__M(##Go,5,(MStack-->MstVO(20007,2)));  
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_82, true);
   rfalse;
];
! From the Standard Rules
! Check an actor going ( this is the determine map connection rule ):
[ R_83 
    t_0 ! Local variable e.g. 'target' = OBJECT_TY
    t_1 ! Local variable e.g. 'direction D' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_83);
      ! phrase 1
      ! [1: let the target be nothing]
        t_0 = nothing;  
      ! phrase 2
      ! [2: if the noun is a direction begin]
        if ((noun ofclass K3_direction))   {
         ! phrase 3
         ! [3: let direction d be the noun]
           t_1 = noun;  
         ! phrase 4
         ! [4: let the target be the room-or-door direction d from the room gone from]
           t_0 = (Resolver_0(t_1,(MStack-->MstVO(20007,0)), "source", 1271));  
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: if the noun is a door , let the target be the noun]
           if ((noun ofclass K4_door)) {   t_0 = noun;     }
         ! phrase 7
         ! [7: end if]
         }

      ! phrase 8
      ! [8: if the target is a door begin]
        if ((t_0 ofclass K4_door))   {
         ! phrase 9
         ! [9: now the target is the other side of the target from the room gone from]
           t_0 = (Resolver_1(t_0,(MStack-->MstVO(20007,0)), "source", 1277));  
         ! phrase 10
         ! [10: end if]
         }

      ! phrase 11
      ! [11: now the room gone to is the target]
        (MStack-->MstVO(20007,1)) = t_0;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_83, true);
   rfalse;
];
! From the Standard Rules
! Check an actor going ( this is the can't go that way rule ):
[ R_84 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_84);
      ! phrase 1
      ! [1: if the room gone to is nothing begin]
        if (((MStack-->MstVO(20007,1)) == nothing))   {
         ! phrase 2
         ! [2: if the door gone through is nothing , stop the action with library message going action number 2 for the room gone from]
           if (((MStack-->MstVO(20007,2)) == nothing)) {   return GL__M(##Go,2,(MStack-->MstVO(20007,0)));     }
         ! phrase 3
         ! [3: stop the action with library message going action number 6 for the door gone through]
           return GL__M(##Go,6,(MStack-->MstVO(20007,2)));  
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_84, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Going (B135_carry_out_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Carry out an actor going ( this is the move player and vehicle rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Carry out an actor going ( this is the move floating objects rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Carry out an actor going ( this is the check light in new location rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor going ( this is the move player and vehicle rule ):
[ R_85 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_85);
      ! phrase 1
      ! [1: if the vehicle gone by is nothing , surreptitiously move the actor to the room gone to]
        if (((MStack-->MstVO(20007,3)) == nothing)) {   I7_SurreptitiousMove(actor, (MStack-->MstVO(20007,1)));     }
      ! phrase 2
      ! [2: otherwise surreptitiously move the vehicle gone by to the room gone to]
        else {   I7_SurreptitiousMove((MStack-->MstVO(20007,3)), (MStack-->MstVO(20007,1)));     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_85, true);
   rfalse;
];
! From the Standard Rules
! Carry out an actor going ( this is the move floating objects rule ):
[ R_86 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_86);
      ! phrase 1
      ! [1: if the actor is the player , surreptitiously move floating objects]
        if ((actor == player)) {   MoveFloatingObjects();     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_86, true);
   rfalse;
];
! From the Standard Rules
! Carry out an actor going ( this is the check light in new location rule ):
[ R_87 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_87);
      ! phrase 1
      ! [1: if the actor is the player , surreptitiously reckon dark in move from the room gone from to the room gone to]
        if ((actor == player)) { (Resolver_3((MStack-->MstVO(20007,0)),(MStack-->MstVO(20007,1)), "source", 1300));   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_87, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Going (B136_report_going)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor going ( this is the describe room gone into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor going ( this is the describe room gone into rule ):
[ R_88 
    t_0 ! Local variable e.g. 'back way' = OBJECT_TY
    t_1 ! Local variable e.g. 'room back the other way' = OBJECT_TY
    t_2 ! Local variable e.g. 'room normally this way' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_88);
      ! phrase 1
      ! [1: if the player is the actor begin]
        if ((player == actor))   {
         ! phrase 2
         ! [2: produce a room description with going spacing conventions]
           I7_RoomDescriptionForGoing();  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The actor]~]
         say__c=0; say__p=1;  print (The) actor;   .L_Say12;
         ! phrase 5
         ! [5: if the noun is a direction begin]
           if ((noun ofclass K3_direction))   {
            ! phrase 6
            ! [6: if the location is the room gone from , say ~ goes ~]
              if ((real_location == (MStack-->MstVO(20007,0)))) { say__c=0; say__p=1;  print (I7_string) SC_22;   .L_Say13;   }
            ! phrase 7
            ! [7: otherwise say ~ arrives~]
              else { say__c=0; say__p=1;  print (I7_string) SC_23;   .L_Say14;   }
            ! phrase 8
            ! [8: let the back way be the opposite of the noun]
              t_0 = AccessProp(noun,p10_opposite);  
            ! phrase 9
            ! [9: if the location is the room gone to begin]
              if ((real_location == (MStack-->MstVO(20007,1))))   {
               ! phrase 10
               ! [10: let the room back the other way be the room back way from the location]
                 t_1 = (Resolver_4(t_0,real_location, "source", 1316));  
               ! phrase 11
               ! [11: let the room normally this way be the room noun from the room gone from]
                 t_2 = (Resolver_4(noun,(MStack-->MstVO(20007,0)), "source", 1318));  
               ! phrase 12
               ! [12: if the room back the other way is the room gone from or the room back the other way is the room normally this way begin]
                 if (((t_1 == (MStack-->MstVO(20007,0)))) || ((t_1 == t_2)))   {
                  ! phrase 13
                  ! [13: say ~ from [if the back way is up]above[otherwise if the	back way is down]below[otherwise]the [back way]~]
                  say__c=0; say__p=1;  print (I7_string) SC_24;   
.L_Say15; if (((t_0 == u_obj))) say__c=true; else jump L_Say16;    print (I7_string) SC_25;   
.L_Say16; if (say__c==false) { say__c=((((t_0 == d_obj)))==true);
		if (say__c==false) jump L_Say17;
	} else jump L_Say17;
   print (I7_string) SC_26;  
.L_Say17; if (say__c==false) say__c=true; else jump L_Say18;    print (I7_string) SC_27;    print (name) t_0;   .L_Say18;
                  ! phrase 14
                  ! [14: end if]
                  }

               ! phrase 15
               ! [15: otherwise]
               } else {

               ! phrase 16
               ! [16: if the location is the room gone from begin]
                 if ((real_location == (MStack-->MstVO(20007,0))))   {
                  ! phrase 17
                  ! [17: say ~[if the noun is up]up[otherwise if the	noun is down]down[otherwise][noun]~]
                  say__c=0; say__p=1; 
.L_Say19; if (((noun == u_obj))) say__c=true; else jump L_Say20;    print (I7_string) SC_28;   
.L_Say20; if (say__c==false) { say__c=((((noun == d_obj)))==true);
		if (say__c==false) jump L_Say21;
	} else jump L_Say21;
   print (I7_string) SC_29;  
.L_Say21; if (say__c==false) say__c=true; else jump L_Say22;    print (name) noun;   .L_Say22;
                  ! phrase 18
                  ! [18: otherwise]
                  } else {

                  ! phrase 19
                  ! [19: say ~ at [the room gone to] from [if the back way is	up]above[otherwise if the back way is	down]below[otherwise]the [back way]~]
                  say__c=0; say__p=1;  print (I7_string) SC_30;    print (the) (MStack-->MstVO(20007,1));    print (I7_string) SC_24;   
.L_Say23; if (((t_0 == u_obj))) say__c=true; else jump L_Say24;    print (I7_string) SC_25;   
.L_Say24; if (say__c==false) { say__c=((((t_0 == d_obj)))==true);
		if (say__c==false) jump L_Say25;
	} else jump L_Say25;
   print (I7_string) SC_26;  
.L_Say25; if (say__c==false) say__c=true; else jump L_Say26;    print (I7_string) SC_27;    print (name) t_0;   .L_Say26;
                  ! phrase 20
                  ! [20: end if]
                  }

               ! phrase 21
               ! [21: end if]
               }

            ! phrase 22
            ! [22: otherwise]
            } else {

            ! phrase 23
            ! [23: say ~[if the location is the room gone from] goes through	[otherwise] arrives from [end if][the noun]~]
            say__c=0; say__p=1; 
.L_Say27; if (((real_location == (MStack-->MstVO(20007,0))))) say__c=true; else jump L_Say28;    print (I7_string) SC_31;  
.L_Say28; if (say__c==false) say__c=true; else jump L_Say29;    print (I7_string) SC_32;   
.L_Say29; say__c = false;    print (the) noun;   .L_Say30;
            ! phrase 24
            ! [24: end if]
            }

         ! phrase 25
         ! [25: if the vehicle gone by is not nothing begin]
           if (~~(((MStack-->MstVO(20007,3)) == nothing)))   {
            ! phrase 26
            ! [26: if the vehicle gone by is a supporter , say ~ on ~]
              if (((MStack-->MstVO(20007,3)) ofclass K6_supporter)) { say__c=0; say__p=1;  print (I7_string) SC_19;   .L_Say31;   }
            ! phrase 27
            ! [27: otherwise say ~ in ~]
              else { say__c=0; say__p=1;  print (I7_string) SC_33;   .L_Say32;   }
            ! phrase 28
            ! [28: say ~[the vehicle gone by]~]
            say__c=0; say__p=1;  print (the) (MStack-->MstVO(20007,3));   .L_Say33;
            ! phrase 29
            ! [29: end if]
            }

         ! phrase 30
         ! [30: if the thing gone with is not nothing begin]
           if (~~(((MStack-->MstVO(20007,4)) == nothing)))   {
            ! phrase 31
            ! [31: say ~, pushing [the thing gone with]~]
            say__c=0; say__p=1;  print (I7_string) SC_34;    print (the) (MStack-->MstVO(20007,4));   .L_Say34;
            ! phrase 32
            ! [32: if the player is within the thing gone with begin]
              if (((MStack-->MstVO(20007,4)) == I7_InWhat(player)))   {
               ! phrase 33
               ! [33: say ~ in front, and you along too~]
               say__c=0; say__p=1;  print (I7_string) SC_35;   .L_Say35;
               ! phrase 34
               ! [34: otherwise if the player is within the vehicle gone by]
                 } else if (((MStack-->MstVO(20007,3)) == I7_InWhat(player))) {  
               ! phrase 35
               ! [35: say ~ in front~]
               say__c=0; say__p=1;  print (I7_string) SC_36;   .L_Say36;
               ! phrase 36
               ! [36: otherwise if the location is the room gone from]
                 } else if ((real_location == (MStack-->MstVO(20007,0)))) {  
               ! phrase 37
               ! [37: say ~ away~]
               say__c=0; say__p=1;  print (I7_string) SC_37;   .L_Say37;
               ! phrase 38
               ! [38: otherwise]
               } else {

               ! phrase 39
               ! [39: say ~ in~]
               say__c=0; say__p=1;  print (I7_string) SC_38;   .L_Say38;
               ! phrase 40
               ! [40: end if]
               }

            ! phrase 41
            ! [41: end if]
            }

         ! phrase 42
         ! [42: if the player is within the vehicle gone by and the player is not within the thing gone with begin]
           if ((((MStack-->MstVO(20007,3)) == I7_InWhat(player))) && (~~(((MStack-->MstVO(20007,4)) == I7_InWhat(player)))))   {
            ! phrase 43
            ! [43: say ~, taking you along.~]
            say__c=0; say__p=1;  print (I7_string) SC_39;   new_line; .L_Say39;
            ! phrase 44
            ! [44: try looking]
              I7_TryAction(0, player, ##Look, 0, 0);;  
            ! phrase 45
            ! [45: continue the action]
              rfalse;  
            ! phrase 46
            ! [46: end if]
            }

         ! phrase 47
         ! [47: say ~.~]
         say__c=0; say__p=1;  print (I7_string) SC_14;   new_line; .L_Say40;
         ! phrase 48
         ! [48: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_88, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Entering (B137_check_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/7 ! Check an actor entering ( this is the convert enter door into go rule ):
!   === which is equally specific with ===
! Rule 2/7 ! Check an actor entering ( this is the convert enter compass direction into go rule ):
!   === which is equally specific with ===
! Rule 3/7 ! Check an actor entering ( this is the can't enter what's already entered rule ):
!   === which is equally specific with ===
! Rule 4/7 ! Check an actor entering ( this is the can't enter what's not enterable rule ):
!   === which is equally specific with ===
! Rule 5/7 ! Check an actor entering ( this is the can't enter closed containers rule ):
!   === which is equally specific with ===
! Rule 6/7 ! Check an actor entering ( this is the can't enter something carried rule ):
!   === which is equally specific with ===
! Rule 7/7 ! Check an actor entering ( this is the implicitly pass through other barriers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor entering ( this is the convert enter door into go rule ):
[ R_89 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_89);
      ! phrase 1
      ! [1: if the noun is a door , convert to the going action on the noun]
        if ((noun ofclass K4_door)) {   return GVS_Convert(##Go,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_89, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the convert enter compass direction into go rule ):
[ R_90 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_90);
      ! phrase 1
      ! [1: if the noun is a direction , convert to the going action on the noun]
        if ((noun ofclass K3_direction)) {   return GVS_Convert(##Go,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_90, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's already entered rule ):
[ R_91 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_91);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 2
      ! [2: if the local ceiling is the noun , stop the action with library message entering action number 1 for the noun]
        if ((t_0 == noun)) {   return GL__M(##Enter,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_91, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the can't enter what's not enterable rule ):
[ R_92 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_92);
      ! phrase 1
      ! [1: if the noun is not enterable , stop the action with library message entering action number 2 for the noun]
        if (~~((I7GetEitherOr(noun,enterable)))) {   return GL__M(##Enter,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_92, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the can't enter closed containers rule ):
[ R_93 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_93);
      ! phrase 1
      ! [1: if the noun is a closed container , stop the action with library message entering action number 3 for the noun]
        if (((noun ofclass K5_container) && (I7GetEitherOr(noun,open)==false))) {   return GL__M(##Enter,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_93, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the can't enter something carried rule ):
[ R_94 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_94);
      ! phrase 1
      ! [1: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 2
      ! [2: if the local ceiling is the actor , stop the action with library message entering action number 4 for the noun]
        if ((t_0 == actor)) {   return GL__M(##Enter,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_94, true);
   rfalse;
];
! From the Standard Rules
! Check an actor entering ( this is the implicitly pass through other barriers rule ):
[ R_95 
    t_0 ! Local variable e.g. 'local ceiling' = OBJECT_TY
    t_1 ! Local variable e.g. 'target' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_95);
      ! phrase 1
      ! [1: if the holder of the actor is the holder of the noun , continue the action]
        if ((  (I7_Holder(actor))   ==   (I7_Holder(noun))  )) {   rfalse;     }
      ! phrase 2
      ! [2: let the local ceiling be the common ancestor of the actor with the noun]
        t_0 =   (OIU_CommonAncestor(actor, noun))  ;  
      ! phrase 3
      ! [3: while the holder of the actor is not the local ceiling begin]
        while (~~((  (I7_Holder(actor))   == t_0)))   {
         ! phrase 4
         ! [4: let the target be the holder of the actor]
           t_1 =   (I7_Holder(actor))  ;  
         ! phrase 5
         ! [5: issue library message entering action number 6 for the target]
           GL__M(##Enter,6,t_1);  
         ! phrase 6
         ! [6: silently try the actor trying exiting]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Exit, 0, 0);; @pull keep_silent;  
         ! phrase 7
         ! [7: if the holder of the actor is the target , stop the action]
           if ((  (I7_Holder(actor))   == t_1)) {   rtrue;     }
         ! phrase 8
         ! [8: end while]
         }

      ! phrase 9
      ! [9: if the holder of the actor is the noun , stop the action]
        if ((  (I7_Holder(actor))   == noun)) {   rtrue;     }
      ! phrase 10
      ! [10: if the holder of the actor is the holder of the noun , continue the action]
        if ((  (I7_Holder(actor))   ==   (I7_Holder(noun))  )) {   rfalse;     }
      ! phrase 11
      ! [11: let the target be the holder of the noun]
        t_1 =   (I7_Holder(noun))  ;  
      ! phrase 12
      ! [12: if the noun is part of the target , let the target be the holder of the target]
        if ((t_1 == (noun.component_parent))) {   t_1 =   (I7_Holder(t_1))  ;     }
      ! phrase 13
      ! [13: while the target is a thing begin]
        while ((t_1 ofclass K2_thing))   {
         ! phrase 14
         ! [14: if the holder of the target is the local ceiling begin]
           if ((  (I7_Holder(t_1))   == t_0))   {
            ! phrase 15
            ! [15: issue library message entering action number 7 for the target]
              GL__M(##Enter,7,t_1);  
            ! phrase 16
            ! [16: silently try the actor trying entering the target]
              @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Enter, t_1, 0);; @pull keep_silent;  
            ! phrase 17
            ! [17: if the holder of the actor is not the target , stop the action]
              if (~~((  (I7_Holder(actor))   == t_1))) {   rtrue;     }
            ! phrase 18
            ! [18: convert to the entering action on the noun]
              return GVS_Convert(##Enter,noun,0);  
            ! phrase 19
            ! [19: continue the action]
              rfalse;  
            ! phrase 20
            ! [20: end if]
            }

         ! phrase 21
         ! [21: let the target be the holder of the target]
           t_1 =   (I7_Holder(t_1))  ;  
         ! phrase 22
         ! [22: end while]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_95, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Entering (B138_carry_out_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor entering ( this is the standard entering rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor entering ( this is the standard entering rule ):
[ R_96 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_96);
      ! phrase 1
      ! [1: move the actor to the noun at object tree level]
        move actor to noun;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_96, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Entering (B139_report_entering)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor entering ( this is the standard report entering rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor entering ( this is the describe contents entered into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor entering ( this is the standard report entering rule ):
[ R_97 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_97);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message entering action number 5 for the noun]
           GL__M(##Enter,5,noun);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The actor] gets [if the noun is a container]into[otherwise]onto[end if] [the noun].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_40;   
.L_Say41; if (((noun ofclass K5_container))) say__c=true; else jump L_Say42;    print (I7_string) SC_41;  
.L_Say42; if (say__c==false) say__c=true; else jump L_Say43;    print (I7_string) SC_42;   
.L_Say43; say__c = false;    print (I7_string) SC_43;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say44;
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_97, true);
   rfalse;
];
! From the Standard Rules
! Report an actor entering ( this is the describe contents entered into rule ):
[ R_98 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_98);
      ! phrase 1
      ! [1: if the actor is the player , describe the locale of the noun]
        if ((actor == player)) {   Locale(noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_98, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Exiting (B140_check_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor exiting ( this is the convert exit into go out rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor exiting ( this is the can't exit when not inside anything rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor exiting ( this is the can't exit closed containers rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor exiting ( this is the convert exit into get off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into go out rule ):
[ R_100 
    t_0 ! Local variable e.g. 'local room' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_100);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
        t_0 =   I7_Location(actor)  ;  
      ! phrase 2
      ! [2: if the container exited from is the local room begin]
        if (((MStack-->MstVO(20009,0)) == t_0))   {
         ! phrase 3
         ! [3: if the room-or-door outside from the local room is not nothing , convert to the going action on the outside]
           if (~~(((Resolver_5(out_obj,t_0, "source", 1474)) == nothing))) {   return GVS_Convert(##Go,out_obj,0);     }
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_100, true);
   rfalse;
];
! From the Standard Rules
! Check an actor exiting ( this is the can't exit when not inside anything rule ):
[ R_101 
    t_0 ! Local variable e.g. 'local room' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_101);
      ! phrase 1
      ! [1: let the local room be the location of the actor]
        t_0 =   I7_Location(actor)  ;  
      ! phrase 2
      ! [2: if the container exited from is the local room , stop the action with library message exiting action number 1 for the actor]
        if (((MStack-->MstVO(20009,0)) == t_0)) {   return GL__M(##Exit,1,actor);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_101, true);
   rfalse;
];
! From the Standard Rules
! Check an actor exiting ( this is the can't exit closed containers rule ):
[ R_102 
    t_0 ! Local variable e.g. 'cage' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_102);
      ! phrase 1
      ! [1: if the actor is in a closed container ( called the cage ) , stop the action with library message exiting action number 2 for the cage]
        if (((t_0=I7_InWhat(actor)) && (I7_InWhat(actor) ofclass K5_container) && (I7GetEitherOr(I7_InWhat(actor),open)==false))) {   return GL__M(##Exit,2,t_0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_102, true);
   rfalse;
];
! From the Standard Rules
! Check an actor exiting ( this is the convert exit into get off rule ):
[ R_103 
    t_0 ! Local variable e.g. 'platform' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_103);
      ! phrase 1
      ! [1: if the actor is on a supporter ( called the platform ) , convert to the getting off action on the platform]
        if (((t_0=I7_OnWhat(actor)) && (I7_OnWhat(actor) ofclass K6_supporter))) {   return GVS_Convert(##GetOff,t_0,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_103, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Exiting (B141_carry_out_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor exiting ( this is the standard exiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor exiting ( this is the standard exiting rule ):
[ R_104 
    t_0 ! Local variable e.g. 'former exterior' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_104);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the container exited from]
        t_0 =   (OIU_Parent((MStack-->MstVO(20009,0))))  ;  
      ! phrase 2
      ! [2: move the actor to the former exterior at object tree level]
        move actor to t_0;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_104, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Exiting (B142_report_exiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor exiting ( this is the standard report exiting rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor exiting ( this is the describe room emerged into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor exiting ( this is the standard report exiting rule ):
[ R_105 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_105);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the container exited from]
           GL__M(##Exit,3,(MStack-->MstVO(20009,0)));  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The actor] gets out of [the container exited from].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_44;    print (the) (MStack-->MstVO(20009,0));    print (I7_string) SC_14;   new_line; .L_Say45;
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_105, true);
   rfalse;
];
! From the Standard Rules
! Report an actor exiting ( this is the describe room emerged into rule ):
[ R_106 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_106);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
        if ((actor == player)) {   I7_RoomDescriptionForGoing();     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_106, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Getting off (B143_check_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor getting off ( this is the can't get off things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor getting off ( this is the can't get off things rule ):
[ R_107 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_107);
      ! phrase 1
      ! [1: if the actor is on the noun , continue the action]
        if ((noun == I7_OnWhat(actor))) {   rfalse;     }
      ! phrase 2
      ! [2: if the actor is carried by the noun , continue the action]
        if ((noun == I7_CarriedBy(actor))) {   rfalse;     }
      ! phrase 3
      ! [3: stop the action with library message getting off action number 1 for the noun]
        return GL__M(##GetOff,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_107, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Getting off (B144_carry_out_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor getting off ( this is the standard getting off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor getting off ( this is the standard getting off rule ):
[ R_108 
    t_0 ! Local variable e.g. 'former exterior' = OBJECT_TY
    ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_108);
      ! phrase 1
      ! [1: let the former exterior be the not-counting-parts holder of the noun]
        t_0 =   (OIU_Parent(noun))  ;  
      ! phrase 2
      ! [2: move the actor to the former exterior at object tree level]
        move actor to t_0;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_108, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Getting off (B145_report_getting_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor getting off ( this is the standard report getting off rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor getting off ( this is the describe room stood up into rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor getting off ( this is the standard report getting off rule ):
[ R_109 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_109);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message exiting action number 3 for the noun]
           GL__M(##Exit,3,noun);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: say ~[The actor] gets off [the noun].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_45;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say46;
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_109, true);
   rfalse;
];
! From the Standard Rules
! Report an actor getting off ( this is the describe room stood up into rule ):
[ R_110 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_110);
      ! phrase 1
      ! [1: if the actor is the player , produce a room description with going spacing conventions]
        if ((actor == player)) {   I7_RoomDescriptionForGoing();     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_110, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking (B147_carry_out_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Carry out looking ( this is the room description heading rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Carry out looking ( this is the room description body text rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Carry out looking ( this is the room description paragraphs about objects rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Carry out looking ( this is the check new arrival rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out looking ( this is the room description heading rule ):
[ R_112 
    t_0 ! Local variable e.g. 'intermediate level' = OBJECT_TY
    t_1 ! Local variable e.g. '?-1,-1?' = NUMBER_TY
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_112);
      ! phrase 1
      ! [1: say bold type]
      say__c=0; say__p=1;  style bold;   .L_Say47;
      ! phrase 2
      ! [2: if the visibility level count is 0 begin]
        if (((MStack-->MstVO(20011,1)) == 0))   {
         ! phrase 3
         ! [3: say short name of the darkness pseudo-room]
         say__c=0; say__p=1;  print (name) thedark;   .L_Say48;
         ! phrase 4
         ! [4: otherwise if the visibility ceiling is the location]
           } else if (((MStack-->MstVO(20011,2)) == real_location)) {  
         ! phrase 5
         ! [5: say ~[visibility ceiling]~]
         say__c=0; say__p=1;  print (name) (MStack-->MstVO(20011,2));   .L_Say49;
         ! phrase 6
         ! [6: otherwise]
         } else {

         ! phrase 7
         ! [7: say ~[The visibility ceiling]~]
         say__c=0; say__p=1;  print (The) (MStack-->MstVO(20011,2));   .L_Say50;
         ! phrase 8
         ! [8: end if]
         }

      ! phrase 9
      ! [9: say roman type]
      say__c=0; say__p=1;  style roman;   .L_Say51;
      ! phrase 10
      ! [10: let intermediate level be the visibility-holder of the actor]
        t_0 =   Vis_parent(actor)  ;  
      ! phrase 11
      ! [11: repeat with intermediate level count running from 2 to the visibility level count begin]
        for (t_1=2: t_1<=(MStack-->MstVO(20011,1)): t_1++)   {
         ! phrase 12
         ! [12: issue library message looking action number 8 for the intermediate level]
           GL__M(##Look,8,t_0);  
         ! phrase 13
         ! [13: let the intermediate level be the visibility-holder of the intermediate level]
           t_0 =   Vis_parent(t_0)  ;  
         ! phrase 14
         ! [14: end repeat]
         }

      ! phrase 15
      ! [15: say line break]
      say__c=0; say__p=1;  new_line;   .L_Say52;
      ! phrase 16
      ! [16: say run paragraph on with special look spacing]
      say__c=0; say__p=1;  I7_RunOnParagraph();   .L_Say53;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_112, true);
   rfalse;
];
! From the Standard Rules
! Carry out looking ( this is the room description body text rule ):
[ R_113 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_113);
      ! phrase 1
      ! [1: describe main room area for the visibility ceiling]
        I7_RoomDescPara((MStack-->MstVO(20011,2)));  
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_113, true);
   rfalse;
];
! From the Standard Rules
! Carry out looking ( this is the room description paragraphs about objects rule ):
[ R_114 
    t_0 ! Local variable e.g. 'intermediate position' = OBJECT_TY
    t_1 ! Local variable e.g. 'IP count' = NUMBER_TY
    t_2 ! Local variable e.g. 'top-down IP count' = NUMBER_TY
    ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_114);
      ! phrase 1
      ! [1: if the visibility level count is 0 begin]
        if (((MStack-->MstVO(20011,1)) == 0))   {
         ! phrase 2
         ! [2: describe locale for the darkness pseudo-room]
           Locale(thedark);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: let the intermediate position be the actor]
           t_0 = actor;  
         ! phrase 5
         ! [5: let the ip count be the visibility level count]
           t_1 = (MStack-->MstVO(20011,1));  
         ! phrase 6
         ! [6: while the ip count is greater than 0 begin]
           while ((t_1 > 0))   {
            ! phrase 7
            ! [7: now the intermediate position is marked for listing]
              I7SetEitherOr(t_0,workflag);  
            ! phrase 8
            ! [8: let the intermediate position be the visibility-holder of the intermediate position]
              t_0 =   Vis_parent(t_0)  ;  
            ! phrase 9
            ! [9: decrease the ip count by 1]
              t_1 = t_1 - 1;  
            ! phrase 10
            ! [10: end while]
            }

         ! phrase 11
         ! [11: let the top-down ip count be the visibility level count]
           t_2 = (MStack-->MstVO(20011,1));  
         ! phrase 12
         ! [12: while the top-down ip count is greater than 0 begin]
           while ((t_2 > 0))   {
            ! phrase 13
            ! [13: let the intermediate position be the actor]
              t_0 = actor;  
            ! phrase 14
            ! [14: let the ip count be 0]
              t_1 = 0;  
            ! phrase 15
            ! [15: while the ip count is less than the top-down ip count begin]
              while ((t_1 < t_2))   {
               ! phrase 16
               ! [16: let the intermediate position be the visibility-holder of the intermediate position]
                 t_0 =   Vis_parent(t_0)  ;  
               ! phrase 17
               ! [17: increase the ip count by 1]
                 t_1 = t_1 + 1;  
               ! phrase 18
               ! [18: end while]
               }

            ! phrase 19
            ! [19: describe locale for the intermediate position]
              Locale(t_0);  
            ! phrase 20
            ! [20: decrease the top-down ip count by 1]
              t_2 = t_2 - 1;  
            ! phrase 21
            ! [21: end while]
            }

         ! phrase 22
         ! [22: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_114, true);
   rfalse;
];
! From the Standard Rules
! Carry out looking ( this is the check new arrival rule ):
[ R_115 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_115);
      ! phrase 1
      ! [1: if in darkness , mark the darkness pseudo-room as visited]
        if (  (location==thedark)  ) {   give thedark visited;     }
      ! phrase 2
      ! [2: otherwise now the location is visited]
        else {   I7SetEitherOr(real_location,visited);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_115, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking (B148_report_looking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking ( this is the other people looking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor looking ( this is the other people looking rule ):
[ R_116 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_116);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] looks around.~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_46;   new_line; .L_Say54;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_116, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Examining (B150_carry_out_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/6 ! Carry out examining ( this is the examine undescribed containers rule ):
!   === which is equally specific with ===
! Rule 2/6 ! Carry out examining ( this is the examine undescribed devices rule ):
!   === which is equally specific with ===
! Rule 3/6 ! Carry out examining ( this is the examine undescribed things rule ):
!   === which is equally specific with ===
! Rule 4/6 ! Carry out examining ( this is the examine directions rule ):
!   === which is equally specific with ===
! Rule 5/6 ! Carry out examining ( this is the standard examining rule ):
!   === which is equally specific with ===
! Rule 6/6 ! Carry out examining ( this is the examine described devices rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out examining ( this is the examine undescribed containers rule ):
[ R_117 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_117);
      ! phrase 1
      ! [1: if the noun goes undescribed by source text and the noun is a container , convert to the searching action on the noun]
        if ((  (noun.description == 0)  ) && ((noun ofclass K5_container))) {   return GVS_Convert(##Search,noun,0);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_117, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the examine undescribed devices rule ):
[ R_118 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_118);
      ! phrase 1
      ! [1: if the noun goes undescribed by source text and the noun is a device , stop the action with library message examining action number 3 for the noun]
        if ((  (noun.description == 0)  ) && ((noun ofclass K11_device))) {   return GL__M(##Examine,3,noun);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_118, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the examine undescribed things rule ):
[ R_119 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_119);
      ! phrase 1
      ! [1: if the noun goes undescribed by source text , stop the action with library message examining action number 2 for the noun]
        if (  (noun.description == 0)  ) {   return GL__M(##Examine,2,noun);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_119, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the examine directions rule ):
[ R_120 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_120);
      ! phrase 1
      ! [1: if the noun is a direction begin]
        if ((noun ofclass K3_direction))   {
         ! phrase 2
         ! [2: say ~You see nothing unexpected in that direction.~]
         say__c=0; say__p=1;  print (I7_string) SC_47;   new_line; .L_Say55;
         ! phrase 3
         ! [3: stop the action]
           rtrue;  
         ! phrase 4
         ! [4: end if]
         }

   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_120, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the standard examining rule ):
[ R_121 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_121);
      ! phrase 1
      ! [1: say ~[the description of the noun][line break]~]
      say__c=0; say__p=1;#ifdef TARGET_ZCODE; @push self; #ifnot; @copy self sp; #endif;   print (I7_string) AccessProp(self=noun,description);  #ifdef TARGET_ZCODE; @pull self; #ifnot; @copy sp self; #endif;   new_line;   .L_Say56;
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_121, true);
   rfalse;
];
! From the Standard Rules
! Carry out examining ( this is the examine described devices rule ):
[ R_122 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_122);
      ! phrase 1
      ! [1: if the noun is a device , stop the action with library message examining action number 3 for the noun]
        if ((noun ofclass K11_device)) {   return GL__M(##Examine,3,noun);     }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_122, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Examining (B151_report_examining)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor examining ( this is the report other people examining rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor examining ( this is the report other people examining rule ):
[ R_123 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_123);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] looks closely at [the noun].~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_48;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say57;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_123, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Looking under (B153_carry_out_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor looking under ( this is the standard looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor looking under ( this is the standard looking under rule ):
[ R_124 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_124);
      ! phrase 1
      ! [1: stop the action with library message looking under action number 2 for the noun]
        return GL__M(##LookUnder,2,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_124, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Looking under (B154_report_looking_under)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor looking under ( this is the report other people looking under rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor looking under ( this is the report other people looking under rule ):
[ R_125 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_125);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] looks under [the noun].~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_49;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say58;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_125, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Searching (B155_check_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor searching ( this is the can't search unless container or supporter rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor searching ( this is the can't search closed opaque containers rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor searching ( this is the can't search unless container or supporter rule ):
[ R_126 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_126);
      ! phrase 1
      ! [1: if the noun is not a container and the noun is not a supporter , stop the action with library message searching action number 4 for the noun]
        if (((Prop_11(noun))) && ((Prop_12(noun)))) {   return GL__M(##Search,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_126, true);
   rfalse;
];
! From the Standard Rules
! Check an actor searching ( this is the can't search closed opaque containers rule ):
[ R_127 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_127);
      ! phrase 1
      ! [1: if the noun is a closed opaque container , stop the action with library message searching action number 5 for the noun]
        if (((noun ofclass K5_container) && (I7GetEitherOr(noun,open)==false) && (I7GetEitherOr(noun,transparent)==false))) {   return GL__M(##Search,5,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_127, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Searching (B157_report_searching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report searching a container ( this is the standard search containers rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report searching a supporter ( this is the standard search supporters rule ):
!   >>> I - Number of aspects constrained >>>
! Rule 3/3 ! Report an actor searching ( this is the report other people searching rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report searching a container ( this is the standard search containers rule ):
[ R_128 ;
   if ( (actor==player) && (noun ofclass K5_container)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_128);
      ! phrase 1
      ! [1: if the noun contains a described thing which is not scenery , issue library message searching action number 7 for the noun]
        if ((Prop_13(noun))) {   GL__M(##Search,7,noun);     }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 6 for the noun]
        else {   GL__M(##Search,6,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_128, true);
   rfalse;
];
! From the Standard Rules
! Report searching a supporter ( this is the standard search supporters rule ):
[ R_129 ;
   if ( (actor==player) && (noun ofclass K6_supporter)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_129);
      ! phrase 1
      ! [1: if the noun supports a described thing which is not scenery , issue library message searching action number 3 for the noun]
        if ((Prop_14(noun))) {   GL__M(##Search,3,noun);     }
      ! phrase 2
      ! [2: otherwise issue library message searching action number 2 for the noun]
        else {   GL__M(##Search,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_129, true);
   rfalse;
];
! From the Standard Rules
! Report an actor searching ( this is the report other people searching rule ):
[ R_130 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_130);
      ! phrase 1
      ! [1: if the actor is not the player , say ~[The actor] searches [the noun].~]
        if (~~((actor == player))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_50;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say59;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_130, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Consulting it about (B160_report_consulting_it_ab)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor consulting something about ( this is the block consulting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor consulting something about ( this is the block consulting rule ):
[ R_131 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_131);
      ! phrase 1
      ! [1: if the actor is the player , issue library message consulting it about action number 1 for the noun]
        if ((actor == player)) {   GL__M(##Consult,1,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] looks at [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_51;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say60;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_131, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Locking it with (B161_check_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor locking something with ( this is the can't lock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor locking something with ( this is the can't lock what's already locked rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor locking something with ( this is the can't lock what's open rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor locking something with ( this is the can't lock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without a lock rule ):
[ R_132 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_132);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
        if ((  (I7_Provides(noun, true,lockable))  ) && ((I7GetEitherOr(noun,lockable)))) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message locking it with action number 1 for the noun]
        return GL__M(##Lock,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_132, true);
   rfalse;
];
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's already locked rule ):
[ R_133 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_133);
      ! phrase 1
      ! [1: if the noun is locked , stop the action with library message locking it with action number 2 for the noun]
        if ((I7GetEitherOr(noun,locked))) {   return GL__M(##Lock,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_133, true);
   rfalse;
];
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock what's open rule ):
[ R_134 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_134);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message locking it with action number 3 for the noun]
        if ((I7GetEitherOr(noun,open))) {   return GL__M(##Lock,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_134, true);
   rfalse;
];
! From the Standard Rules
! Check an actor locking something with ( this is the can't lock without the correct key rule ):
[ R_135 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_135);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the matching key of the noun is not the second noun , stop the action with library message locking it with action number 4 for the second noun]
        if ((~~((  (I7_Holder(second))   == actor))) || (~~((AccessProp(noun,with_key) == second)))) {   return GL__M(##Lock,4,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_135, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Locking it with (B162_carry_out_locking_it_wi)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor locking something with ( this is the standard locking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor locking something with ( this is the standard locking rule ):
[ R_136 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_136);
      ! phrase 1
      ! [1: now the noun is locked]
        I7SetEitherOr(noun,locked);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_136, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Locking it with (B163_report_locking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor locking something with ( this is the standard report locking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor locking something with ( this is the standard report locking rule ):
[ R_137 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_137);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message locking it with action number 5 for the noun]
           GL__M(##Lock,5,noun);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , say ~[The actor] locks [the noun].~]
           if ((Adj_1(actor))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_52;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say61;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_137, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Unlocking it with (B164_check_unlocking_it_with)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without a lock rule ):
[ R_138 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_138);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is lockable , continue the action]
        if ((  (I7_Provides(noun, true,lockable))  ) && ((I7GetEitherOr(noun,lockable)))) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message unlocking it with action number 1 for the noun]
        return GL__M(##Unlock,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_138, true);
   rfalse;
];
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock what's already unlocked rule ):
[ R_139 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_139);
      ! phrase 1
      ! [1: if the noun is not locked , stop the action with library message unlocking it with action number 2 for the noun]
        if (~~((I7GetEitherOr(noun,locked)))) {   return GL__M(##Unlock,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_139, true);
   rfalse;
];
! From the Standard Rules
! Check an actor unlocking something with ( this is the can't unlock without the correct key rule ):
[ R_140 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_140);
      ! phrase 1
      ! [1: if the holder of the second noun is not the actor or the matching key of the noun is not the second noun , stop the action with library message unlocking it with action number 3 for the second noun]
        if ((~~((  (I7_Holder(second))   == actor))) || (~~((AccessProp(noun,with_key) == second)))) {   return GL__M(##Unlock,3,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_140, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Unlocking it with (B165_carry_out_unlocking_it_)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor unlocking something with ( this is the standard unlocking rule ):
[ R_141 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_141);
      ! phrase 1
      ! [1: now the noun is not locked]
        I7SetEitherOr(noun,locked,true);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_141, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Unlocking it with (B166_report_unlocking_it_wit)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor unlocking something with ( this is the standard report unlocking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor unlocking something with ( this is the standard report unlocking rule ):
[ R_142 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_142);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message unlocking it with action number 4 for the noun]
           GL__M(##Unlock,4,noun);  
         ! phrase 3
         ! [3: otherwise]
         } else {

         ! phrase 4
         ! [4: if the actor is visible , say ~[The actor] unlocks [the noun].~]
           if ((Adj_1(actor))) { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_53;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say62;   }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_142, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching on (B167_check_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching on ( this is the can't switch on unless switchable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor switching on ( this is the can't switch on what's already on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on unless switchable rule ):
[ R_143 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_143);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
        if (  (I7_Provides(noun, true,on))  ) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message switching on action number 1 for the noun]
        return GL__M(##SwitchOn,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_143, true);
   rfalse;
];
! From the Standard Rules
! Check an actor switching on ( this is the can't switch on what's already on rule ):
[ R_144 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_144);
      ! phrase 1
      ! [1: if the noun is switched on , stop the action with library message switching on action number 2 for the noun]
        if ((I7GetEitherOr(noun,on))) {   return GL__M(##SwitchOn,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_144, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching on (B168_carry_out_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching on ( this is the standard switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor switching on ( this is the standard switching on rule ):
[ R_145 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_145);
      ! phrase 1
      ! [1: now the noun is switched on]
        I7SetEitherOr(noun,on);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_145, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching on (B169_report_switching_on)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching on ( this is the standard report switching on rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor switching on ( this is the standard report switching on rule ):
[ R_146 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_146);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching on action number 3 for the noun]
        if ((actor == player)) {   GL__M(##SwitchOn,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] switches [the noun] on.~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_54;    print (the) noun;    print (I7_string) SC_55;   new_line; .L_Say63;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_146, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Switching off (B170_check_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor switching off ( this is the can't switch off unless switchable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor switching off ( this is the can't switch off what's already off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off unless switchable rule ):
[ R_147 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_147);
      ! phrase 1
      ! [1: if the noun provides the property switched on , continue the action]
        if (  (I7_Provides(noun, true,on))  ) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message switching off action number 1 for the noun]
        return GL__M(##SwitchOff,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_147, true);
   rfalse;
];
! From the Standard Rules
! Check an actor switching off ( this is the can't switch off what's already off rule ):
[ R_148 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_148);
      ! phrase 1
      ! [1: if the noun is switched off , stop the action with library message switching off action number 2 for the noun]
        if ((I7GetEitherOr(noun,on)==false)) {   return GL__M(##SwitchOff,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_148, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Switching off (B171_carry_out_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor switching off ( this is the standard switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor switching off ( this is the standard switching off rule ):
[ R_149 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_149);
      ! phrase 1
      ! [1: now the noun is switched off]
        I7SetEitherOr(noun,on,true);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_149, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Switching off (B172_report_switching_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor switching off ( this is the standard report switching off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor switching off ( this is the standard report switching off rule ):
[ R_150 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_150);
      ! phrase 1
      ! [1: if the actor is the player , issue library message switching off action number 3 for the noun]
        if ((actor == player)) {   GL__M(##SwitchOff,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] switches [the noun] off.~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_54;    print (the) noun;    print (I7_string) SC_56;   new_line; .L_Say64;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_150, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Opening (B173_check_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor opening ( this is the can't open unless openable rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor opening ( this is the can't open what's locked rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor opening ( this is the can't open what's already open rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor opening ( this is the can't open unless openable rule ):
[ R_151 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_151);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
        if ((  (I7_Provides(noun, true,openable))  ) && ((I7GetEitherOr(noun,openable)))) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message opening action number 1 for the noun]
        return GL__M(##Open,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_151, true);
   rfalse;
];
! From the Standard Rules
! Check an actor opening ( this is the can't open what's locked rule ):
[ R_152 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_152);
      ! phrase 1
      ! [1: if the noun provides the property lockable and the noun is locked , stop the action with library message opening action number 2 for the noun]
        if ((  (I7_Provides(noun, true,lockable))  ) && ((I7GetEitherOr(noun,locked)))) {   return GL__M(##Open,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_152, true);
   rfalse;
];
! From the Standard Rules
! Check an actor opening ( this is the can't open what's already open rule ):
[ R_153 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_153);
      ! phrase 1
      ! [1: if the noun is open , stop the action with library message opening action number 3 for the noun]
        if ((I7GetEitherOr(noun,open))) {   return GL__M(##Open,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_153, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Opening (B174_carry_out_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor opening ( this is the standard opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor opening ( this is the standard opening rule ):
[ R_154 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_154);
      ! phrase 1
      ! [1: now the noun is open]
        I7SetEitherOr(noun,open);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_154, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Opening (B175_report_opening)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Report an actor opening ( this is the reveal any newly visible interior rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Report an actor opening ( this is the standard report opening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor opening ( this is the reveal any newly visible interior rule ):
[ R_155 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_155);
      ! phrase 1
      ! [1: if the actor is the player and the noun is an opaque container and the first thing held by the noun is not nothing and the noun does not enclose the actor , stop the action with library message opening action number 4 for the noun]
        if (((actor == player)) && ((((noun ofclass K5_container) && (I7GetEitherOr(noun,transparent)==false))) && ((~~((  (child(noun))   == nothing))) && (~~((I7_IndirectlyContains(noun,actor))))))) {   return GL__M(##Open,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_155, true);
   rfalse;
];
! From the Standard Rules
! Report an actor opening ( this is the standard report opening rule ):
[ R_156 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_156);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message opening action number 5 for the noun]
           GL__M(##Open,5,noun);  
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
           } else if ((I7_CanSee(player,actor))) {  
         ! phrase 4
         ! [4: say ~[The actor] opens [the noun].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_57;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say65;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~[The noun] opens.~]
         say__c=0; say__p=1;  print (The) noun;    print (I7_string) SC_58;   new_line; .L_Say66;
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_156, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Closing (B176_check_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor closing ( this is the can't close unless openable rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor closing ( this is the can't close what's already closed rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor closing ( this is the can't close unless openable rule ):
[ R_157 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_157);
      ! phrase 1
      ! [1: if the noun provides the property openable and the noun is openable , continue the action]
        if ((  (I7_Provides(noun, true,openable))  ) && ((I7GetEitherOr(noun,openable)))) {   rfalse;     }
      ! phrase 2
      ! [2: stop the action with library message closing action number 1 for the noun]
        return GL__M(##Close,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_157, true);
   rfalse;
];
! From the Standard Rules
! Check an actor closing ( this is the can't close what's already closed rule ):
[ R_158 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_158);
      ! phrase 1
      ! [1: if the noun is closed , stop the action with library message closing action number 2 for the noun]
        if ((I7GetEitherOr(noun,open)==false)) {   return GL__M(##Close,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_158, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Closing (B177_carry_out_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor closing ( this is the standard closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor closing ( this is the standard closing rule ):
[ R_159 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_159);
      ! phrase 1
      ! [1: now the noun is closed]
        I7SetEitherOr(noun,open,true);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_159, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Closing (B178_report_closing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor closing ( this is the standard report closing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor closing ( this is the standard report closing rule ):
[ R_160 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_160);
      ! phrase 1
      ! [1: if the actor is the player begin]
        if ((actor == player))   {
         ! phrase 2
         ! [2: issue library message closing action number 3 for the noun]
           GL__M(##Close,3,noun);  
         ! phrase 3
         ! [3: otherwise if the player can see the actor]
           } else if ((I7_CanSee(player,actor))) {  
         ! phrase 4
         ! [4: say ~[The actor] closes [the noun].~]
         say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_59;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say67;
         ! phrase 5
         ! [5: otherwise]
         } else {

         ! phrase 6
         ! [6: say ~[The noun] closes.~]
         say__c=0; say__p=1;  print (The) noun;    print (I7_string) SC_60;   new_line; .L_Say68;
         ! phrase 7
         ! [7: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_160, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Wearing (B179_check_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor wearing ( this is the can't wear what's not clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor wearing ( this is the can't wear what's not held rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor wearing ( this is the can't wear what's already worn rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not clothing rule ):
[ R_161 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_161);
      ! phrase 1
      ! [1: if the noun is not a thing or the noun is not wearable , stop the action with library message wearing action number 1 for the noun]
        if (((Prop_15(noun))) || (~~((I7GetEitherOr(noun,clothing))))) {   return GL__M(##Wear,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_161, true);
   rfalse;
];
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's not held rule ):
[ R_162 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_162);
      ! phrase 1
      ! [1: if the holder of the noun is not the actor , stop the action with library message wearing action number 2 for the noun]
        if (~~((  (I7_Holder(noun))   == actor))) {   return GL__M(##Wear,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_162, true);
   rfalse;
];
! From the Standard Rules
! Check an actor wearing ( this is the can't wear what's already worn rule ):
[ R_163 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_163);
      ! phrase 1
      ! [1: if the actor is wearing the noun , stop the action with library message wearing action number 3 for the noun]
        if ((actor == I7_WornBy(noun))) {   return GL__M(##Wear,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_163, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Wearing (B180_carry_out_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor wearing ( this is the standard wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor wearing ( this is the standard wearing rule ):
[ R_164 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_164);
      ! phrase 1
      ! [1: now the actor wears the noun]
        I7_Wear(noun,actor);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_164, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Wearing (B181_report_wearing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor wearing ( this is the standard report wearing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor wearing ( this is the standard report wearing rule ):
[ R_165 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_165);
      ! phrase 1
      ! [1: if the actor is the player , issue library message wearing action number 4 for the noun]
        if ((actor == player)) {   GL__M(##Wear,4,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] puts on [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_61;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say69;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_165, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Taking off (B182_check_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor taking off ( this is the can't take off what's not worn rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor taking off ( this is the can't take off what's not worn rule ):
[ R_166 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_166);
      ! phrase 1
      ! [1: if the actor is not wearing the noun , stop the action with library message taking off action number 1 for the noun]
        if (~~((actor == I7_WornBy(noun)))) {   return GL__M(##Disrobe,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_166, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Taking off (B183_carry_out_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor taking off ( this is the standard taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor taking off ( this is the standard taking off rule ):
[ R_167 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_167);
      ! phrase 1
      ! [1: now the actor carries the noun]
        I7_Move(noun,actor);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_167, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Taking off (B184_report_taking_off)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor taking off ( this is the standard report taking off rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor taking off ( this is the standard report taking off rule ):
[ R_168 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_168);
      ! phrase 1
      ! [1: if the actor is the player , issue library message taking off action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Disrobe,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] takes off [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_62;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say70;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_168, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Giving it to (B185_check_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/4 ! Check an actor giving something to ( this is the can't give what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/4 ! Check an actor giving something to ( this is the can't give to yourself rule ):
!   === which is equally specific with ===
! Rule 3/4 ! Check an actor giving something to ( this is the can't give to a non-person rule ):
!   === which is equally specific with ===
! Rule 4/4 ! Check an actor giving something to ( this is the block giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor giving something to ( this is the can't give what you haven't got rule ):
[ R_169 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_169);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message giving it to action number 1 for the noun]
        if (~~((actor ==   (I7_Holder(noun))  ))) {   return GL__M(##Give,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_169, true);
   rfalse;
];
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to yourself rule ):
[ R_170 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_170);
      ! phrase 1
      ! [1: if the actor is the second noun , stop the action with library message giving it to action number 2 for the noun]
        if ((actor == second)) {   return GL__M(##Give,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_170, true);
   rfalse;
];
! From the Standard Rules
! Check an actor giving something to ( this is the can't give to a non-person rule ):
[ R_171 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_171);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message giving it to action number 4 for the second noun]
        if ((Prop_16(second))) {   return GL__M(##Give,4,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_171, true);
   rfalse;
];
! From the Standard Rules
! Check an actor giving something to ( this is the block giving rule ):
[ R_172 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_172);
      ! phrase 1
      ! [1: stop the action with library message giving it to action number 3 for the second noun]
        return GL__M(##Give,3,second);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_172, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Giving it to (B186_carry_out_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out an actor giving something to ( this is the standard giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Carry out an actor giving something to ( this is the standard giving rule ):
[ R_173 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_173);
      ! phrase 1
      ! [1: move the noun to the second noun]
        I7_Move(noun, second, 0, 0);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_173, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Giving it to (B187_report_giving_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor giving something to ( this is the standard report giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor giving something to ( this is the standard report giving rule ):
[ R_174 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_174);
      ! phrase 1
      ! [1: if the actor is the player , say ~You give [the noun] to [the second noun].~]
        if ((actor == player)) { say__c=0; say__p=1;  print (I7_string) SC_63;    print (the) noun;    print (I7_string) SC_64;    print (the) second;    print (I7_string) SC_14;   new_line; .L_Say71;   }
      ! phrase 2
      ! [2: otherwise say ~[The actor] gives [the noun] to [if the second noun is the	player]you[otherwise][the second noun][end if].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_65;    print (the) noun;    print (I7_string) SC_64;   
.L_Say72; if (((second == player))) say__c=true; else jump L_Say73;    print (I7_string) SC_66;  
.L_Say73; if (say__c==false) say__c=true; else jump L_Say74;    print (the) second;   
.L_Say74; say__c = false;    print (I7_string) SC_14;   new_line; .L_Say75;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_174, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Showing it to (B188_check_showing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor showing something to ( this is the can't show what you haven't got rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor showing something to ( this is the block showing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor showing something to ( this is the can't show what you haven't got rule ):
[ R_175 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_175);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message showing it to action number 1 for the noun]
        if (~~((actor ==   (I7_Holder(noun))  ))) {   return GL__M(##Show,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_175, true);
   rfalse;
];
! From the Standard Rules
! Check an actor showing something to ( this is the convert show to yourself to examine rule ):
[ R_176 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_176);
      ! phrase 1
      ! [1: if the actor is the second noun , convert to the examining action on the noun]
        if ((actor == second)) {   return GVS_Convert(##Examine,noun,0);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_176, true);
   rfalse;
];
! From the Standard Rules
! Check an actor showing something to ( this is the block showing rule ):
[ R_177 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_177);
      ! phrase 1
      ! [1: stop the action with library message showing it to action number 2 for the second noun]
        return GL__M(##Show,2,second);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_177, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking (B191_check_waking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking ( this is the block waking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor waking ( this is the block waking rule ):
[ R_178 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_178);
      ! phrase 1
      ! [1: stop the action with library message waking action number 1 for the noun]
        return GL__M(##WakeOther,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_178, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Throwing it at (B194_check_throwing_it_at)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor throwing something at ( this is the block throwing at rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor throwing something at ( this is the implicitly remove thrown clothing rule ):
[ R_179 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_179);
      ! phrase 1
      ! [1: if the actor is wearing the noun begin]
        if ((actor == I7_WornBy(noun)))   {
         ! phrase 2
         ! [2: issue library message dropping action number 3 for the noun]
           GL__M(##Drop,3,noun);  
         ! phrase 3
         ! [3: silently try the actor trying taking off the noun]
           @push keep_silent; keep_silent=1; I7_TryAction(0, actor, ##Disrobe, noun, 0);; @pull keep_silent;  
         ! phrase 4
         ! [4: if the actor is wearing the noun , stop the action]
           if ((actor == I7_WornBy(noun))) {   rtrue;     }
         ! phrase 5
         ! [5: end if]
         }

   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_179, true);
   rfalse;
];
! From the Standard Rules
! Check an actor throwing something at ( this is the futile to throw things at inanimate objects rule ):
[ R_180 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_180);
      ! phrase 1
      ! [1: if the second noun is not a person , stop the action with library message throwing it at action number 1 for the second noun]
        if ((Prop_17(second))) {   return GL__M(##ThrowAt,1,second);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_180, true);
   rfalse;
];
! From the Standard Rules
! Check an actor throwing something at ( this is the block throwing at rule ):
[ R_181 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_181);
      ! phrase 1
      ! [1: stop the action with library message throwing it at action number 2 for the noun]
        return GL__M(##ThrowAt,2,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_181, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Attacking (B197_check_attacking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor attacking ( this is the block attacking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor attacking ( this is the block attacking rule ):
[ R_182 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_182);
      ! phrase 1
      ! [1: stop the action with library message attacking action number 1 for the noun]
        return GL__M(##Attack,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_182, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Kissing (B200_check_kissing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor kissing ( this is the kissing yourself rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor kissing ( this is the block kissing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor kissing ( this is the kissing yourself rule ):
[ R_183 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_183);
      ! phrase 1
      ! [1: if the noun is the actor , stop the action with library message touching action number 3 for the noun]
        if ((noun == actor)) {   return GL__M(##Touch,3,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_183, true);
   rfalse;
];
! From the Standard Rules
! Check an actor kissing ( this is the block kissing rule ):
[ R_184 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_184);
      ! phrase 1
      ! [1: stop the action with library message kissing action number 1 for the noun]
        return GL__M(##Kiss,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_184, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Answering it that (B205_report_answering_it_tha)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor answering something that ( this is the block answering rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor answering something that ( this is the block answering rule ):
[ R_185 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_185);
      ! phrase 1
      ! [1: stop the action with library message answering it that action number 1 for the noun]
        return GL__M(##Answer,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_185, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Telling it about (B206_check_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor telling something about ( this is the telling yourself rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor telling something about ( this is the telling yourself rule ):
[ R_186 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_186);
      ! phrase 1
      ! [1: if the actor is the noun , stop the action with library message telling it about action number 1 for the noun]
        if ((actor == noun)) {   return GL__M(##Tell,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_186, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Telling it about (B208_report_telling_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor telling something about ( this is the block telling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor telling something about ( this is the block telling rule ):
[ R_187 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_187);
      ! phrase 1
      ! [1: stop the action with library message telling it about action number 2 for the noun]
        return GL__M(##Tell,2,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_187, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Asking it about (B211_report_asking_it_about)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor asking something about ( this is the block asking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor asking something about ( this is the block asking rule ):
[ R_188 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_188);
      ! phrase 1
      ! [1: stop the action with library message asking it about action number 1 for the noun]
        return GL__M(##Ask,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_188, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Asking it for (B212_check_asking_it_for)
! ----------------------------------------------------------------------------------------------------
! Rule 1/2 ! Check an actor asking something for ( this is the asking yourself for something rule ):
!   === which is equally specific with ===
! Rule 2/2 ! Check an actor asking something for ( this is the translate asking for to giving rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor asking something for ( this is the asking yourself for something rule ):
[ R_189 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_189);
      ! phrase 1
      ! [1: if the actor is the noun and the actor is the player , try taking inventory instead]
        if (((actor == noun)) && ((actor == player))) {   I7_TryAction(0, player, ##Inv, 0, 0);;     rtrue; }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_189, true);
   rfalse;
];
! From the Standard Rules
! Check an actor asking something for ( this is the translate asking for to giving rule ):
[ R_190 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_190);
      ! phrase 1
      ! [1: convert to request of the noun to perform giving it to action with the second noun and the actor]
        I7_TryAction(true, noun, ##Give, second, actor); rtrue;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_190, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waiting (B217_report_waiting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waiting ( this is the standard report waiting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor waiting ( this is the standard report waiting rule ):
[ R_191 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_191);
      ! phrase 1
      ! [1: if the actor is the player , stop the action with library message waiting action number 1 for the actor]
        if ((actor == player)) {   return GL__M(##Wait,1,actor);     }
      ! phrase 2
      ! [2: say ~[The actor] waits.~]
      say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_67;   new_line; .L_Say76;
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_191, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Touching (B220_report_touching)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Report an actor touching ( this is the report touching yourself rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Report an actor touching ( this is the report touching other people rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Report an actor touching ( this is the report touching things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor touching ( this is the report touching yourself rule ):
[ R_192 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_192);
      ! phrase 1
      ! [1: if the noun is the actor begin]
        if ((noun == actor))   {
         ! phrase 2
         ! [2: if the actor is the player , issue library message touching action number 3 for the noun]
           if ((actor == player)) {   GL__M(##Touch,3,noun);     }
         ! phrase 3
         ! [3: otherwise say ~[The actor] touches	[if the actor is female]herself[otherwise]himself[end if].~]
           else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_68;   
.L_Say77; if (((I7GetEitherOr(actor,female)))) say__c=true; else jump L_Say78;    print (I7_string) SC_69;  
.L_Say78; if (say__c==false) say__c=true; else jump L_Say79;    print (I7_string) SC_70;   
.L_Say79; say__c = false;    print (I7_string) SC_14;   new_line; .L_Say80;   }
         ! phrase 4
         ! [4: stop the action]
           rtrue;  
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_192, true);
   rfalse;
];
! From the Standard Rules
! Report an actor touching ( this is the report touching other people rule ):
[ R_193 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_193);
      ! phrase 1
      ! [1: if the noun is a person begin]
        if ((noun ofclass K8_person))   {
         ! phrase 2
         ! [2: if the actor is the player , issue library message touching action number 1 for the noun]
           if ((actor == player)) {   GL__M(##Touch,1,noun);     }
         ! phrase 3
         ! [3: otherwise say ~[The actor] touches	[if the noun is the player]you[otherwise][the noun][end if].~]
           else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_68;   
.L_Say81; if (((noun == player))) say__c=true; else jump L_Say82;    print (I7_string) SC_66;  
.L_Say82; if (say__c==false) say__c=true; else jump L_Say83;    print (the) noun;   
.L_Say83; say__c = false;    print (I7_string) SC_14;   new_line; .L_Say84;   }
         ! phrase 4
         ! [4: stop the action]
           rtrue;  
         ! phrase 5
         ! [5: end if]
         }

      ! phrase 6
      ! [6: continue the action]
        rfalse;  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_193, true);
   rfalse;
];
! From the Standard Rules
! Report an actor touching ( this is the report touching things rule ):
[ R_194 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_194);
      ! phrase 1
      ! [1: if the actor is the player , issue library message touching action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Touch,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] touches [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_71;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say85;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_194, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving (B221_check_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving ( this is the can't wave what's not held rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor waving ( this is the can't wave what's not held rule ):
[ R_195 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_195);
      ! phrase 1
      ! [1: if the actor is not the holder of the noun , stop the action with library message waving action number 1 for the noun]
        if (~~((actor ==   (I7_Holder(noun))  ))) {   return GL__M(##Wave,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_195, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Waving (B223_report_waving)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor waving ( this is the report waving things rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor waving ( this is the report waving things rule ):
[ R_196 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_196);
      ! phrase 1
      ! [1: if the actor is the player , issue library message waving action number 2 for the noun]
        if ((actor == player)) {   GL__M(##Wave,2,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] waves [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_72;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say86;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_196, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pulling (B224_check_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pulling ( this is the can't pull scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pulling ( this is the can't pull people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor pulling ( this is the can't pull what's fixed in place rule ):
[ R_197 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_197);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pulling action number 1 for the noun]
        if ((I7GetEitherOr(noun,static))) {   return GL__M(##Pull,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_197, true);
   rfalse;
];
! From the Standard Rules
! Check an actor pulling ( this is the can't pull scenery rule ):
[ R_198 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_198);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pulling action number 2 for the noun]
        if ((I7GetEitherOr(noun,scenery))) {   return GL__M(##Pull,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_198, true);
   rfalse;
];
! From the Standard Rules
! Check an actor pulling ( this is the can't pull people rule ):
[ R_199 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_199);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pulling action number 4 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Pull,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_199, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pulling (B226_report_pulling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pulling ( this is the report pulling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor pulling ( this is the report pulling rule ):
[ R_200 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_200);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pulling action number 3 for the noun]
        if ((actor == player)) {   GL__M(##Pull,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] pulls [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_73;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say87;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_200, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing (B227_check_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor pushing something ( this is the can't push scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor pushing something ( this is the can't push people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor pushing something ( this is the can't push what's fixed in place rule ):
[ R_201 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_201);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message pushing action number 1 for the noun]
        if ((I7GetEitherOr(noun,static))) {   return GL__M(##Push,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_201, true);
   rfalse;
];
! From the Standard Rules
! Check an actor pushing something ( this is the can't push scenery rule ):
[ R_202 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_202);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message pushing action number 2 for the noun]
        if ((I7GetEitherOr(noun,scenery))) {   return GL__M(##Push,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_202, true);
   rfalse;
];
! From the Standard Rules
! Check an actor pushing something ( this is the can't push people rule ):
[ R_203 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_203);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message pushing action number 4 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Push,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_203, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Pushing (B229_report_pushing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor pushing something ( this is the report pushing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor pushing something ( this is the report pushing rule ):
[ R_204 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_204);
      ! phrase 1
      ! [1: if the actor is the player , issue library message pushing action number 3 for the noun]
        if ((actor == player)) {   GL__M(##Push,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] pushes [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_74;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say88;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_204, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Turning (B230_check_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/3 ! Check an actor turning ( this is the can't turn what's fixed in place rule ):
!   === which is equally specific with ===
! Rule 2/3 ! Check an actor turning ( this is the can't turn scenery rule ):
!   === which is equally specific with ===
! Rule 3/3 ! Check an actor turning ( this is the can't turn people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor turning ( this is the can't turn what's fixed in place rule ):
[ R_205 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_205);
      ! phrase 1
      ! [1: if the noun is fixed in place , stop the action with library message turning action number 1 for the noun]
        if ((I7GetEitherOr(noun,static))) {   return GL__M(##Turn,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_205, true);
   rfalse;
];
! From the Standard Rules
! Check an actor turning ( this is the can't turn scenery rule ):
[ R_206 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_206);
      ! phrase 1
      ! [1: if the noun is scenery , stop the action with library message turning action number 2 for the noun]
        if ((I7GetEitherOr(noun,scenery))) {   return GL__M(##Turn,2,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_206, true);
   rfalse;
];
! From the Standard Rules
! Check an actor turning ( this is the can't turn people rule ):
[ R_207 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_207);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message turning action number 4 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Turn,4,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_207, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Turning (B232_report_turning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor turning ( this is the report turning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor turning ( this is the report turning rule ):
[ R_208 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_208);
      ! phrase 1
      ! [1: if the actor is the player , issue library message turning action number 3 for the noun]
        if ((actor == player)) {   GL__M(##Turn,3,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] turns [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_75;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say89;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_208, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Pushing it to (B233_check_pushing_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor pushing something to ( this is the block pushing in directions rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor pushing something to ( this is the block pushing in directions rule ):
[ R_209 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_209);
      ! phrase 1
      ! [1: stop the action with library message pushing it to action number 1 for the noun]
        return GL__M(##PushDir,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_209, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Squeezing (B236_check_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor squeezing ( this is the innuendo about squeezing people rule ):
[ R_210 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_210);
      ! phrase 1
      ! [1: if the noun is a person , stop the action with library message squeezing action number 1 for the noun]
        if ((noun ofclass K8_person)) {   return GL__M(##Squeeze,1,noun);     }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_210, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: report Squeezing (B238_report_squeezing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Report an actor squeezing ( this is the report squeezing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Report an actor squeezing ( this is the report squeezing rule ):
[ R_211 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_211);
      ! phrase 1
      ! [1: if the actor is the player , issue library message squeezing action number 1 for the noun]
        if ((actor == player)) {   GL__M(##Squeeze,1,noun);     }
      ! phrase 2
      ! [2: otherwise say ~[The actor] squeezes [the noun].~]
        else { say__c=0; say__p=1;  print (The) actor;    print (I7_string) SC_76;    print (the) noun;    print (I7_string) SC_14;   new_line; .L_Say90;   }
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_211, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying yes (B239_check_saying_yes)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying yes ( this is the block saying yes rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor saying yes ( this is the block saying yes rule ):
[ R_212 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_212);
      ! phrase 1
      ! [1: stop the action with library message saying yes action number 1]
        return GL__M(##Yes,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_212, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying no (B242_check_saying_no)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying no ( this is the block saying no rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor saying no ( this is the block saying no rule ):
[ R_213 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_213);
      ! phrase 1
      ! [1: stop the action with library message saying no action number 1]
        return GL__M(##No,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_213, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Burning (B245_check_burning)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor burning ( this is the block burning rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor burning ( this is the block burning rule ):
[ R_214 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_214);
      ! phrase 1
      ! [1: stop the action with library message burning action number 1]
        return GL__M(##Burn,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_214, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waking up (B248_check_waking_up)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waking up ( this is the block waking up rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor waking up ( this is the block waking up rule ):
[ R_215 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_215);
      ! phrase 1
      ! [1: stop the action with library message waking up action number 1]
        return GL__M(##Wake,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_215, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Thinking (B251_check_thinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor thinking ( this is the block thinking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor thinking ( this is the block thinking rule ):
[ R_216 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_216);
      ! phrase 1
      ! [1: stop the action with library message thinking action number 1]
        return GL__M(##Think,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_216, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Smelling (B254_check_smelling)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor smelling ( this is the block smelling rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor smelling ( this is the block smelling rule ):
[ R_217 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_217);
      ! phrase 1
      ! [1: stop the action with library message smelling action number 1 for the noun]
        return GL__M(##Smell,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_217, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Listening to (B257_check_listening_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor listening ( this is the block listening rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor listening ( this is the block listening rule ):
[ R_218 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_218);
      ! phrase 1
      ! [1: stop the action with library message listening to action number 1 for the noun]
        return GL__M(##Listen,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_218, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tasting (B260_check_tasting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tasting ( this is the block tasting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor tasting ( this is the block tasting rule ):
[ R_219 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_219);
      ! phrase 1
      ! [1: stop the action with library message tasting action number 1 for the noun]
        return GL__M(##Taste,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_219, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Cutting (B263_check_cutting)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor cutting ( this is the block cutting rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor cutting ( this is the block cutting rule ):
[ R_220 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_220);
      ! phrase 1
      ! [1: stop the action with library message cutting action number 1 for the noun]
        return GL__M(##Cut,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_220, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Jumping (B266_check_jumping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor jumping ( this is the block jumping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor jumping ( this is the block jumping rule ):
[ R_221 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_221);
      ! phrase 1
      ! [1: stop the action with library message jumping action number 1]
        return GL__M(##Jump,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_221, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Tying it to (B269_check_tying_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor tying ( this is the block tying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor tying ( this is the block tying rule ):
[ R_222 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_222);
      ! phrase 1
      ! [1: stop the action with library message tying it to action number 1 for the noun]
        return GL__M(##Tie,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_222, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Drinking (B272_check_drinking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor drinking ( this is the block drinking rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor drinking ( this is the block drinking rule ):
[ R_223 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_223);
      ! phrase 1
      ! [1: stop the action with library message drinking action number 1 for the noun]
        return GL__M(##Drink,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_223, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Saying sorry (B275_check_saying_sorry)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor saying sorry ( this is the block saying sorry rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor saying sorry ( this is the block saying sorry rule ):
[ R_224 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_224);
      ! phrase 1
      ! [1: stop the action with library message saying sorry action number 1]
        return GL__M(##Sorry,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_224, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing obscenely (B278_check_swearing_obscenel)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor swearing obscenely ( this is the block swearing obscenely rule ):
[ R_225 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_225);
      ! phrase 1
      ! [1: stop the action with library message swearing obscenely action number 1]
        return GL__M(##Strong,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_225, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swearing mildly (B281_check_swearing_mildly)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swearing mildly ( this is the block swearing mildly rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor swearing mildly ( this is the block swearing mildly rule ):
[ R_226 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_226);
      ! phrase 1
      ! [1: stop the action with library message swearing mildly action number 1]
        return GL__M(##Mild,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_226, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Swinging (B284_check_swinging)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor swinging ( this is the block swinging rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor swinging ( this is the block swinging rule ):
[ R_227 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_227);
      ! phrase 1
      ! [1: stop the action with library message swinging action number 1 for the noun]
        return GL__M(##Swing,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_227, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Rubbing (B287_check_rubbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor rubbing ( this is the block rubbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor rubbing ( this is the block rubbing rule ):
[ R_228 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_228);
      ! phrase 1
      ! [1: stop the action with library message rubbing action number 1 for the noun]
        return GL__M(##Rub,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_228, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Setting it to (B290_check_setting_it_to)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor setting something to ( this is the block setting it to rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor setting something to ( this is the block setting it to rule ):
[ R_229 ;
   if ((noun ofclass K2_thing)) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_229);
      ! phrase 1
      ! [1: stop the action with library message setting it to action number 1 for the noun]
        return GL__M(##SetTo,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_229, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Waving hands (B293_check_waving_hands)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor waving hands ( this is the block waving hands rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor waving hands ( this is the block waving hands rule ):
[ R_230 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_230);
      ! phrase 1
      ! [1: stop the action with library message waving hands action number 1]
        return GL__M(##WaveHands,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_230, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Buying (B296_check_buying)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor buying ( this is the block buying rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor buying ( this is the block buying rule ):
[ R_231 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_231);
      ! phrase 1
      ! [1: stop the action with library message buying action number 1 for the noun]
        return GL__M(##Buy,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_231, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Singing (B299_check_singing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor singing ( this is the block singing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor singing ( this is the block singing rule ):
[ R_232 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_232);
      ! phrase 1
      ! [1: stop the action with library message singing action number 1]
        return GL__M(##Sing,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_232, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Climbing (B302_check_climbing)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor climbing ( this is the block climbing rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor climbing ( this is the block climbing rule ):
[ R_233 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_233);
      ! phrase 1
      ! [1: stop the action with library message climbing action number 1 for the noun]
        return GL__M(##Climb,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_233, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: check Sleeping (B305_check_sleeping)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Check an actor sleeping ( this is the block sleeping rule ):
! ----------------------------------------------------------------------------------------------------
! From the Standard Rules
! Check an actor sleeping ( this is the block sleeping rule ):
[ R_234 ;
   if (TRUE) { ! Runs only when pattern matches
   if (debug_rules) DB_Rule(R_234);
      ! phrase 1
      ! [1: stop the action with library message sleeping action number 1]
        return GL__M(##Sleep,1,noun);  
   } ! Runs only when pattern matches
   else if (debug_rules > 1) DB_Rule(R_234, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------

! ----------------------------------------------------------------------------------------------------
! Rules in rulebook: carry out Time-checking (B354_carry_out_time_checking)
! ----------------------------------------------------------------------------------------------------
! Rule 1/1 ! Carry out time-checking:
! ----------------------------------------------------------------------------------------------------
! Carry out time-checking:
[ R_553 ;
   if (actor == player) {
   if (debug_rules) DB_Rule(R_553);
      ! phrase 1
        #ifndef I7_ECONOMY; if (debug_rules>1) print "@31  [1: if the player carries the pocketwatch , say ~Your pocketwatch reads [time of day].~]^"; #endif;
      ! [2: otherwise say ~You have no way of checking the time.~]
        if ((player == I7_CarriedBy(O97_pocketwatch))) { say__c=0; say__p=1;  print (I7_string) SC_77;    print (PrintTimeOfDay) the_time;    print (I7_string) SC_14;   new_line; .L_Say91;   }
      ! phrase 3
      ! [3: otherwise say ~You have no way of checking the time.~]
        else { say__c=0; say__p=1;  print (I7_string) SC_78;   new_line; .L_Say92;   }
   } ! Runs only when actor is the player
   else if (debug_rules > 1) DB_Rule(R_553, true);
   rfalse;
];
! ----------------------------------------------------------------------------------------------------
! Definitions of displaced and unbooked rules

! Definitions of miscellaneous remaining rules

! From the Standard Rules
! Definition:
[ R_0 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_1 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_2 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_3 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_4 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_5 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_6 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_7 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];
! From the Standard Rules
! Definition:
[ R_8 
    t_0 ! Call parameter 'it' = I6_OBJECT_SPEC_TY
    ;
   rfalse;
];


Array I7TimerTable table 0 0;

Array I7TimerTableTimes table 0 0;


[ TurnEndPrimitive;
	actor = player; self = player; act_requester = 0;
	BeginActionProcessing();
	ProcessRulebook(TURNEND_RB);
	EndActionProcessing();
];

[ BeforeRoutines x; self = noun;
	ChronologyPoint();
	rfalse;
];

[ AfterRoutines; self = noun;
	if (ProcessRulebook(AFTER_RB)) rtrue;
	if (keep_silent == 1) rtrue;
	return ProcessRulebook(REPLY_RB);
];


Array EMPTY_RULEBOOK -> $ff $ff $ff $ff; ! 4 bytes needed in case of Glulx
Array rulebooks_array --> B0_action_processing B1_before B2_instead B3_after B4_procedural B5_accessibility B6_action_specific B7_carry_out B8_general_report B9_turn_sequence B10_reaching_inside B11_reaching_outside B12_general_before B13_actor_specific_before B14_location_specific_before B15_reaction_before B16_object_specific_before B17_general_after B18_actor_specific_after B19_location_specific_after B20_reaction_after B21_object_specific_after B22_when_play_begins B23_when_play_ends B24_every_turn B25_check B26_report B27_persuasion B28_unsuccessful_attempt_by B29_visibility B30_does_the_player_mean B31_setting_action_variables B32_scene_changing B33_when_entire_game_begins B34_when_entire_game_ends B35_before_printing_the_name B36_for_printing_the_name B37_after_printing_the_name B38_before_listing_contents B39_for_listing_contents B40_after_listing_contents B41_before_grouping_together B42_for_grouping_together B43_after_grouping_together B44_before_constructing_the_ B45_for_constructing_the_sta B46_after_constructing_the_s B47_before_listing_nondescri B48_for_listing_nondescript_ B49_after_listing_nondescrip B50_before_deciding_the_scop B51_for_deciding_the_scope B52_after_deciding_the_scope B53_before_supplying_a_missi B54_for_supplying_a_missing_ B55_after_supplying_a_missin B56_before_supplying_a_missi B57_for_supplying_a_missing_ B58_after_supplying_a_missin B59_before_reading_a_command B60_for_reading_a_command B61_after_reading_a_command B62_before_deciding_whether_ B63_for_deciding_whether_all B64_after_deciding_whether_a B65_before_printing_the_play B66_for_printing_the_player_ B67_after_printing_the_playe B68_before_amusing_a_victori B69_for_amusing_a_victorious B70_after_amusing_a_victorio B71_before_printing_the_bann B72_for_printing_the_banner_ B73_after_printing_the_banne B74_before_printing_the_plur B75_for_printing_the_plural_ B76_after_printing_the_plura B77_before_deciding_the_conc B78_for_deciding_the_conceal B79_after_deciding_the_conce B80_before_printing_a_refusa B81_for_printing_a_refusal_t B82_after_printing_a_refusal B83_before_printing_the_anno B84_for_printing_the_announc B85_after_printing_the_annou B86_before_printing_the_name B87_for_printing_the_name_of B88_after_printing_the_name_ B89_before_printing_the_desc B90_for_printing_the_descrip B91_after_printing_the_descr B92_before_printing_room_des B93_for_printing_room_descri B94_after_printing_room_desc B95_before_printing_a_parser B96_for_printing_a_parser_er B97_after_printing_a_parser_ B98_before_implicitly_taking B99_for_implicitly_taking B100_after_implicitly_taking B101_before_starting_the_vir B102_for_starting_the_virtua B103_after_starting_the_virt B104_before_clarifying_the_p B105_for_clarifying_the_pars B106_after_clarifying_the_pa B107_before_asking_which_do_ B108_for_asking_which_do_you B109_after_asking_which_do_y B110_before_writing_a_paragr B111_for_writing_a_paragraph B112_after_writing_a_paragra B113_check_taking_inventory B114_carry_out_taking_invent B115_report_taking_inventory B116_check_taking B117_carry_out_taking B118_report_taking B119_check_removing_it_from B120_carry_out_removing_it_f B121_report_removing_it_from B122_check_dropping B123_carry_out_dropping B124_report_dropping B125_check_putting_it_on B126_carry_out_putting_it_on B127_report_putting_it_on B128_check_inserting_it_into B129_carry_out_inserting_it_ B130_report_inserting_it_int B131_check_eating B132_carry_out_eating B133_report_eating B134_check_going B135_carry_out_going B136_report_going B137_check_entering B138_carry_out_entering B139_report_entering B140_check_exiting B141_carry_out_exiting B142_report_exiting B143_check_getting_off B144_carry_out_getting_off B145_report_getting_off B146_check_looking B147_carry_out_looking B148_report_looking B149_check_examining B150_carry_out_examining B151_report_examining B152_check_looking_under B153_carry_out_looking_under B154_report_looking_under B155_check_searching B156_carry_out_searching B157_report_searching B158_check_consulting_it_abo B159_carry_out_consulting_it B160_report_consulting_it_ab B161_check_locking_it_with B162_carry_out_locking_it_wi B163_report_locking_it_with B164_check_unlocking_it_with B165_carry_out_unlocking_it_ B166_report_unlocking_it_wit B167_check_switching_on B168_carry_out_switching_on B169_report_switching_on B170_check_switching_off B171_carry_out_switching_off B172_report_switching_off B173_check_opening B174_carry_out_opening B175_report_opening B176_check_closing B177_carry_out_closing B178_report_closing B179_check_wearing B180_carry_out_wearing B181_report_wearing B182_check_taking_off B183_carry_out_taking_off B184_report_taking_off B185_check_giving_it_to B186_carry_out_giving_it_to B187_report_giving_it_to B188_check_showing_it_to B189_carry_out_showing_it_to B190_report_showing_it_to B191_check_waking B192_carry_out_waking B193_report_waking B194_check_throwing_it_at B195_carry_out_throwing_it_a B196_report_throwing_it_at B197_check_attacking B198_carry_out_attacking B199_report_attacking B200_check_kissing B201_carry_out_kissing B202_report_kissing B203_check_answering_it_that B204_carry_out_answering_it_ B205_report_answering_it_tha B206_check_telling_it_about B207_carry_out_telling_it_ab B208_report_telling_it_about B209_check_asking_it_about B210_carry_out_asking_it_abo B211_report_asking_it_about B212_check_asking_it_for B213_carry_out_asking_it_for B214_report_asking_it_for B215_check_waiting B216_carry_out_waiting B217_report_waiting B218_check_touching B219_carry_out_touching B220_report_touching B221_check_waving B222_carry_out_waving B223_report_waving B224_check_pulling B225_carry_out_pulling B226_report_pulling B227_check_pushing B228_carry_out_pushing B229_report_pushing B230_check_turning B231_carry_out_turning B232_report_turning B233_check_pushing_it_to B234_carry_out_pushing_it_to B235_report_pushing_it_to B236_check_squeezing B237_carry_out_squeezing B238_report_squeezing B239_check_saying_yes B240_carry_out_saying_yes B241_report_saying_yes B242_check_saying_no B243_carry_out_saying_no B244_report_saying_no B245_check_burning B246_carry_out_burning B247_report_burning B248_check_waking_up B249_carry_out_waking_up B250_report_waking_up B251_check_thinking B252_carry_out_thinking B253_report_thinking B254_check_smelling B255_carry_out_smelling B256_report_smelling B257_check_listening_to B258_carry_out_listening_to B259_report_listening_to B260_check_tasting B261_carry_out_tasting B262_report_tasting B263_check_cutting B264_carry_out_cutting B265_report_cutting B266_check_jumping B267_carry_out_jumping B268_report_jumping B269_check_tying_it_to B270_carry_out_tying_it_to B271_report_tying_it_to B272_check_drinking B273_carry_out_drinking B274_report_drinking B275_check_saying_sorry B276_carry_out_saying_sorry B277_report_saying_sorry B278_check_swearing_obscenel B279_carry_out_swearing_obsc B280_report_swearing_obscene B281_check_swearing_mildly B282_carry_out_swearing_mild B283_report_swearing_mildly B284_check_swinging B285_carry_out_swinging B286_report_swinging B287_check_rubbing B288_carry_out_rubbing B289_report_rubbing B290_check_setting_it_to B291_carry_out_setting_it_to B292_report_setting_it_to B293_check_waving_hands B294_carry_out_waving_hands B295_report_waving_hands B296_check_buying B297_carry_out_buying B298_report_buying B299_check_singing B300_carry_out_singing B301_report_singing B302_check_climbing B303_carry_out_climbing B304_report_climbing B305_check_sleeping B306_carry_out_sleeping B307_report_sleeping B308_check_requesting_the_sc B309_carry_out_requesting_th B310_report_requesting_the_s B311_check_quitting_the_game B312_carry_out_quitting_the_ B313_report_quitting_the_gam B314_check_saving_the_game B315_carry_out_saving_the_ga B316_report_saving_the_game B317_check_restoring_the_gam B318_carry_out_restoring_the B319_report_restoring_the_ga B320_check_restarting_the_ga B321_carry_out_restarting_th B322_report_restarting_the_g B323_check_verifying_the_sto B324_carry_out_verifying_the B325_report_verifying_the_st B326_check_requesting_the_st B327_carry_out_requesting_th B328_report_requesting_the_s B329_check_switching_the_sto B330_carry_out_switching_the B331_report_switching_the_st B332_check_switching_the_sto B333_carry_out_switching_the B334_report_switching_the_st B335_check_preferring_abbrev B336_carry_out_preferring_ab B337_report_preferring_abbre B338_check_preferring_unabbr B339_carry_out_preferring_un B340_report_preferring_unabb B341_check_preferring_someti B342_carry_out_preferring_so B343_report_preferring_somet B344_check_requesting_the_pr B345_carry_out_requesting_th B346_report_requesting_the_p B347_check_switching_score_n B348_carry_out_switching_sco B349_report_switching_score_ B350_check_switching_score_n B351_carry_out_switching_sco B352_report_switching_score_ B353_check_time_checking B354_carry_out_time_checking B355_report_time_checking 0;

Array B0_action_processing -->  R_17 PA_R CR_R R_18 R_19 R_20 R_21 I6_NULL;
Array B1_before -->  R_15 I6_NULL;
Constant B2_instead = EMPTY_RULEBOOK;
Array B3_after -->  R_16 I6_NULL;
Constant B4_procedural = EMPTY_RULEBOOK;
Array B5_accessibility -->  OIU_Barrier OIU_Scoped I6_NULL;
Array B6_action_specific -->  R_22 I6_NULL;
Constant B7_carry_out = EMPTY_RULEBOOK;
Constant B8_general_report = EMPTY_RULEBOOK;
Array B9_turn_sequence -->  R_11 R_10 I7ResetChooseObjects ProcessI7Timers TS1_R TS4_R R_12 TS5_R TS6_R I6_NULL;
Array B10_reaching_inside -->  OIUB_RI OIUB_CCI I6_NULL;
Array B11_reaching_outside -->  OIUB_CCO I6_NULL;
Constant B12_general_before = EMPTY_RULEBOOK;
Constant B13_actor_specific_before = EMPTY_RULEBOOK;
Constant B14_location_specific_before = EMPTY_RULEBOOK;
Constant B15_reaction_before = EMPTY_RULEBOOK;
Constant B16_object_specific_before = EMPTY_RULEBOOK;
Constant B17_general_after = EMPTY_RULEBOOK;
Constant B18_actor_specific_after = EMPTY_RULEBOOK;
Constant B19_location_specific_after = EMPTY_RULEBOOK;
Constant B20_reaction_after = EMPTY_RULEBOOK;
Constant B21_object_specific_after = EMPTY_RULEBOOK;
Array B22_when_play_begins -->  R_9 R_550 R_551 I6_NULL;
Constant B23_when_play_ends = EMPTY_RULEBOOK;
Array B24_every_turn -->  R_554 I6_NULL;
Constant B25_check = EMPTY_RULEBOOK;
Constant B26_report = EMPTY_RULEBOOK;
Constant B27_persuasion = EMPTY_RULEBOOK;
Constant B28_unsuccessful_attempt_by = EMPTY_RULEBOOK;
Array B29_visibility -->  CSITDR I6_NULL;
Array B30_does_the_player_mean -->  R_14 I6_NULL;
Array B31_setting_action_variables -->  R_30 R_79 R_111 R_99 I6_NULL;
Array B32_scene_changing -->  R_13 I6_NULL;
Constant B33_when_entire_game_begins = EMPTY_RULEBOOK;
Constant B34_when_entire_game_ends = EMPTY_RULEBOOK;
Array B35_before_printing_the_name -->  R_25 I6_NULL;
Array B36_for_printing_the_name -->  R_23 I6_NULL;
Constant B37_after_printing_the_name = EMPTY_RULEBOOK;
Constant B38_before_listing_contents = EMPTY_RULEBOOK;
Array B39_for_listing_contents -->  R_24 I6_NULL;
Constant B40_after_listing_contents = EMPTY_RULEBOOK;
Constant B41_before_grouping_together = EMPTY_RULEBOOK;
Constant B42_for_grouping_together = EMPTY_RULEBOOK;
Constant B43_after_grouping_together = EMPTY_RULEBOOK;
Constant B44_before_constructing_the_ = EMPTY_RULEBOOK;
Constant B45_for_constructing_the_sta = EMPTY_RULEBOOK;
Constant B46_after_constructing_the_s = EMPTY_RULEBOOK;
Constant B47_before_listing_nondescri = EMPTY_RULEBOOK;
Constant B48_for_listing_nondescript_ = EMPTY_RULEBOOK;
Constant B49_after_listing_nondescrip = EMPTY_RULEBOOK;
Constant B50_before_deciding_the_scop = EMPTY_RULEBOOK;
Constant B51_for_deciding_the_scope = EMPTY_RULEBOOK;
Constant B52_after_deciding_the_scope = EMPTY_RULEBOOK;
Constant B53_before_supplying_a_missi = EMPTY_RULEBOOK;
Array B54_for_supplying_a_missing_ -->  R_235 R_236 R_237 I6_NULL;
Constant B55_after_supplying_a_missin = EMPTY_RULEBOOK;
Constant B56_before_supplying_a_missi = EMPTY_RULEBOOK;
Constant B57_for_supplying_a_missing_ = EMPTY_RULEBOOK;
Constant B58_after_supplying_a_missin = EMPTY_RULEBOOK;
Constant B59_before_reading_a_command = EMPTY_RULEBOOK;
Constant B60_for_reading_a_command = EMPTY_RULEBOOK;
Constant B61_after_reading_a_command = EMPTY_RULEBOOK;
Constant B62_before_deciding_whether_ = EMPTY_RULEBOOK;
Constant B63_for_deciding_whether_all = EMPTY_RULEBOOK;
Constant B64_after_deciding_whether_a = EMPTY_RULEBOOK;
Constant B65_before_printing_the_play = EMPTY_RULEBOOK;
Array B66_for_printing_the_player_ -->  OBIT_HEAD OBIT_FINAL OBIT_DISP I6_NULL;
Constant B67_after_printing_the_playe = EMPTY_RULEBOOK;
Constant B68_before_amusing_a_victori = EMPTY_RULEBOOK;
Constant B69_for_amusing_a_victorious = EMPTY_RULEBOOK;
Constant B70_after_amusing_a_victorio = EMPTY_RULEBOOK;
Constant B71_before_printing_the_bann = EMPTY_RULEBOOK;
Constant B72_for_printing_the_banner_ = EMPTY_RULEBOOK;
Constant B73_after_printing_the_banne = EMPTY_RULEBOOK;
Constant B74_before_printing_the_plur = EMPTY_RULEBOOK;
Constant B75_for_printing_the_plural_ = EMPTY_RULEBOOK;
Constant B76_after_printing_the_plura = EMPTY_RULEBOOK;
Constant B77_before_deciding_the_conc = EMPTY_RULEBOOK;
Array B78_for_deciding_the_conceal -->  R_552 I6_NULL;
Constant B79_after_deciding_the_conce = EMPTY_RULEBOOK;
Constant B80_before_printing_a_refusa = EMPTY_RULEBOOK;
Constant B81_for_printing_a_refusal_t = EMPTY_RULEBOOK;
Constant B82_after_printing_a_refusal = EMPTY_RULEBOOK;
Constant B83_before_printing_the_anno = EMPTY_RULEBOOK;
Constant B84_for_printing_the_announc = EMPTY_RULEBOOK;
Constant B85_after_printing_the_annou = EMPTY_RULEBOOK;
Constant B86_before_printing_the_name = EMPTY_RULEBOOK;
Constant B87_for_printing_the_name_of = EMPTY_RULEBOOK;
Constant B88_after_printing_the_name_ = EMPTY_RULEBOOK;
Constant B89_before_printing_the_desc = EMPTY_RULEBOOK;
Constant B90_for_printing_the_descrip = EMPTY_RULEBOOK;
Constant B91_after_printing_the_descr = EMPTY_RULEBOOK;
Constant B92_before_printing_room_des = EMPTY_RULEBOOK;
Constant B93_for_printing_room_descri = EMPTY_RULEBOOK;
Constant B94_after_printing_room_desc = EMPTY_RULEBOOK;
Constant B95_before_printing_a_parser = EMPTY_RULEBOOK;
Constant B96_for_printing_a_parser_er = EMPTY_RULEBOOK;
Constant B97_after_printing_a_parser_ = EMPTY_RULEBOOK;
Constant B98_before_implicitly_taking = EMPTY_RULEBOOK;
Constant B99_for_implicitly_taking = EMPTY_RULEBOOK;
Constant B100_after_implicitly_taking = EMPTY_RULEBOOK;
Constant B101_before_starting_the_vir = EMPTY_RULEBOOK;
Constant B102_for_starting_the_virtua = EMPTY_RULEBOOK;
Constant B103_after_starting_the_virt = EMPTY_RULEBOOK;
Constant B104_before_clarifying_the_p = EMPTY_RULEBOOK;
Constant B105_for_clarifying_the_pars = EMPTY_RULEBOOK;
Constant B106_after_clarifying_the_pa = EMPTY_RULEBOOK;
Constant B107_before_asking_which_do_ = EMPTY_RULEBOOK;
Constant B108_for_asking_which_do_you = EMPTY_RULEBOOK;
Constant B109_after_asking_which_do_y = EMPTY_RULEBOOK;
Constant B110_before_writing_a_paragr = EMPTY_RULEBOOK;
Constant B111_for_writing_a_paragraph = EMPTY_RULEBOOK;
Constant B112_after_writing_a_paragra = EMPTY_RULEBOOK;
Constant B113_check_taking_inventory = EMPTY_RULEBOOK;
Array B114_carry_out_taking_invent -->  R_26 R_27 R_28 I6_NULL;
Array B115_report_taking_inventory -->  R_29 I6_NULL;
Array B116_check_taking -->  R_31 R_32 R_33 R_34 R_35 R_36 R_37 R_38 R_39 R_40 R_41 I6_NULL;
Array B117_carry_out_taking -->  R_42 I6_NULL;
Array B118_report_taking -->  R_43 R_44 I6_NULL;
Array B119_check_removing_it_from -->  R_34 R_45 R_46 R_47 I6_NULL;
Constant B120_carry_out_removing_it_f = EMPTY_RULEBOOK;
Constant B121_report_removing_it_from = EMPTY_RULEBOOK;
Array B122_check_dropping -->  R_48 R_49 R_50 R_51 R_52 I6_NULL;
Array B123_carry_out_dropping -->  R_53 I6_NULL;
Array B124_report_dropping -->  R_54 I6_NULL;
Array B125_check_putting_it_on -->  R_55 R_56 R_57 R_58 R_59 R_60 R_61 I6_NULL;
Array B126_carry_out_putting_it_on -->  R_62 I6_NULL;
Array B127_report_putting_it_on -->  R_63 R_64 I6_NULL;
Array B128_check_inserting_it_into -->  R_65 R_66 R_67 R_68 R_69 R_70 R_71 I6_NULL;
Array B129_carry_out_inserting_it_ -->  R_72 I6_NULL;
Array B130_report_inserting_it_int -->  R_73 R_74 I6_NULL;
Array B131_check_eating -->  R_75 R_76 I6_NULL;
Array B132_carry_out_eating -->  R_77 I6_NULL;
Array B133_report_eating -->  R_78 I6_NULL;
Array B134_check_going -->  R_80 R_81 R_82 R_83 R_84 I6_NULL;
Array B135_carry_out_going -->  R_85 R_86 R_87 I6_NULL;
Array B136_report_going -->  R_88 I6_NULL;
Array B137_check_entering -->  R_89 R_90 R_91 R_92 R_93 R_94 R_95 I6_NULL;
Array B138_carry_out_entering -->  R_96 I6_NULL;
Array B139_report_entering -->  R_97 R_98 I6_NULL;
Array B140_check_exiting -->  R_100 R_101 R_102 R_103 I6_NULL;
Array B141_carry_out_exiting -->  R_104 I6_NULL;
Array B142_report_exiting -->  R_105 R_106 I6_NULL;
Array B143_check_getting_off -->  R_107 I6_NULL;
Array B144_carry_out_getting_off -->  R_108 I6_NULL;
Array B145_report_getting_off -->  R_109 R_110 I6_NULL;
Constant B146_check_looking = EMPTY_RULEBOOK;
Array B147_carry_out_looking -->  R_112 R_113 R_114 R_115 I6_NULL;
Array B148_report_looking -->  R_116 I6_NULL;
Constant B149_check_examining = EMPTY_RULEBOOK;
Array B150_carry_out_examining -->  R_117 R_118 R_119 R_120 R_121 R_122 I6_NULL;
Array B151_report_examining -->  R_123 I6_NULL;
Constant B152_check_looking_under = EMPTY_RULEBOOK;
Array B153_carry_out_looking_under -->  R_124 I6_NULL;
Array B154_report_looking_under -->  R_125 I6_NULL;
Array B155_check_searching -->  R_126 R_127 I6_NULL;
Constant B156_carry_out_searching = EMPTY_RULEBOOK;
Array B157_report_searching -->  R_128 R_129 R_130 I6_NULL;
Constant B158_check_consulting_it_abo = EMPTY_RULEBOOK;
Constant B159_carry_out_consulting_it = EMPTY_RULEBOOK;
Array B160_report_consulting_it_ab -->  R_131 I6_NULL;
Array B161_check_locking_it_with -->  R_132 R_133 R_134 R_135 I6_NULL;
Array B162_carry_out_locking_it_wi -->  R_136 I6_NULL;
Array B163_report_locking_it_with -->  R_137 I6_NULL;
Array B164_check_unlocking_it_with -->  R_138 R_139 R_140 I6_NULL;
Array B165_carry_out_unlocking_it_ -->  R_141 I6_NULL;
Array B166_report_unlocking_it_wit -->  R_142 I6_NULL;
Array B167_check_switching_on -->  R_143 R_144 I6_NULL;
Array B168_carry_out_switching_on -->  R_145 I6_NULL;
Array B169_report_switching_on -->  R_146 I6_NULL;
Array B170_check_switching_off -->  R_147 R_148 I6_NULL;
Array B171_carry_out_switching_off -->  R_149 I6_NULL;
Array B172_report_switching_off -->  R_150 I6_NULL;
Array B173_check_opening -->  R_151 R_152 R_153 I6_NULL;
Array B174_carry_out_opening -->  R_154 I6_NULL;
Array B175_report_opening -->  R_155 R_156 I6_NULL;
Array B176_check_closing -->  R_157 R_158 I6_NULL;
Array B177_carry_out_closing -->  R_159 I6_NULL;
Array B178_report_closing -->  R_160 I6_NULL;
Array B179_check_wearing -->  R_161 R_162 R_163 I6_NULL;
Array B180_carry_out_wearing -->  R_164 I6_NULL;
Array B181_report_wearing -->  R_165 I6_NULL;
Array B182_check_taking_off -->  R_166 I6_NULL;
Array B183_carry_out_taking_off -->  R_167 I6_NULL;
Array B184_report_taking_off -->  R_168 I6_NULL;
Array B185_check_giving_it_to -->  R_169 R_170 R_171 R_172 I6_NULL;
Array B186_carry_out_giving_it_to -->  R_173 I6_NULL;
Array B187_report_giving_it_to -->  R_174 I6_NULL;
Array B188_check_showing_it_to -->  R_175 R_176 R_177 I6_NULL;
Constant B189_carry_out_showing_it_to = EMPTY_RULEBOOK;
Constant B190_report_showing_it_to = EMPTY_RULEBOOK;
Array B191_check_waking -->  R_178 I6_NULL;
Constant B192_carry_out_waking = EMPTY_RULEBOOK;
Constant B193_report_waking = EMPTY_RULEBOOK;
Array B194_check_throwing_it_at -->  R_179 R_180 R_181 I6_NULL;
Constant B195_carry_out_throwing_it_a = EMPTY_RULEBOOK;
Constant B196_report_throwing_it_at = EMPTY_RULEBOOK;
Array B197_check_attacking -->  R_182 I6_NULL;
Constant B198_carry_out_attacking = EMPTY_RULEBOOK;
Constant B199_report_attacking = EMPTY_RULEBOOK;
Array B200_check_kissing -->  R_183 R_184 I6_NULL;
Constant B201_carry_out_kissing = EMPTY_RULEBOOK;
Constant B202_report_kissing = EMPTY_RULEBOOK;
Constant B203_check_answering_it_that = EMPTY_RULEBOOK;
Constant B204_carry_out_answering_it_ = EMPTY_RULEBOOK;
Array B205_report_answering_it_tha -->  R_185 I6_NULL;
Array B206_check_telling_it_about -->  R_186 I6_NULL;
Constant B207_carry_out_telling_it_ab = EMPTY_RULEBOOK;
Array B208_report_telling_it_about -->  R_187 I6_NULL;
Constant B209_check_asking_it_about = EMPTY_RULEBOOK;
Constant B210_carry_out_asking_it_abo = EMPTY_RULEBOOK;
Array B211_report_asking_it_about -->  R_188 I6_NULL;
Array B212_check_asking_it_for -->  R_189 R_190 I6_NULL;
Constant B213_carry_out_asking_it_for = EMPTY_RULEBOOK;
Constant B214_report_asking_it_for = EMPTY_RULEBOOK;
Constant B215_check_waiting = EMPTY_RULEBOOK;
Constant B216_carry_out_waiting = EMPTY_RULEBOOK;
Array B217_report_waiting -->  R_191 I6_NULL;
Constant B218_check_touching = EMPTY_RULEBOOK;
Constant B219_carry_out_touching = EMPTY_RULEBOOK;
Array B220_report_touching -->  R_192 R_193 R_194 I6_NULL;
Array B221_check_waving -->  R_195 I6_NULL;
Constant B222_carry_out_waving = EMPTY_RULEBOOK;
Array B223_report_waving -->  R_196 I6_NULL;
Array B224_check_pulling -->  R_197 R_198 R_199 I6_NULL;
Constant B225_carry_out_pulling = EMPTY_RULEBOOK;
Array B226_report_pulling -->  R_200 I6_NULL;
Array B227_check_pushing -->  R_201 R_202 R_203 I6_NULL;
Constant B228_carry_out_pushing = EMPTY_RULEBOOK;
Array B229_report_pushing -->  R_204 I6_NULL;
Array B230_check_turning -->  R_205 R_206 R_207 I6_NULL;
Constant B231_carry_out_turning = EMPTY_RULEBOOK;
Array B232_report_turning -->  R_208 I6_NULL;
Array B233_check_pushing_it_to -->  R_209 I6_NULL;
Constant B234_carry_out_pushing_it_to = EMPTY_RULEBOOK;
Constant B235_report_pushing_it_to = EMPTY_RULEBOOK;
Array B236_check_squeezing -->  R_210 I6_NULL;
Constant B237_carry_out_squeezing = EMPTY_RULEBOOK;
Array B238_report_squeezing -->  R_211 I6_NULL;
Array B239_check_saying_yes -->  R_212 I6_NULL;
Constant B240_carry_out_saying_yes = EMPTY_RULEBOOK;
Constant B241_report_saying_yes = EMPTY_RULEBOOK;
Array B242_check_saying_no -->  R_213 I6_NULL;
Constant B243_carry_out_saying_no = EMPTY_RULEBOOK;
Constant B244_report_saying_no = EMPTY_RULEBOOK;
Array B245_check_burning -->  R_214 I6_NULL;
Constant B246_carry_out_burning = EMPTY_RULEBOOK;
Constant B247_report_burning = EMPTY_RULEBOOK;
Array B248_check_waking_up -->  R_215 I6_NULL;
Constant B249_carry_out_waking_up = EMPTY_RULEBOOK;
Constant B250_report_waking_up = EMPTY_RULEBOOK;
Array B251_check_thinking -->  R_216 I6_NULL;
Constant B252_carry_out_thinking = EMPTY_RULEBOOK;
Constant B253_report_thinking = EMPTY_RULEBOOK;
Array B254_check_smelling -->  R_217 I6_NULL;
Constant B255_carry_out_smelling = EMPTY_RULEBOOK;
Constant B256_report_smelling = EMPTY_RULEBOOK;
Array B257_check_listening_to -->  R_218 I6_NULL;
Constant B258_carry_out_listening_to = EMPTY_RULEBOOK;
Constant B259_report_listening_to = EMPTY_RULEBOOK;
Array B260_check_tasting -->  R_219 I6_NULL;
Constant B261_carry_out_tasting = EMPTY_RULEBOOK;
Constant B262_report_tasting = EMPTY_RULEBOOK;
Array B263_check_cutting -->  R_220 I6_NULL;
Constant B264_carry_out_cutting = EMPTY_RULEBOOK;
Constant B265_report_cutting = EMPTY_RULEBOOK;
Array B266_check_jumping -->  R_221 I6_NULL;
Constant B267_carry_out_jumping = EMPTY_RULEBOOK;
Constant B268_report_jumping = EMPTY_RULEBOOK;
Array B269_check_tying_it_to -->  R_222 I6_NULL;
Constant B270_carry_out_tying_it_to = EMPTY_RULEBOOK;
Constant B271_report_tying_it_to = EMPTY_RULEBOOK;
Array B272_check_drinking -->  R_223 I6_NULL;
Constant B273_carry_out_drinking = EMPTY_RULEBOOK;
Constant B274_report_drinking = EMPTY_RULEBOOK;
Array B275_check_saying_sorry -->  R_224 I6_NULL;
Constant B276_carry_out_saying_sorry = EMPTY_RULEBOOK;
Constant B277_report_saying_sorry = EMPTY_RULEBOOK;
Array B278_check_swearing_obscenel -->  R_225 I6_NULL;
Constant B279_carry_out_swearing_obsc = EMPTY_RULEBOOK;
Constant B280_report_swearing_obscene = EMPTY_RULEBOOK;
Array B281_check_swearing_mildly -->  R_226 I6_NULL;
Constant B282_carry_out_swearing_mild = EMPTY_RULEBOOK;
Constant B283_report_swearing_mildly = EMPTY_RULEBOOK;
Array B284_check_swinging -->  R_227 I6_NULL;
Constant B285_carry_out_swinging = EMPTY_RULEBOOK;
Constant B286_report_swinging = EMPTY_RULEBOOK;
Array B287_check_rubbing -->  R_228 I6_NULL;
Constant B288_carry_out_rubbing = EMPTY_RULEBOOK;
Constant B289_report_rubbing = EMPTY_RULEBOOK;
Array B290_check_setting_it_to -->  R_229 I6_NULL;
Constant B291_carry_out_setting_it_to = EMPTY_RULEBOOK;
Constant B292_report_setting_it_to = EMPTY_RULEBOOK;
Array B293_check_waving_hands -->  R_230 I6_NULL;
Constant B294_carry_out_waving_hands = EMPTY_RULEBOOK;
Constant B295_report_waving_hands = EMPTY_RULEBOOK;
Array B296_check_buying -->  R_231 I6_NULL;
Constant B297_carry_out_buying = EMPTY_RULEBOOK;
Constant B298_report_buying = EMPTY_RULEBOOK;
Array B299_check_singing -->  R_232 I6_NULL;
Constant B300_carry_out_singing = EMPTY_RULEBOOK;
Constant B301_report_singing = EMPTY_RULEBOOK;
Array B302_check_climbing -->  R_233 I6_NULL;
Constant B303_carry_out_climbing = EMPTY_RULEBOOK;
Constant B304_report_climbing = EMPTY_RULEBOOK;
Array B305_check_sleeping -->  R_234 I6_NULL;
Constant B306_carry_out_sleeping = EMPTY_RULEBOOK;
Constant B307_report_sleeping = EMPTY_RULEBOOK;
Constant B308_check_requesting_the_sc = EMPTY_RULEBOOK;
Array B309_carry_out_requesting_th -->  ScoreSub_O1 I6_NULL;
Constant B310_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B311_check_quitting_the_game = EMPTY_RULEBOOK;
Array B312_carry_out_quitting_the_ -->  QuitSub_O1 I6_NULL;
Constant B313_report_quitting_the_gam = EMPTY_RULEBOOK;
Constant B314_check_saving_the_game = EMPTY_RULEBOOK;
Array B315_carry_out_saving_the_ga -->  SaveSub_O1 I6_NULL;
Constant B316_report_saving_the_game = EMPTY_RULEBOOK;
Constant B317_check_restoring_the_gam = EMPTY_RULEBOOK;
Array B318_carry_out_restoring_the -->  RestoreSub_O1 I6_NULL;
Constant B319_report_restoring_the_ga = EMPTY_RULEBOOK;
Constant B320_check_restarting_the_ga = EMPTY_RULEBOOK;
Array B321_carry_out_restarting_th -->  RestartSub_O1 I6_NULL;
Constant B322_report_restarting_the_g = EMPTY_RULEBOOK;
Constant B323_check_verifying_the_sto = EMPTY_RULEBOOK;
Array B324_carry_out_verifying_the -->  VerifySub_O1 I6_NULL;
Constant B325_report_verifying_the_st = EMPTY_RULEBOOK;
Constant B326_check_requesting_the_st = EMPTY_RULEBOOK;
Array B327_carry_out_requesting_th -->  VersionSub_O1 I6_NULL;
Constant B328_report_requesting_the_s = EMPTY_RULEBOOK;
Constant B329_check_switching_the_sto = EMPTY_RULEBOOK;
Array B330_carry_out_switching_the -->  ScriptOnSub_O1 I6_NULL;
Constant B331_report_switching_the_st = EMPTY_RULEBOOK;
Constant B332_check_switching_the_sto = EMPTY_RULEBOOK;
Array B333_carry_out_switching_the -->  ScriptOffSub_O1 I6_NULL;
Constant B334_report_switching_the_st = EMPTY_RULEBOOK;
Constant B335_check_preferring_abbrev = EMPTY_RULEBOOK;
Array B336_carry_out_preferring_ab -->  LMode3Sub_O1 I6_NULL;
Constant B337_report_preferring_abbre = EMPTY_RULEBOOK;
Constant B338_check_preferring_unabbr = EMPTY_RULEBOOK;
Array B339_carry_out_preferring_un -->  LMode2Sub_O1 I6_NULL;
Constant B340_report_preferring_unabb = EMPTY_RULEBOOK;
Constant B341_check_preferring_someti = EMPTY_RULEBOOK;
Array B342_carry_out_preferring_so -->  LMode1Sub_O1 I6_NULL;
Constant B343_report_preferring_somet = EMPTY_RULEBOOK;
Constant B344_check_requesting_the_pr = EMPTY_RULEBOOK;
Array B345_carry_out_requesting_th -->  PronounsSub_O1 I6_NULL;
Constant B346_report_requesting_the_p = EMPTY_RULEBOOK;
Constant B347_check_switching_score_n = EMPTY_RULEBOOK;
Array B348_carry_out_switching_sco -->  NotifyOnSub_O1 I6_NULL;
Constant B349_report_switching_score_ = EMPTY_RULEBOOK;
Constant B350_check_switching_score_n = EMPTY_RULEBOOK;
Array B351_carry_out_switching_sco -->  NotifyOffSub_O1 I6_NULL;
Constant B352_report_switching_score_ = EMPTY_RULEBOOK;
Constant B353_check_time_checking = EMPTY_RULEBOOK;
Array B354_carry_out_time_checking -->  R_553 I6_NULL;
Constant B355_report_time_checking = EMPTY_RULEBOOK;

! MStack.i6 segment
! Providing a second in-memory stack for temporary variables attached to
! rulebooks, activities, actions and the like

Constant MAX_MSTACK_FRAME = 2 + 5;
Constant MSTACK_CAPACITY = 20;
Constant MSTACK_SIZE = MSTACK_CAPACITY*MAX_MSTACK_FRAME;

Array MStack --> MSTACK_SIZE;
Global MStack_Top = 0;

[ Mstack_Create_Frame creator id extent;
	if (creator == 0) rfalse;
	extent = creator.call(MStack_Top+2);
	if (extent == 0) rfalse;
	if (MStack_Top + MAX_MSTACK_FRAME >= MSTACK_SIZE + 2) {
		print "Variable stack exhausted^";
		Mstack_Backtrace();
		rfalse;
	}
	MStack_Top++;
	MStack-->MStack_Top = id;
	MStack_Top++;
	MStack_Top = MStack_Top + extent;
	MStack-->MStack_Top = -(extent+2);
	! Mstack_Backtrace();
	rtrue;
];

Global MStack_Frame_Extent = 0;

[ Mstack_Backtrace pos k;
	print "Mstack backtrace: size ", MStack_Top+1, " words^";
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		print "Block at ", pos+2,
			" owner ID ", MStack-->(pos+1), " size ", MStack_Frame_Extent, "^";
		for (k=0: k<MStack_Frame_Extent: k++) print MStack-->(pos+2+k), " ";
		print "^";
	}
];

[ Mstack_Seek_Frame id pos;
	pos = MStack_Top;
	while (MStack-->pos ~= 0) {
		MStack_Frame_Extent = MStack-->pos;
		pos = pos + MStack_Frame_Extent;
		MStack_Frame_Extent = (-2) - MStack_Frame_Extent;
		if (MStack-->(pos+1) == id) return pos+2;
	}
	MStack_Frame_Extent = 0;
	return 0; ! Not found
];

[ Mstack_Destroy_Frame id pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) rfalse; ! Not found: do nothing
	MStack_Top = pos - 2; ! Clear mstack down to just below this frame
	rtrue;
];

[ MstVO id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		print "Variable unavailable: ", id, "/", off, "^";
		rfalse;
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

[ MstVON id off pos;
	pos = Mstack_Seek_Frame(id);
	if (pos == 0) {
		return 0; ! because word 0 is 0 == nothing in I6 terms
	}
	if ((off<0) || (off >= MStack_Frame_Extent)) {
		print "Variable stack offset wrong: ", id, "/", off, " at ", pos, "^";
		rfalse;
	}
	return pos+off;
];

! Blocks can be attached to rulebooks (id = allocation id) or to activities
! (id = 10000 + allocation id) or to actions (20000 + allocation id)

Array rulebook_var_creators --> RBSTVC_0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;
[  RBSTVC_0 X;
  MStack-->X = selfobj; X++;
  return 1;
];

Array activity_var_creators --> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0;


[ MStack_CreateRBVars rb cr;
	cr = rulebook_var_creators-->rb;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, rb);
];

[ MStack_DestroyRBVars rb cr;
	cr = rulebook_var_creators-->rb;
	if (cr == 0) return;
	Mstack_Destroy_Frame(rb);
];

[ MStack_CreateAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Create_Frame(cr, av + 10000);
];

[ MStack_DestroyAVVars av cr;
	cr = activity_var_creators-->av;
	if (cr == 0) return;
	Mstack_Destroy_Frame(av + 10000);
];

! End of MStack.i6 segment


! RTP.i6 segment
! Reporting of run-time problems in a format which can be parsed by the
! Inform application

Global I7_enable_rte = true;

Constant RTP_BACKDROP 1;
Constant RTP_EXITDOOR 2;
Constant RTP_NOEXIT 3;
Constant RTP_CANTCHANGE 4;
Constant RTP_IMPREL 5;
Constant RTP_RULESTACK 6;
Constant RTP_TOOMANYRULEBOOKS 7;
Constant RTP_TOOMANYEVENTS 8;
Constant RTP_BADPROPERTY 9;
Constant RTP_UNPROVIDED 10;
Constant RTP_UNSET 11;
Constant RTP_TOOMANYACTS 12;
Constant RTP_CANTABANDON 13;
Constant RTP_CANTEND 14;
Constant RTP_CANTMOVENOTHING 15;
Constant RTP_CANTREMOVENOTHING 16;
Constant RTP_DIVZERO 17;
Constant RTP_BADVALUEPROPERTY 18;
Constant RTP_NOTBACKDROP 19;
Constant RTP_TABLE_NOCOL 20;
Constant RTP_TABLE_NOCORR 21;
Constant RTP_TABLE_NOROW 22;
Constant RTP_TABLE_NOENTRY 23;
Constant RTP_TABLE_NOTABLE 24;
Constant RTP_TABLE_NOMOREBLANKS 25;
Constant RTP_TABLE_NOROWS 26;
Constant RTP_TABLE_CANTSORT 27;
Constant RTP_NOTINAROOM 28;
Constant RTP_BADTOPIC 29;
Constant RTP_ROUTELESS 30;
Constant RTP_PROPOFNOTHING 31;
Constant RTP_DECIDEONWRONGKIND 32;
Constant RTP_DECIDEONNOTHING 33;

[ RunTimeProblem n obj obj2 ln obj3 i c;
	! if (I7_enable_rte == false) return;
	I7_enable_rte = false;
	print "^*** Run-time problem P", n;
	! if (ln == 0) ln=1;
	if (ln) print " (at paragraph ", ln, " in the source text)";
	print ": ";
	switch(n) {
		RTP_BACKDROP:
			print "Tried to move ", (the) obj, " (a backdrop) to ", (the) obj2,
				", which is not a region.^";
		RTP_CANTCHANGE:
			print "Tried to change player to ", (the) obj,
				", which is not a player-character.^";
		RTP_NOEXIT:
		    print "Tried to change ", (the) obj2, " exit of ", (the) obj,
		    	", but it didn't seem to have such an exit to change.^";
		RTP_EXITDOOR:
		    print "Tried to change ", (the) obj2, " exit of ", (the) obj,
		    	", but it led to a door, not a room.^";
		RTP_IMPREL:
			print "Tried to access an inappropriate relation for ", (the) obj,
				", violating '";
			for (i=0: RelationList-->i ~= I6_NULL: i=i+3) {
				c = RelationList-->(i+1);
				if (((c == Relation_VtoV) || (c == Relation_Sym_VtoV))
					&& (obj2 == RelationList-->i)) {
					print (string) RelationList-->(i+2), "'.^";
				}
			}
		RTP_RULESTACK:
			print "Too many procedural rules acting all at once.^";
		RTP_TOOMANYRULEBOOKS:
			print "Too many rulebooks in simultaneous use.^";
		RTP_TOOMANYEVENTS:
			print "Too many timed events are going on at once.^";
		RTP_BADPROPERTY:
			print "Tried to access non-existent property for ", (the) obj, ".^";
		RTP_UNPROVIDED:
			print "Since ", (the) obj, " is not allowed the property ~",
					(string) obj2, "~, it is against the rules to try to use it.^";
		RTP_UNSET:
			print "Although ", (the) obj, " is allowed to have the property ~",
				(string) obj2, "~, no value was ever given, so it can't now be used.^";
		RTP_TOOMANYACTS:
			print "Too many activities are going on at once.^";
		RTP_CANTABANDON:
			print "Tried to abandon an activity which wasn't going on.^";
		RTP_CANTEND:
			print "Tried to end an activity which wasn't going on.^";
		RTP_CANTMOVENOTHING:
			print "You can't move nothing.^";
		RTP_CANTREMOVENOTHING:
			print "You can't remove nothing from play.^";
		RTP_DIVZERO:
			print "You can't divide by zero.^";
		RTP_BADVALUEPROPERTY:
			print "Tried to access property for a value which didn't fit: ",
				"if this were a number it would be ", obj, ".^";
		RTP_NOTBACKDROP:
			print "Tried to move ", (the) obj, " (not a backdrop) to ", (the) obj2,
				", which is a region.^";
		RTP_TABLE_NOCOL:
			print "Attempt to look up a non-existent column in the table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_NOCORR:
			print "Attempt to look up a non-existent correspondence in the table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_NOROW:
			print "Attempt to look up a non-existent row in the table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_NOENTRY:
			print "Attempt to look up a non-existent entry at column ", obj2,
				", row ", obj3, " of the table '", (PrintTableName) obj, "'.^";
		RTP_TABLE_NOTABLE:
			print "Attempt to blank out a row from a non-existent table (value ",
				obj, ").^";
		RTP_TABLE_NOMOREBLANKS:
			print "Attempt to choose a blank row in a table with none left: table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_NOROWS:
			print "Attempt to choose a random row in an entirely blank table: table '",
				(PrintTableName) obj, "'.^";
		RTP_TABLE_CANTSORT:
			print "Attempt to sort a table whose ordering must remain fixed: table '",
				(PrintTableName) obj, "'.^";
		RTP_NOTINAROOM:
			print "Attempt to test if the current location is '",
				(the) obj, "', which is not a room or region.^";
		RTP_BADTOPIC:
			print "Attempt to see if a snippet of text matches something which
				is not a topic.^";
		RTP_ROUTELESS:
			print "Attempt to find route or count steps through an implicit
				relation.^";
		RTP_PROPOFNOTHING:
			print "Attempt to use a property of the 'nothing' non-object.^";
		RTP_DECIDEONWRONGKIND:
			print "Attempt to 'decide on V' where V is the wrong kind of object.^";
		RTP_DECIDEONNOTHING:
			print "Attempt to 'decide on nothing'.^";
		}
	print "^";
];

! Protected Z-machine division routines:

[ I7_Divide A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A/B;
];

[ I7_Rem A B;
	if (B == 0) { RunTimeProblem(RTP_DIVZERO); rfalse; }
	return A%B;
];

! Checked return values:

[ I7_VerifyK V K;
	if (V ofclass K) return V;
	if (v == nothing) RunTimeProblem(RTP_DECIDEONNOTHING);
	else RunTimeProblem(RTP_DECIDEONWRONGKIND);
	return V;
];

! Protected Z-machine property and attribute access:

[ I7_Provides o either_or p;
	return HypotheticalProperty(either_or, o, p);
];

[ I7GetEitherOr o p;
	if (o == nothing) rfalse;
	if (p<0) p = ~p;
	if (p<I7_FBNA) {
		if (o has p) rtrue;
		rfalse;
	}
	if ((o provides p) && (o.p)) rtrue;
	rfalse;
];
[ I7SetEitherOr o p negate;
	if (p<0) { p = ~p; negate = ~negate; }
	if (negate) {
		if (PermitAttribute(true, o, p)) {
			if (p<I7_FBNA) give o ~p; else o.p = false;
		}
		return;
	}
	if (PermitAttribute(true, o, p)) {
		if (p<I7_FBNA) give o p; else o.p = true;
	}
];
[ PermitAttributeR obj off i;
	! print "Asking permission of ", (the) obj, "^";
	i=off; while (property_metadata-->i >= 0) {
	if (obj == property_metadata-->i) rtrue; i++; }
	rfalse;
];
[ HypotheticalProperty f obj att off textual i a l; if (att<0) att = ~att;
	if (metaclass(obj) ~= Object) rfalse;
	if (f) {
		if (att < I7_FBNA) off = attribute_offsets-->att;
		else off = attribute_offsets-->(50+att-I7_FBNA);
	} else off = property_offsets-->att;
	if (off<0) rfalse;
	textual = property_metadata-->off; off++;
	if (PermitAttributeR(obj, off)) jump Okay;
	if (obj provides i7_kind) { l = (obj.#i7_kind)/2; a = obj.&i7_kind;
	for (i=0: i<l: i++) if (PermitAttributeR(a-->i, off)) jump Okay; }
	rfalse;
	.Okay; if (f) rtrue;
	if (obj provides att) rtrue;
	rfalse;
];
[ PermitAttribute f obj att off textual i a l; if (att<0) att = ~att;
	if (metaclass(obj) ~= Object) rfalse;
	if (f) {
		if (att < I7_FBNA) off = attribute_offsets-->att;
		else off = attribute_offsets-->(50+att-I7_FBNA);
	} else off = property_offsets-->att;
! print "Off is ", off, "^";
! for (i=0: i<116: i++) print attribute_offsets-->i, ", ";
! print "^^Props: ";
! for (i=0: i<166: i++) print property_offsets-->i, ", ";
! print "^";
	if (off<0) return RunTimeProblem(RTP_BADPROPERTY, obj);
	textual = property_metadata-->off; off++;
	if (PermitAttributeR(obj, off)) jump Okay;
	if (obj provides i7_kind) { l = (obj.#i7_kind)/2; a = obj.&i7_kind;
	for (i=0: i<l: i++) if (PermitAttributeR(a-->i, off)) jump Okay; }
	RunTimeProblem(RTP_UNPROVIDED, obj, textual);
	rfalse;
	.Okay; if (f) rtrue;
	if (obj provides att) rtrue;
	RunTimeProblem(RTP_UNSET, obj, textual);
	rfalse;
];
[ AccessProp obj pr;
	if (Value_Property_Holder provides pr) {
		if ((obj<=0) || (obj > (Value_Property_Holder.pr)-->0)) {
			RunTimeProblem(RTP_BADVALUEPROPERTY);
			rfalse;
		}
		return (Value_Property_Holder.pr)-->(obj+1);
	}
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if ((pr == door_to) && (obj provides pr)) return obj.pr();
	if (PermitAttribute(false, obj, pr)) return obj.pr;
	rfalse;
];
[ WriteAccessProp obj pr val;
	if (Value_Property_Holder provides pr) {
		if ((obj<=0) || (obj > (Value_Property_Holder.pr)-->0))
			return RunTimeProblem(RTP_BADVALUEPROPERTY);
		(Value_Property_Holder.pr)-->(obj+1) = val;
		return;
	}
	if (obj == 0) { RunTimeProblem(RTP_PROPOFNOTHING, obj, pr); rfalse; }
	if (PermitAttribute(false, obj, pr)) obj.pr = val;
];

! Type checking failing at run-time

[ Runtime_Type_Error file line arg;
	print ">--> A mistake in the source (~", (string) file,
		"~, line ", line, ") meant that argument ", arg,
		" had the wrong type.^";
];

! End of RTP.i6 segment

! Printing.i6

!Constant TRACE_I7_SPACING;

[ I7_DefaultPrinter x;
	print x;
];

Global debug_rule_nesting;
[ SetString31 d;
	switch(d) {
		0: string 31 "";
		1: string 31 "    ";
		2: string 31 "		  ";
		3: string 31 "			  ";
		4: string 31 "					";
		default:
		   string 31 "						";
	}
];

[ I7_DivideParagraph;
#ifdef TRACE_I7_SPACING;
	print "[DP", say__p, say__pc, "]";
#endif;
	if (say__p) {
		new_line; say__p = 0; say__pc = say__pc | PARA_COMPLETED;
		if (say__pc & PARA_LINEBREAK) say__pc = say__pc - PARA_LINEBREAK;
		if (say__pc & PARA_FORCELINEBREAK)
			say__pc = say__pc - PARA_FORCELINEBREAK;
	}
#ifdef TRACE_I7_SPACING;
	print "[TO", say__p, say__pc, "]";
#endif;
];

[ I7_RunOnParagraph said;
#ifdef TRACE_I7_SPACING;
	print "[ROP(", said, ")", say__p, say__pc, "]";
#endif;
	say__p = 0; say__pc = say__pc | PARA_LINEBREAK;
	if (said) say__pc = say__pc | PARA_FORCELINEBREAK;
];

[ I7_CommandClarificationBreak;
	say__p = true; I7_DivideParagraph(); say__pc = 0; ! i.e., clear PARA_COMPLETED
];

[ I7_SpliceSnippet A B s1 s2;
	s1 = say__pc; s2 = say__p;
	SpliceSnippet(A, B);
	say__pc = s1; say__p = s2;
];

[ I7_Prompt i;
	style roman;
	if ((say__p) ||
		((say__pc & PARA_LINEBREAK) && ((say__pc & PARA_FORCELINEBREAK)==0))) {
		new_line; say__p=0; say__pc = 0;
	}
	switch(metaclass(I7_prompt_text)) {
		String: print (string) I7_prompt_text;
		Routine: I7_prompt_text();
	}
	say__p = 0; say__pc = 0;
	if (I7_box) {
		for (i=0: I7_boxes_appeared-->i: i++)
			if (I7_boxes_appeared-->i == I7_box) {
					I7_box = 0;
					return;
			}
		I7_boxes_appeared-->i = I7_box;
		I7_box();
		I7_box = 0;
		say__p = 0; say__pc = 0;
	}
	I7_enable_rte = true;
];
[ SL_Score_Moves;
	 if (I7_uninitialised) return;
	#ifdef I7_NOSCORE; print sline2; #ifnot; print sline1, "/", sline2; #endif;
];
[ SL_Location;
	 if (I7_uninitialised) return;
	 if (location == thedark) print (name) location;
	 else
	 {   FindVisibilityLevels();
		 if (visibility_ceiling == location)
			 print (name) location;
		 else print (The) visibility_ceiling;
	 }
];

#Ifdef TARGET_ZCODE;
#IfV5;
#Iftrue (#version_number == 6);

Constant DrawStatusLine_Preempted;

[ DrawStatusLine width x charw scw s spc;
	(0-->8) = (0-->8) &~ $$00000100;
	s = say__p; spc = say__pc;
	BeginActivity(3);
	StatusLineHeight(gg_statuswin_size);
	! Now clear the window. This isn't totally trivial. Our approach is to select the
	! fixed space font, measure its width, and print an appropriate
	! number of spaces. We round up if the screen isn't a whole number
	! of characters wide, and rely on window 1 being set to clip by default.
	MoveCursor(1, 1);
	@set_font 4 -> x;
	width = ScreenWidth();
	spaces width;
	say__p = 0; say__pc = 0;
	if (ForActivity(3) == false) {
	! Back to standard font for the display. We use output_stream 3 to
	! measure the space required, the aim being to get 50 characters
	! worth of space for the location name.
	MoveCursor(1, 2);
	@set_font 1 -> x;
	switch (metaclass(I7_left_sl)) {
		String: print (string) I7_left_sl;
		Routine: I7_left_sl();
	}
	@get_wind_prop 1 3 -> width;
	@get_wind_prop 1 13 -> charw;
	charw = charw & $FF;
	@output_stream 3 StorageForShortName;
	print (I7_string) I7_right_sl;
	@output_stream -3; scw = HDR_PIXELSTO3-->0 + charw;
	x = 1+width-scw;
	@set_cursor 1 x; print (I7_string) I7_right_sl;
	}
	! Reselect roman, as Infocom's interpreters interpreters go funny
	! if reverse is selected twice.
	MainWindow();
	say__p = 0; say__pc = 0;
	EndActivity(3);
	say__p = s; say__pc = spc;
];

#Endif; ! #version_number == 6
#Endif; ! V5
#Endif; ! TARGET_ZCODE

#Ifndef DrawStatusLine_Preempted;
[ DrawStatusLine width posb s spc;
	s = say__p; spc = say__pc;
	BeginActivity(3);
	StatusLineHeight(1); MoveCursor(1, 1); 
	width = ScreenWidth(); posb = width-15;
	spaces width;
	say__p = 0; say__pc = 0;
	if (ForActivity(3) == false) {
		MoveCursor(1, 2);
		switch(metaclass(I7_left_sl)) {
			String: print (string) I7_left_sl;
			Routine: I7_left_sl();
		}
		MoveCursor(1, posb);
		switch(metaclass(I7_right_sl)) {
			String: print (string) I7_right_sl;
			Routine: I7_right_sl();
		}
	}
	MoveCursor(1, 1); MainWindow();
	say__p = 0; say__pc = 0;
	EndActivity(3);
	say__p = s; say__pc = spc;
];
#Endif; ! DrawStatusLine_Preempted

[ I7_say_s; if (say__n ~= 1) print "s"; ];
[ I7_string s; if (s ofclass String) { print (string) s; return; }
	indirect(s);
];
[ I7SwapWF obj lst;
	objectloop (obj ofclass Object) {
		lst = false;
		if (obj has i7listflag) lst = true;
		give obj ~i7listflag;
		if (obj has workflag) give obj i7listflag;
		give obj ~workflag;
		if (lst) give obj workflag;
	}
];
[ I7List supp obj par flag mixed ct defart;
	objectloop (obj ofclass Object && obj has i7listflag) {
		ct++;
		if (flag == false) {
			flag = true; par = parent(obj);
		} else {
			if (parent(obj) ~= par) mixed = true;
		}
	}
	if (ct == 0) { print "nothing"; return; }
	if (supp < 0) { supp = -supp; mixed = true; defart = true; }
	if (supp & ISARE_BIT) {
		if (ct > 1) print "are "; else print "is ";
		supp = supp - ISARE_BIT;
	}
	if ((mixed == false) && (par)) {
		ct = c_style;
		I7SwapWF();
		! print "<";
		WriteListFrom(child(par), ENGLISH_BIT+WORKFLAG_BIT+supp);
		I7SwapWF();
		! print ">";
		c_style = ct;
		return;
	}

	objectloop (obj ofclass Object && obj has i7listflag) {
		give obj ~i7listflag;
		if (supp & DEFART_BIT) {
			if (defart) print (The) obj; else print (the) obj;
			defart = false;
		} else print (a) obj;
		ct--;
#ifdef US_DIALECT;
		if (ct == 1) print ", and ";
#ifnot;
		if (ct == 1) print " and ";
#endif;
		if (ct > 1) print ", ";
 }
! print ">";
];
[ I7WriteListFrom A opt;
	if (opt & EXTRAINDENT_BIT) {
		opt = opt - EXTRAINDENT_BIT;
		if (opt & WORKFLAG_BIT) opt = opt - WORKFLAG_BIT + EXTRA_WORKFLAG_BIT;
		WriteListFrom(A, opt, 1);
	}
	else WriteListFrom(A, opt);
];

[ I7_Locale L T1 T2;
	objectloop (L ofclass Object) give L ~I7_mentioned;
];

! End of Printing.i6

! Rulebooks.i6 segment

! (i) Rulebooks are numbered, and we need I6 constants for the numbers of
! some commonly used ones. (These numbers must correspond to those in the
! source of NI, and to the creation sequence in the Standard Rules.)

Constant APROC_RB				= 0;
Constant AFTER_RB				= 3;
Constant PROC_RB				= 4;
Constant ACCESS_RB				= 5;
Constant GENERIC_CARRYOUT_RB	= 7;
Constant REPLY_RB				= 8;
Constant TURNEND_RB				= 9;
Constant REACHIN_RB				= 10;
Constant REACHOUT_RB			= 11;
Constant GAME_BEGINS_RB			= 22;
Constant GAME_ENDS_RB			= 23;
Constant GENERIC_CHECK_RB		= 25;
Constant GENERIC_REPORT_RB		= 26;
Constant PERSUADE_RB			= 27;
Constant UNABLE_RB				= 28;
Constant VISIBLE_RB				= 29;
Constant SETACTIONVARS_RB		= 31;

! (ii) We maintain a "rule change stack" to keep track of any temporary
! abolition or modification of rules otherwise used in the rulebooks.
! The rule change stack contains 3-word (6 byte) records, and is defined
! in Main.i6. 

[ PushRuleChange usage rule1 rule2;
	if (rulechange_sp >= RS_CAPACITY) {
		return RunTimeProblem(RTP_RULESTACK);
	}
	rulechange_stack-->rulechange_sp++ = usage;
	rulechange_stack-->rulechange_sp++ = rule1;
	rulechange_stack-->rulechange_sp++ = rule2;
];

! The first word of each record indicates a usage type, of which one value
! is special and indicates the start of a frame. A new frame is opened on
! the stack each time a new "follow" occurs; recall that this processes a
! rulebook after consulting procedural rules, which may in turn modify
! the behaviour of other rules. These frame divisions, therefore, mark
! local scopes for modifications: anything from the top of the stack down
! to the topmost frame marker is currently in force.

Global rule_frames = 0;

Constant RS_FRAME = -1;

! The other possible values of usage are as follows:

Constant RS_DONOTRUN	= 1;
Constant RS_RUN			= 2;
Constant RS_MOVEBEFORE	= 3;
Constant RS_MOVEAFTER	= 4;
Constant RS_DONOTUSE	= 5;
Constant RS_USE			= 6;
Constant RS_SUBSTITUTE	= 7;
Constant RS_SUCCEEDS	= 8;
Constant RS_FAILS		= 9;

! (iii) To "follow" a rulebook, we start a new frame, process the
! procedural rules, then process the rulebook, then clear the frame back off
! the stack:

[ BeginFollowRulebook;
	PushRuleChange(RS_FRAME, RS_FRAME, RS_FRAME);
	rule_frames++;
	! print "+<", rule_frames, "/", rulechange_sp, ">";
	if (rule_frames == 20) {
		RunTimeProblem(RTP_TOOMANYRULEBOOKS);
		rule_frames = -1;
		return;
	}
	ProcessRulebook(PROC_RB, 0, 1);
];
[ EndFollowRulebook r x y;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) r = 1;
	else if (rulechange_stack-->rulechange_sp == RS_FAILS) r = 0;
	else r = -1;
	if (r ~= -1) {
		x = rulechange_stack-->(rulechange_sp+1);
		y = rulechange_stack-->(rulechange_sp+2);
	}
	rule_frames--;
	while (rulechange_sp > 0) {
		rulechange_sp = rulechange_sp - 3;
		if (rulechange_stack-->rulechange_sp == RS_FRAME) break;
	}
	if (rulechange_sp == 0) rule_frames = 0;
	if (r == 1) rulechange_stack-->rulechange_sp = RS_SUCCEEDS;
	else if (r == 0) rulechange_stack-->rulechange_sp = RS_FAILS;
	if (r ~= -1) {
		rulechange_stack-->(rulechange_sp+1) = x;
		rulechange_stack-->(rulechange_sp+2) = y;
	}
	! print "-<", rule_frames, "/", rulechange_sp, ">";
];

[ FollowRulebook rulebook par activity_flag rv;
	! print "^{", rulebook, "}";
	if (rulebook ~= PROC_RB) BeginFollowRulebook();
	rv = ProcessRulebook(rulebook, par, activity_flag);
	if (rulebook ~= PROC_RB) EndFollowRulebook();
	! print "{/", rulebook, "}";
	if (rv) rtrue; rfalse;
];

[ FollowRulebookSelfed R o ss rv;
	ss = self; if (o) self = o;
	rv = FollowRulebook(R, o, true);
	self = ss; return rv;
];

! (iv) The main rulebook processing routine is
!   ProcessRulebook(rulebook/rule)
! which returns true if the rulebook or rule chose to "succeed" or "fail",
! and false if it made no choice. In the event that a choice was made, the
! result is left as a record above the top of the stack, and should be
! collected immediately.
! First a variable logging the depth of recursion of rulebook processing,
! which at present is used only to print neatly formatted debugging:

Global process_rulebook_count;

! The following bitmap is used in a simple state machine while working
! through a given routine:

Constant RS_ACTIVE_BIT		= 1;
Constant RS_MOVED_BIT		= 2;
Constant RS_USERESULT_BIT	= 4;
Constant RS_ACTIVITY		= 8;
Constant RS_NOSKIPS			= 16;

! The following flag records whether we are tracing rule invocations:
Global debugging_rules = false;

[ ProcessRulebook rulebook par bits rv
	x frame_base substituted_rule usage original_deadflag ssrb;
! if ((rulebook >= 0) && (rulebook < HIGHEST_RULEBOOK_NO)) {
!	print "Rulebook ", rulebook, "^";
! }
	if ((Protect_I7_Arrays-->0 ~= 16339) ||
		(Protect_I7_Arrays-->1 ~= 12345)) {
		print "^^*** Fatal programming error: I7 arrays corrupted ***^^";
		@quit;
	}
	if (bits) bits = RS_ACTIVITY + RS_NOSKIPS;
	if (rule_frames<0) rfalse;
	original_deadflag = deadflag;
	if (par) parameter_object = par;
	for (x = rulechange_sp-3: x>=0: x = x - 3) {
		usage = rulechange_stack-->x;
		if (usage == RS_FRAME) { x=x+3; break; }
		if (rulechange_stack-->(x+1) == rulebook) {
			if (usage == RS_MOVEBEFORE) bits = bits | (RS_MOVED_BIT);
			if (usage == RS_MOVEAFTER) bits = bits | (RS_MOVED_BIT);
		}
	} if (x<0) x=0; frame_base = x;
	if ((bits & RS_MOVED_BIT) && (rv == false)) { rfalse; }
	! rv was a call parameter: it's no longer needed and is now reused
	bits = bits | RS_ACTIVE_BIT;
	bits = bits | RS_USERESULT_BIT;
	substituted_rule = rulebook; rv = 0;
	for (: x<rulechange_sp: x = x + 3) {
		usage = rulechange_stack-->x;
		if (rulechange_stack-->(x+1) == rulebook) {
			if (usage == RS_DONOTRUN) bits = bits & (~RS_ACTIVE_BIT);
			if (usage == RS_RUN) bits = bits | (RS_ACTIVE_BIT);
			if (usage == RS_DONOTUSE) bits = bits & (~RS_USERESULT_BIT);
			if (usage == RS_USE) bits = bits | (RS_USERESULT_BIT);
			if (usage == RS_SUBSTITUTE)
				substituted_rule = rulechange_stack-->(x+2);
		}
		if ((usage == RS_MOVEBEFORE) && (rulechange_stack-->(x+2) == rulebook)) {
			rv = ProcessRulebook(rulechange_stack-->(x+1),
				par, (bits & RS_ACTIVITY ~= 0), true);
			if (rv) return rv;
		}
	}
	if ((bits & RS_ACTIVE_BIT) == 0) rfalse;
	! We now reuse usage to keep the stack frame slimmer
	usage = debugging_rules;
	#ifdef DEBUG;
	AdjustDbr(substituted_rule);
	#endif;
	#ifndef I7_ECONOMY;
	if (debugging_rules) DebugRulebooks(substituted_rule, par);
	#endif;
	! (A routine defined in the I7 code generator)
	process_rulebook_count = process_rulebook_count + debugging_rules;
	if ((substituted_rule >= 0) && (substituted_rule < HIGHEST_RULEBOOK_NO)) {
		ssrb = substituted_rule;
		if (ssrb ~= APROC_RB) MStack_CreateRBVars(ssrb);
		substituted_rule = rulebooks_array-->substituted_rule;
		for (x=0, rv=0:
			(substituted_rule-->x~=I6_NULL) && (original_deadflag == deadflag):
			x++) {
			if ((rv = (ProcessRulebook(substituted_rule-->x,
				par, (bits & RS_ACTIVITY ~= 0))))
			    && (bits & RS_USERESULT_BIT)) break;
			rv = 0;
		}
		if (ssrb ~= APROC_RB) MStack_DestroyRBVars(ssrb);
	} else {
		if ((say__p) && (bits & RS_NOSKIPS == 0)) I7_DivideParagraph();
		rv = indirect(substituted_rule);
		if (rv) rv = substituted_rule;
	}
	if (rv && (bits & RS_USERESULT_BIT)) {
		#ifdef DEBUG;
		AdjustDbr(substituted_rule);
		#endif;
		  process_rulebook_count = process_rulebook_count - debugging_rules;
		  if (process_rulebook_count < 0) process_rulebook_count = 0;
		#ifndef I7_ECONOMY;
		  if (debugging_rules) {
			spaces(2*process_rulebook_count);
	  	  if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS)
	  			print "[stopped: success]^";
	  	  if (rulechange_stack-->rulechange_sp == RS_FAILS)
	  			print "[stopped: fail]^";
		}
		#endif;
		debugging_rules = usage;
		return rv;
	}
	for (x=rulechange_sp-3: x>=frame_base: x = x-3) {
		if ((rulechange_stack-->x == RS_MOVEAFTER) &&
			(rulechange_stack-->(x+2) == rulebook)) {
			rv = ProcessRulebook(rulechange_stack-->(x+1),
				par, (bits & RS_ACTIVITY ~= 0), true);
			if (rv) {
				process_rulebook_count--;
			    debugging_rules = usage;
				return rv;
			}
		}
	}
	process_rulebook_count = process_rulebook_count - debugging_rules;
	rulechange_stack-->rulechange_sp = 0;
	debugging_rules = usage;
	rfalse;
];

! (v) The following routines provide a sort of rule-changing API:

[ ResultOfRule a;
	a = rulechange_stack-->rulechange_sp;
	if ((a == RS_FAILS) || (a == RS_SUCCEEDS)) {
		a = rulechange_stack-->(rulechange_sp + 1);
		if (a) return rulechange_stack-->(rulechange_sp + 2);
	}
	rfalse;
];

[ ActRulebookSucceeds rule_id;
	if (rule_id) I7_action_deciding_rule = rule_id;
	RulebookSucceeds();
];
[ ActRulebookFails rule_id;
	if (rule_id) I7_action_deciding_rule = rule_id;
	RulebookFails();
];
[ RulebookSucceeds valueflag value;
	PushRuleChange(RS_SUCCEEDS, valueflag, value);
	rulechange_sp = rulechange_sp - 3;
];
[ RulebookFails valueflag value;
	PushRuleChange(RS_FAILS, valueflag, value);
	rulechange_sp = rulechange_sp - 3;
];
[ RulebookSucceeded;
	if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) rtrue;
	rfalse;
];

[ SuppressRule rule;
	PushRuleChange(RS_DONOTRUN, rule, 0);
];
[ ReinstateRule rule;
	PushRuleChange(RS_RUN, rule, 0);
];
[ DonotuseRule rule;
	PushRuleChange(RS_DONOTUSE, rule, 0);
];
[ UseRule rule;
	PushRuleChange(RS_USE, rule, 0);
];
[ SubstituteRule rule1 rule2;
	PushRuleChange(RS_SUBSTITUTE, rule2, rule1);
];
[ MoveRuleBefore rule1 rule2;
	PushRuleChange(RS_MOVEBEFORE, rule1, rule2);
];
[ MoveRuleAfter rule1 rule2;
	PushRuleChange(RS_MOVEAFTER, rule1, rule2);
];

! (vi) This is the I6 printing rule used for a value of kind "rule", which
! is the I6 packed address of the rule's routine:

#IFNDEF I7_ECONOMY;
Array RulebookNames -->
    "Action-processing rulebook" ! 0
    "Before rulebook" ! 1
    "Instead rulebook" ! 2
    "After rulebook" ! 3
    "Procedural rulebook" ! 4
    "Accessibility rulebook" ! 5
    "Action-specific rulebook" ! 6
    "Carry out rulebook" ! 7
    "General report rulebook" ! 8
    "Turn sequence rulebook" ! 9
    "Reaching inside rulebook" ! 10
    "Reaching outside rulebook" ! 11
    "General before rulebook" ! 12
    "Actor-specific before rulebook" ! 13
    "Location-specific before rulebook" ! 14
    "Reaction before rulebook" ! 15
    "Object-specific before rulebook" ! 16
    "General after rulebook" ! 17
    "Actor-specific after rulebook" ! 18
    "Location-specific after rulebook" ! 19
    "Reaction after rulebook" ! 20
    "Object-specific after rulebook" ! 21
    "When play begins rulebook" ! 22
    "When play ends rulebook" ! 23
    "Every turn rulebook" ! 24
    "Check rulebook" ! 25
    "Report rulebook" ! 26
    "Persuasion rulebook" ! 27
    "Unsuccessful attempt by rulebook" ! 28
    "Visibility rulebook" ! 29
    "does the player mean rulebook" ! 30
    "Setting action variables rulebook" ! 31
    "Scene changing rulebook" ! 32
    "when Entire Game begins rulebook" ! 33
    "when Entire Game ends rulebook" ! 34
    "before Printing the name rulebook" ! 35
    "for Printing the name rulebook" ! 36
    "after Printing the name rulebook" ! 37
    "before Listing contents rulebook" ! 38
    "for Listing contents rulebook" ! 39
    "after Listing contents rulebook" ! 40
    "before Grouping together rulebook" ! 41
    "for Grouping together rulebook" ! 42
    "after Grouping together rulebook" ! 43
    "before Constructing the status line rulebook" ! 44
    "for Constructing the status line rulebook" ! 45
    "after Constructing the status line rulebook" ! 46
    "before Listing nondescript items rulebook" ! 47
    "for Listing nondescript items rulebook" ! 48
    "after Listing nondescript items rulebook" ! 49
    "before Deciding the scope rulebook" ! 50
    "for Deciding the scope rulebook" ! 51
    "after Deciding the scope rulebook" ! 52
    "before Supplying a missing noun rulebook" ! 53
    "for Supplying a missing noun rulebook" ! 54
    "after Supplying a missing noun rulebook" ! 55
    "before Supplying a missing second noun rulebook" ! 56
    "for Supplying a missing second noun rulebook" ! 57
    "after Supplying a missing second noun rulebook" ! 58
    "before Reading a command rulebook" ! 59
    "for Reading a command rulebook" ! 60
    "after Reading a command rulebook" ! 61
    "before Deciding whether all includes rulebook" ! 62
    "for Deciding whether all includes rulebook" ! 63
    "after Deciding whether all includes rulebook" ! 64
    "before Printing the player's obituary rulebook" ! 65
    "for Printing the player's obituary rulebook" ! 66
    "after Printing the player's obituary rulebook" ! 67
    "before Amusing a victorious player rulebook" ! 68
    "for Amusing a victorious player rulebook" ! 69
    "after Amusing a victorious player rulebook" ! 70
    "before Printing the banner text rulebook" ! 71
    "for Printing the banner text rulebook" ! 72
    "after Printing the banner text rulebook" ! 73
    "before Printing the plural name rulebook" ! 74
    "for Printing the plural name rulebook" ! 75
    "after Printing the plural name rulebook" ! 76
    "before Deciding the concealed possessions rulebook" ! 77
    "for Deciding the concealed possessions rulebook" ! 78
    "after Deciding the concealed possessions rulebook" ! 79
    "before Printing a refusal to act in the dark rulebook" ! 80
    "for Printing a refusal to act in the dark rulebook" ! 81
    "after Printing a refusal to act in the dark rulebook" ! 82
    "before Printing the announcement of darkness rulebook" ! 83
    "for Printing the announcement of darkness rulebook" ! 84
    "after Printing the announcement of darkness rulebook" ! 85
    "before Printing the name of a dark room rulebook" ! 86
    "for Printing the name of a dark room rulebook" ! 87
    "after Printing the name of a dark room rulebook" ! 88
    "before Printing the description of a dark room rulebook" ! 89
    "for Printing the description of a dark room rulebook" ! 90
    "after Printing the description of a dark room rulebook" ! 91
    "before Printing room description details rulebook" ! 92
    "for Printing room description details rulebook" ! 93
    "after Printing room description details rulebook" ! 94
    "before Printing a parser error rulebook" ! 95
    "for Printing a parser error rulebook" ! 96
    "after Printing a parser error rulebook" ! 97
    "before Implicitly taking rulebook" ! 98
    "for Implicitly taking rulebook" ! 99
    "after Implicitly taking rulebook" ! 100
    "before Starting the virtual machine rulebook" ! 101
    "for Starting the virtual machine rulebook" ! 102
    "after Starting the virtual machine rulebook" ! 103
    "before Clarifying the parser's choice rulebook" ! 104
    "for Clarifying the parser's choice rulebook" ! 105
    "after Clarifying the parser's choice rulebook" ! 106
    "before Asking which do you mean rulebook" ! 107
    "for Asking which do you mean rulebook" ! 108
    "after Asking which do you mean rulebook" ! 109
    "before Writing a paragraph about rulebook" ! 110
    "for Writing a paragraph about rulebook" ! 111
    "after Writing a paragraph about rulebook" ! 112
    "check Taking inventory rulebook" ! 113
    "carry out Taking inventory rulebook" ! 114
    "report Taking inventory rulebook" ! 115
    "check Taking rulebook" ! 116
    "carry out Taking rulebook" ! 117
    "report Taking rulebook" ! 118
    "check Removing it from rulebook" ! 119
    "carry out Removing it from rulebook" ! 120
    "report Removing it from rulebook" ! 121
    "check Dropping rulebook" ! 122
    "carry out Dropping rulebook" ! 123
    "report Dropping rulebook" ! 124
    "check Putting it on rulebook" ! 125
    "carry out Putting it on rulebook" ! 126
    "report Putting it on rulebook" ! 127
    "check Inserting it into rulebook" ! 128
    "carry out Inserting it into rulebook" ! 129
    "report Inserting it into rulebook" ! 130
    "check Eating rulebook" ! 131
    "carry out Eating rulebook" ! 132
    "report Eating rulebook" ! 133
    "check Going rulebook" ! 134
    "carry out Going rulebook" ! 135
    "report Going rulebook" ! 136
    "check Entering rulebook" ! 137
    "carry out Entering rulebook" ! 138
    "report Entering rulebook" ! 139
    "check Exiting rulebook" ! 140
    "carry out Exiting rulebook" ! 141
    "report Exiting rulebook" ! 142
    "check Getting off rulebook" ! 143
    "carry out Getting off rulebook" ! 144
    "report Getting off rulebook" ! 145
    "check Looking rulebook" ! 146
    "carry out Looking rulebook" ! 147
    "report Looking rulebook" ! 148
    "check Examining rulebook" ! 149
    "carry out Examining rulebook" ! 150
    "report Examining rulebook" ! 151
    "check Looking under rulebook" ! 152
    "carry out Looking under rulebook" ! 153
    "report Looking under rulebook" ! 154
    "check Searching rulebook" ! 155
    "carry out Searching rulebook" ! 156
    "report Searching rulebook" ! 157
    "check Consulting it about rulebook" ! 158
    "carry out Consulting it about rulebook" ! 159
    "report Consulting it about rulebook" ! 160
    "check Locking it with rulebook" ! 161
    "carry out Locking it with rulebook" ! 162
    "report Locking it with rulebook" ! 163
    "check Unlocking it with rulebook" ! 164
    "carry out Unlocking it with rulebook" ! 165
    "report Unlocking it with rulebook" ! 166
    "check Switching on rulebook" ! 167
    "carry out Switching on rulebook" ! 168
    "report Switching on rulebook" ! 169
    "check Switching off rulebook" ! 170
    "carry out Switching off rulebook" ! 171
    "report Switching off rulebook" ! 172
    "check Opening rulebook" ! 173
    "carry out Opening rulebook" ! 174
    "report Opening rulebook" ! 175
    "check Closing rulebook" ! 176
    "carry out Closing rulebook" ! 177
    "report Closing rulebook" ! 178
    "check Wearing rulebook" ! 179
    "carry out Wearing rulebook" ! 180
    "report Wearing rulebook" ! 181
    "check Taking off rulebook" ! 182
    "carry out Taking off rulebook" ! 183
    "report Taking off rulebook" ! 184
    "check Giving it to rulebook" ! 185
    "carry out Giving it to rulebook" ! 186
    "report Giving it to rulebook" ! 187
    "check Showing it to rulebook" ! 188
    "carry out Showing it to rulebook" ! 189
    "report Showing it to rulebook" ! 190
    "check Waking rulebook" ! 191
    "carry out Waking rulebook" ! 192
    "report Waking rulebook" ! 193
    "check Throwing it at rulebook" ! 194
    "carry out Throwing it at rulebook" ! 195
    "report Throwing it at rulebook" ! 196
    "check Attacking rulebook" ! 197
    "carry out Attacking rulebook" ! 198
    "report Attacking rulebook" ! 199
    "check Kissing rulebook" ! 200
    "carry out Kissing rulebook" ! 201
    "report Kissing rulebook" ! 202
    "check Answering it that rulebook" ! 203
    "carry out Answering it that rulebook" ! 204
    "report Answering it that rulebook" ! 205
    "check Telling it about rulebook" ! 206
    "carry out Telling it about rulebook" ! 207
    "report Telling it about rulebook" ! 208
    "check Asking it about rulebook" ! 209
    "carry out Asking it about rulebook" ! 210
    "report Asking it about rulebook" ! 211
    "check Asking it for rulebook" ! 212
    "carry out Asking it for rulebook" ! 213
    "report Asking it for rulebook" ! 214
    "check Waiting rulebook" ! 215
    "carry out Waiting rulebook" ! 216
    "report Waiting rulebook" ! 217
    "check Touching rulebook" ! 218
    "carry out Touching rulebook" ! 219
    "report Touching rulebook" ! 220
    "check Waving rulebook" ! 221
    "carry out Waving rulebook" ! 222
    "report Waving rulebook" ! 223
    "check Pulling rulebook" ! 224
    "carry out Pulling rulebook" ! 225
    "report Pulling rulebook" ! 226
    "check Pushing rulebook" ! 227
    "carry out Pushing rulebook" ! 228
    "report Pushing rulebook" ! 229
    "check Turning rulebook" ! 230
    "carry out Turning rulebook" ! 231
    "report Turning rulebook" ! 232
    "check Pushing it to rulebook" ! 233
    "carry out Pushing it to rulebook" ! 234
    "report Pushing it to rulebook" ! 235
    "check Squeezing rulebook" ! 236
    "carry out Squeezing rulebook" ! 237
    "report Squeezing rulebook" ! 238
    "check Saying yes rulebook" ! 239
    "carry out Saying yes rulebook" ! 240
    "report Saying yes rulebook" ! 241
    "check Saying no rulebook" ! 242
    "carry out Saying no rulebook" ! 243
    "report Saying no rulebook" ! 244
    "check Burning rulebook" ! 245
    "carry out Burning rulebook" ! 246
    "report Burning rulebook" ! 247
    "check Waking up rulebook" ! 248
    "carry out Waking up rulebook" ! 249
    "report Waking up rulebook" ! 250
    "check Thinking rulebook" ! 251
    "carry out Thinking rulebook" ! 252
    "report Thinking rulebook" ! 253
    "check Smelling rulebook" ! 254
    "carry out Smelling rulebook" ! 255
    "report Smelling rulebook" ! 256
    "check Listening to rulebook" ! 257
    "carry out Listening to rulebook" ! 258
    "report Listening to rulebook" ! 259
    "check Tasting rulebook" ! 260
    "carry out Tasting rulebook" ! 261
    "report Tasting rulebook" ! 262
    "check Cutting rulebook" ! 263
    "carry out Cutting rulebook" ! 264
    "report Cutting rulebook" ! 265
    "check Jumping rulebook" ! 266
    "carry out Jumping rulebook" ! 267
    "report Jumping rulebook" ! 268
    "check Tying it to rulebook" ! 269
    "carry out Tying it to rulebook" ! 270
    "report Tying it to rulebook" ! 271
    "check Drinking rulebook" ! 272
    "carry out Drinking rulebook" ! 273
    "report Drinking rulebook" ! 274
    "check Saying sorry rulebook" ! 275
    "carry out Saying sorry rulebook" ! 276
    "report Saying sorry rulebook" ! 277
    "check Swearing obscenely rulebook" ! 278
    "carry out Swearing obscenely rulebook" ! 279
    "report Swearing obscenely rulebook" ! 280
    "check Swearing mildly rulebook" ! 281
    "carry out Swearing mildly rulebook" ! 282
    "report Swearing mildly rulebook" ! 283
    "check Swinging rulebook" ! 284
    "carry out Swinging rulebook" ! 285
    "report Swinging rulebook" ! 286
    "check Rubbing rulebook" ! 287
    "carry out Rubbing rulebook" ! 288
    "report Rubbing rulebook" ! 289
    "check Setting it to rulebook" ! 290
    "carry out Setting it to rulebook" ! 291
    "report Setting it to rulebook" ! 292
    "check Waving hands rulebook" ! 293
    "carry out Waving hands rulebook" ! 294
    "report Waving hands rulebook" ! 295
    "check Buying rulebook" ! 296
    "carry out Buying rulebook" ! 297
    "report Buying rulebook" ! 298
    "check Singing rulebook" ! 299
    "carry out Singing rulebook" ! 300
    "report Singing rulebook" ! 301
    "check Climbing rulebook" ! 302
    "carry out Climbing rulebook" ! 303
    "report Climbing rulebook" ! 304
    "check Sleeping rulebook" ! 305
    "carry out Sleeping rulebook" ! 306
    "report Sleeping rulebook" ! 307
    "check Requesting the score rulebook" ! 308
    "carry out Requesting the score rulebook" ! 309
    "report Requesting the score rulebook" ! 310
    "check Quitting the game rulebook" ! 311
    "carry out Quitting the game rulebook" ! 312
    "report Quitting the game rulebook" ! 313
    "check Saving the game rulebook" ! 314
    "carry out Saving the game rulebook" ! 315
    "report Saving the game rulebook" ! 316
    "check Restoring the game rulebook" ! 317
    "carry out Restoring the game rulebook" ! 318
    "report Restoring the game rulebook" ! 319
    "check Restarting the game rulebook" ! 320
    "carry out Restarting the game rulebook" ! 321
    "report Restarting the game rulebook" ! 322
    "check Verifying the story file rulebook" ! 323
    "carry out Verifying the story file rulebook" ! 324
    "report Verifying the story file rulebook" ! 325
    "check Requesting the story file version rulebook" ! 326
    "carry out Requesting the story file version rulebook" ! 327
    "report Requesting the story file version rulebook" ! 328
    "check Switching the story transcript on rulebook" ! 329
    "carry out Switching the story transcript on rulebook" ! 330
    "report Switching the story transcript on rulebook" ! 331
    "check Switching the story transcript off rulebook" ! 332
    "carry out Switching the story transcript off rulebook" ! 333
    "report Switching the story transcript off rulebook" ! 334
    "check Preferring abbreviated room descriptions rulebook" ! 335
    "carry out Preferring abbreviated room descriptions rulebook" ! 336
    "report Preferring abbreviated room descriptions rulebook" ! 337
    "check Preferring unabbreviated room descriptions rulebook" ! 338
    "carry out Preferring unabbreviated room descriptions rulebook" ! 339
    "report Preferring unabbreviated room descriptions rulebook" ! 340
    "check Preferring sometimes abbreviated room descriptions rulebook" ! 341
    "carry out Preferring sometimes abbreviated room descriptions rulebook" ! 342
    "report Preferring sometimes abbreviated room descriptions rulebook" ! 343
    "check Requesting the pronoun meanings rulebook" ! 344
    "carry out Requesting the pronoun meanings rulebook" ! 345
    "report Requesting the pronoun meanings rulebook" ! 346
    "check Switching score notification on rulebook" ! 347
    "carry out Switching score notification on rulebook" ! 348
    "report Switching score notification on rulebook" ! 349
    "check Switching score notification off rulebook" ! 350
    "carry out Switching score notification off rulebook" ! 351
    "report Switching score notification off rulebook" ! 352
    "check Time-checking rulebook" ! 353
    "carry out Time-checking rulebook" ! 354
    "report Time-checking rulebook" ! 355
;


#ENDIF; ! I7_ECONOMY

[ I7_RulePrintingRule R p1;
#ifndef I7_ECONOMY;
	if ((R>=0) && (R<356)) {
		print (string) (RulebookNames-->R);
	} else {
		if (R == R_14) { print "very unlikely to mean taking what's already carried rule"; return; } ! 0, case 1
		if (R == R_23) { print "standard name printing rule"; return; } ! 1, case 1
		if (R == R_24) { print "standard contents listing rule"; return; } ! 2, case 1
		if (R == R_25) { print "make named things mentioned rule"; return; } ! 3, case 1
		if (R == R_26) { print "print empty inventory rule"; return; } ! 4, case 1
		if (R == R_27) { print "print standard inventory rule"; return; } ! 5, case 1
		if (R == R_28) { print "use inventory to set pronouns rule"; return; } ! 6, case 1
		if (R == R_29) { print "report other people taking inventory rule"; return; } ! 7, case 1
		if (R == R_30) { print "standard set taking variables rule"; return; } ! 8, case 1
		if (R == R_31) { print "avoid unnecessary implicit taking rule"; return; } ! 9, case 1
		if (R == R_32) { print "can't take yourself rule"; return; } ! 10, case 1
		if (R == R_33) { print "can't take other people rule"; return; } ! 11, case 1
		if (R == R_34) { print "can't take component parts rule"; return; } ! 12, case 1
		if (R == R_35) { print "can't take people's possessions rule"; return; } ! 13, case 1
		if (R == R_36) { print "can't take what you're inside rule"; return; } ! 14, case 1
		if (R == R_37) { print "can't take what's already taken rule"; return; } ! 15, case 1
		if (R == R_38) { print "can't take scenery rule"; return; } ! 16, case 1
		if (R == R_39) { print "can't take what's fixed in place rule"; return; } ! 17, case 1
		if (R == R_40) { print "use player's holdall to avoid exceeding carrying capacity rule"; return; } ! 18, case 1
		if (R == R_41) { print "can't exceed carrying capacity rule"; return; } ! 19, case 1
		if (R == R_42) { print "standard taking rule"; return; } ! 20, case 1
		if (R == R_43) { print "don't report successful implicit takes rule"; return; } ! 21, case 1
		if (R == R_44) { print "standard report taking rule"; return; } ! 22, case 1
		if (R == R_45) { print "can't remove what's not inside rule"; return; } ! 23, case 1
		if (R == R_46) { print "can't remove from people rule"; return; } ! 24, case 1
		if (R == R_47) { print "convert remove to take rule"; return; } ! 25, case 1
		if (R == R_48) { print "can't drop yourself rule"; return; } ! 26, case 1
		if (R == R_49) { print "can't drop what's already dropped rule"; return; } ! 27, case 1
		if (R == R_50) { print "can't drop what's not held rule"; return; } ! 28, case 1
		if (R == R_51) { print "can't drop clothes being worn rule"; return; } ! 29, case 1
		if (R == R_52) { print "can't drop if this exceeds carrying capacity rule"; return; } ! 30, case 1
		if (R == R_53) { print "standard dropping rule"; return; } ! 31, case 1
		if (R == R_54) { print "standard report dropping rule"; return; } ! 32, case 1
		if (R == R_55) { print "convert put to drop where possible rule"; return; } ! 33, case 1
		if (R == R_56) { print "can't put what's not held rule"; return; } ! 34, case 1
		if (R == R_57) { print "can't put something on itself rule"; return; } ! 35, case 1
		if (R == R_58) { print "can't put onto what's not a supporter rule"; return; } ! 36, case 1
		if (R == R_59) { print "can't put onto something being carried rule"; return; } ! 37, case 1
		if (R == R_60) { print "can't put clothes being worn rule"; return; } ! 38, case 1
		if (R == R_61) { print "can't put if this exceeds carrying capacity rule"; return; } ! 39, case 1
		if (R == R_62) { print "standard putting rule"; return; } ! 40, case 1
		if (R == R_63) { print "concise report putting rule"; return; } ! 41, case 1
		if (R == R_64) { print "standard report putting rule"; return; } ! 42, case 1
		if (R == R_65) { print "convert insert to drop where possible rule"; return; } ! 43, case 1
		if (R == R_66) { print "can't insert what's not held rule"; return; } ! 44, case 1
		if (R == R_67) { print "can't insert something into itself rule"; return; } ! 45, case 1
		if (R == R_68) { print "can't insert into closed containers rule"; return; } ! 46, case 1
		if (R == R_69) { print "can't insert into what's not a container rule"; return; } ! 47, case 1
		if (R == R_70) { print "can't insert clothes being worn rule"; return; } ! 48, case 1
		if (R == R_71) { print "can't insert if this exceeds carrying capacity rule"; return; } ! 49, case 1
		if (R == R_72) { print "standard inserting rule"; return; } ! 50, case 1
		if (R == R_73) { print "concise report inserting rule"; return; } ! 51, case 1
		if (R == R_74) { print "standard report inserting rule"; return; } ! 52, case 1
		if (R == R_75) { print "can't eat unless edible rule"; return; } ! 53, case 1
		if (R == R_76) { print "can't eat clothing without removing it first rule"; return; } ! 54, case 1
		if (R == R_77) { print "standard eating rule"; return; } ! 55, case 1
		if (R == R_78) { print "standard report eating rule"; return; } ! 56, case 1
		if (R == R_79) { print "standard set going variables rule"; return; } ! 57, case 1
		if (R == R_80) { print "can't travel in what's not a vehicle rule"; return; } ! 58, case 1
		if (R == R_81) { print "can't go through concealed doors rule"; return; } ! 59, case 1
		if (R == R_82) { print "can't go through closed doors rule"; return; } ! 60, case 1
		if (R == R_83) { print "determine map connection rule"; return; } ! 61, case 1
		if (R == R_84) { print "can't go that way rule"; return; } ! 62, case 1
		if (R == R_85) { print "move player and vehicle rule"; return; } ! 63, case 1
		if (R == R_86) { print "move floating objects rule"; return; } ! 64, case 1
		if (R == R_87) { print "check light in new location rule"; return; } ! 65, case 1
		if (R == R_88) { print "describe room gone into rule"; return; } ! 66, case 1
		if (R == R_89) { print "convert enter door into go rule"; return; } ! 67, case 1
		if (R == R_90) { print "convert enter compass direction into go rule"; return; } ! 68, case 1
		if (R == R_91) { print "can't enter what's already entered rule"; return; } ! 69, case 1
		if (R == R_92) { print "can't enter what's not enterable rule"; return; } ! 70, case 1
		if (R == R_93) { print "can't enter closed containers rule"; return; } ! 71, case 1
		if (R == R_94) { print "can't enter something carried rule"; return; } ! 72, case 1
		if (R == R_95) { print "implicitly pass through other barriers rule"; return; } ! 73, case 1
		if (R == R_96) { print "standard entering rule"; return; } ! 74, case 1
		if (R == R_97) { print "standard report entering rule"; return; } ! 75, case 1
		if (R == R_98) { print "describe contents entered into rule"; return; } ! 76, case 1
		if (R == R_100) { print "convert exit into go out rule"; return; } ! 77, case 1
		if (R == R_101) { print "can't exit when not inside anything rule"; return; } ! 78, case 1
		if (R == R_102) { print "can't exit closed containers rule"; return; } ! 79, case 1
		if (R == R_103) { print "convert exit into get off rule"; return; } ! 80, case 1
		if (R == R_104) { print "standard exiting rule"; return; } ! 81, case 1
		if (R == R_105) { print "standard report exiting rule"; return; } ! 82, case 1
		if (R == R_106) { print "describe room emerged into rule"; return; } ! 83, case 1
		if (R == R_107) { print "can't get off things rule"; return; } ! 84, case 1
		if (R == R_108) { print "standard getting off rule"; return; } ! 85, case 1
		if (R == R_109) { print "standard report getting off rule"; return; } ! 86, case 1
		if (R == R_110) { print "describe room stood up into rule"; return; } ! 87, case 1
		if (R == R_111) { print "determine visibility ceiling rule"; return; } ! 88, case 1
		if (R == R_112) { print "room description heading rule"; return; } ! 89, case 1
		if (R == R_113) { print "room description body text rule"; return; } ! 90, case 1
		if (R == R_114) { print "room description paragraphs about objects rule"; return; } ! 91, case 1
		if (R == R_115) { print "check new arrival rule"; return; } ! 92, case 1
		if (R == R_116) { print "other people looking rule"; return; } ! 93, case 1
		if (R == R_117) { print "examine undescribed containers rule"; return; } ! 94, case 1
		if (R == R_118) { print "examine undescribed devices rule"; return; } ! 95, case 1
		if (R == R_119) { print "examine undescribed things rule"; return; } ! 96, case 1
		if (R == R_120) { print "examine directions rule"; return; } ! 97, case 1
		if (R == R_121) { print "standard examining rule"; return; } ! 98, case 1
		if (R == R_122) { print "examine described devices rule"; return; } ! 99, case 1
		if (R == R_123) { print "report other people examining rule"; return; } ! 100, case 1
		if (R == R_124) { print "standard looking under rule"; return; } ! 101, case 1
		if (R == R_125) { print "report other people looking under rule"; return; } ! 102, case 1
		if (R == R_126) { print "can't search unless container or supporter rule"; return; } ! 103, case 1
		if (R == R_127) { print "can't search closed opaque containers rule"; return; } ! 104, case 1
		if (R == R_128) { print "standard search containers rule"; return; } ! 105, case 1
		if (R == R_129) { print "standard search supporters rule"; return; } ! 106, case 1
		if (R == R_130) { print "report other people searching rule"; return; } ! 107, case 1
		if (R == R_131) { print "block consulting rule"; return; } ! 108, case 1
		if (R == R_132) { print "can't lock without a lock rule"; return; } ! 109, case 1
		if (R == R_133) { print "can't lock what's already locked rule"; return; } ! 110, case 1
		if (R == R_134) { print "can't lock what's open rule"; return; } ! 111, case 1
		if (R == R_135) { print "can't lock without the correct key rule"; return; } ! 112, case 1
		if (R == R_136) { print "standard locking rule"; return; } ! 113, case 1
		if (R == R_137) { print "standard report locking rule"; return; } ! 114, case 1
		if (R == R_138) { print "can't unlock without a lock rule"; return; } ! 115, case 1
		if (R == R_139) { print "can't unlock what's already unlocked rule"; return; } ! 116, case 1
		if (R == R_140) { print "can't unlock without the correct key rule"; return; } ! 117, case 1
		if (R == R_141) { print "standard unlocking rule"; return; } ! 118, case 1
		if (R == R_142) { print "standard report unlocking rule"; return; } ! 119, case 1
		if (R == R_143) { print "can't switch on unless switchable rule"; return; } ! 120, case 1
		if (R == R_144) { print "can't switch on what's already on rule"; return; } ! 121, case 1
		if (R == R_145) { print "standard switching on rule"; return; } ! 122, case 1
		if (R == R_146) { print "standard report switching on rule"; return; } ! 123, case 1
		if (R == R_147) { print "can't switch off unless switchable rule"; return; } ! 124, case 1
		if (R == R_148) { print "can't switch off what's already off rule"; return; } ! 125, case 1
		if (R == R_149) { print "standard switching off rule"; return; } ! 126, case 1
		if (R == R_150) { print "standard report switching off rule"; return; } ! 127, case 1
		if (R == R_151) { print "can't open unless openable rule"; return; } ! 128, case 1
		if (R == R_152) { print "can't open what's locked rule"; return; } ! 129, case 1
		if (R == R_153) { print "can't open what's already open rule"; return; } ! 130, case 1
		if (R == R_154) { print "standard opening rule"; return; } ! 131, case 1
		if (R == R_155) { print "reveal any newly visible interior rule"; return; } ! 132, case 1
		if (R == R_156) { print "standard report opening rule"; return; } ! 133, case 1
		if (R == R_157) { print "can't close unless openable rule"; return; } ! 134, case 1
		if (R == R_158) { print "can't close what's already closed rule"; return; } ! 135, case 1
		if (R == R_159) { print "standard closing rule"; return; } ! 136, case 1
		if (R == R_160) { print "standard report closing rule"; return; } ! 137, case 1
		if (R == R_161) { print "can't wear what's not clothing rule"; return; } ! 138, case 1
		if (R == R_162) { print "can't wear what's not held rule"; return; } ! 139, case 1
		if (R == R_163) { print "can't wear what's already worn rule"; return; } ! 140, case 1
		if (R == R_164) { print "standard wearing rule"; return; } ! 141, case 1
		if (R == R_165) { print "standard report wearing rule"; return; } ! 142, case 1
		if (R == R_166) { print "can't take off what's not worn rule"; return; } ! 143, case 1
		if (R == R_167) { print "standard taking off rule"; return; } ! 144, case 1
		if (R == R_168) { print "standard report taking off rule"; return; } ! 145, case 1
		if (R == R_169) { print "can't give what you haven't got rule"; return; } ! 146, case 1
		if (R == R_170) { print "can't give to yourself rule"; return; } ! 147, case 1
		if (R == R_171) { print "can't give to a non-person rule"; return; } ! 148, case 1
		if (R == R_172) { print "block giving rule"; return; } ! 149, case 1
		if (R == R_173) { print "standard giving rule"; return; } ! 150, case 1
		if (R == R_174) { print "standard report giving rule"; return; } ! 151, case 1
		if (R == R_175) { print "can't show what you haven't got rule"; return; } ! 152, case 1
		if (R == R_176) { print "convert show to yourself to examine rule"; return; } ! 153, case 1
		if (R == R_177) { print "block showing rule"; return; } ! 154, case 1
		if (R == R_178) { print "block waking rule"; return; } ! 155, case 1
		if (R == R_179) { print "implicitly remove thrown clothing rule"; return; } ! 156, case 1
		if (R == R_180) { print "futile to throw things at inanimate objects rule"; return; } ! 157, case 1
		if (R == R_181) { print "block throwing at rule"; return; } ! 158, case 1
		if (R == R_182) { print "block attacking rule"; return; } ! 159, case 1
		if (R == R_183) { print "kissing yourself rule"; return; } ! 160, case 1
		if (R == R_184) { print "block kissing rule"; return; } ! 161, case 1
		if (R == R_185) { print "block answering rule"; return; } ! 162, case 1
		if (R == R_186) { print "telling yourself rule"; return; } ! 163, case 1
		if (R == R_187) { print "block telling rule"; return; } ! 164, case 1
		if (R == R_188) { print "block asking rule"; return; } ! 165, case 1
		if (R == R_189) { print "asking yourself for something rule"; return; } ! 166, case 1
		if (R == R_190) { print "translate asking for to giving rule"; return; } ! 167, case 1
		if (R == R_191) { print "standard report waiting rule"; return; } ! 168, case 1
		if (R == R_192) { print "report touching yourself rule"; return; } ! 169, case 1
		if (R == R_193) { print "report touching other people rule"; return; } ! 170, case 1
		if (R == R_194) { print "report touching things rule"; return; } ! 171, case 1
		if (R == R_195) { print "can't wave what's not held rule"; return; } ! 172, case 1
		if (R == R_196) { print "report waving things rule"; return; } ! 173, case 1
		if (R == R_197) { print "can't pull what's fixed in place rule"; return; } ! 174, case 1
		if (R == R_198) { print "can't pull scenery rule"; return; } ! 175, case 1
		if (R == R_199) { print "can't pull people rule"; return; } ! 176, case 1
		if (R == R_200) { print "report pulling rule"; return; } ! 177, case 1
		if (R == R_201) { print "can't push what's fixed in place rule"; return; } ! 178, case 1
		if (R == R_202) { print "can't push scenery rule"; return; } ! 179, case 1
		if (R == R_203) { print "can't push people rule"; return; } ! 180, case 1
		if (R == R_204) { print "report pushing rule"; return; } ! 181, case 1
		if (R == R_205) { print "can't turn what's fixed in place rule"; return; } ! 182, case 1
		if (R == R_206) { print "can't turn scenery rule"; return; } ! 183, case 1
		if (R == R_207) { print "can't turn people rule"; return; } ! 184, case 1
		if (R == R_208) { print "report turning rule"; return; } ! 185, case 1
		if (R == R_209) { print "block pushing in directions rule"; return; } ! 186, case 1
		if (R == R_210) { print "innuendo about squeezing people rule"; return; } ! 187, case 1
		if (R == R_211) { print "report squeezing rule"; return; } ! 188, case 1
		if (R == R_212) { print "block saying yes rule"; return; } ! 189, case 1
		if (R == R_213) { print "block saying no rule"; return; } ! 190, case 1
		if (R == R_214) { print "block burning rule"; return; } ! 191, case 1
		if (R == R_215) { print "block waking up rule"; return; } ! 192, case 1
		if (R == R_216) { print "block thinking rule"; return; } ! 193, case 1
		if (R == R_217) { print "block smelling rule"; return; } ! 194, case 1
		if (R == R_218) { print "block listening rule"; return; } ! 195, case 1
		if (R == R_219) { print "block tasting rule"; return; } ! 196, case 1
		if (R == R_220) { print "block cutting rule"; return; } ! 197, case 1
		if (R == R_221) { print "block jumping rule"; return; } ! 198, case 1
		if (R == R_222) { print "block tying rule"; return; } ! 199, case 1
		if (R == R_223) { print "block drinking rule"; return; } ! 200, case 1
		if (R == R_224) { print "block saying sorry rule"; return; } ! 201, case 1
		if (R == R_225) { print "block swearing obscenely rule"; return; } ! 202, case 1
		if (R == R_226) { print "block swearing mildly rule"; return; } ! 203, case 1
		if (R == R_227) { print "block swinging rule"; return; } ! 204, case 1
		if (R == R_228) { print "block rubbing rule"; return; } ! 205, case 1
		if (R == R_229) { print "block setting it to rule"; return; } ! 206, case 1
		if (R == R_230) { print "block waving hands rule"; return; } ! 207, case 1
		if (R == R_231) { print "block buying rule"; return; } ! 208, case 1
		if (R == R_232) { print "block singing rule"; return; } ! 209, case 1
		if (R == R_233) { print "block climbing rule"; return; } ! 210, case 1
		if (R == R_234) { print "block sleeping rule"; return; } ! 211, case 1
		if (R == R_235) { print "ambient odour rule"; return; } ! 212, case 1
		if (R == R_236) { print "ambient sound rule"; return; } ! 213, case 1
		if (R == R_237) { print "block vaguely going rule"; return; } ! 214, case 1
		if (R == ScoreSub_O1) { print "announce the score rule"; return; } ! 526, case 1
		if (R == QuitSub_O1) { print "quit the game rule"; return; } ! 530, case 1
		if (R == SaveSub_O1) { print "save the game rule"; return; } ! 534, case 1
		if (R == RestoreSub_O1) { print "restore the game rule"; return; } ! 538, case 1
		if (R == RestartSub_O1) { print "restart the game rule"; return; } ! 542, case 1
		if (R == VerifySub_O1) { print "verify the story file rule"; return; } ! 546, case 1
		if (R == VersionSub_O1) { print "announce the story file version rule"; return; } ! 550, case 1
		if (R == ScriptOnSub_O1) { print "switch the story transcript on rule"; return; } ! 554, case 1
		if (R == ScriptOffSub_O1) { print "switch the story transcript off rule"; return; } ! 558, case 1
		if (R == LMode3Sub_O1) { print "prefer abbreviated room descriptions rule"; return; } ! 562, case 1
		if (R == LMode2Sub_O1) { print "prefer unabbreviated room descriptions rule"; return; } ! 566, case 1
		if (R == LMode1Sub_O1) { print "prefer sometimes abbreviated room descriptions rule"; return; } ! 570, case 1
		if (R == PronounsSub_O1) { print "announce the pronoun meanings rule"; return; } ! 574, case 1
		if (R == NotifyOnSub_O1) { print "switch score notification on rule"; return; } ! 578, case 1
		if (R == NotifyOffSub_O1) { print "switch score notification off rule"; return; } ! 582, case 1
		if (R == I7_DO_NOTHING) { print "little-used do nothing rule"; return; } ! 586, case 1
		if (R == TS1_R) { print "advance time rule"; return; } ! 587, case 1
		if (R == TS4_R) { print "update chronological records rule"; return; } ! 588, case 1
		if (R == TS5_R) { print "adjust light rule"; return; } ! 589, case 1
		if (R == TS6_R) { print "note object acquisitions rule"; return; } ! 590, case 1
		if (R == ProcessI7Timers) { print "timed events rule"; return; } ! 591, case 1
		if (R == I7ResetChooseObjects) { print "reset parser disambiguation rule"; return; } ! 592, case 1
		if (R == I7_NPCA) { print "non-player character action rule"; return; } ! 593, case 1
		if (R == OIU_Scoped) { print "access to scoped objects rule"; return; } ! 594, case 1
		if (R == OIU_Barrier) { print "access through barriers rule"; return; } ! 595, case 1
		if (R == OIUB_CCI) { print "can't reach inside closed containers rule"; return; } ! 596, case 1
		if (R == OIUB_CCO) { print "can't reach outside closed containers rule"; return; } ! 597, case 1
		if (R == OIUB_RI) { print "can't reach inside rooms rule"; return; } ! 598, case 1
		if (R == PA_R) { print "basic accessibility rule"; return; } ! 599, case 1
		if (R == CR_R) { print "carrying requirements rule"; return; } ! 600, case 1
		if (R == CSITDR) { print "can't act in the dark rule"; return; } ! 601, case 1
		if (R == OBIT_HEAD) { print "print obituary headline rule"; return; } ! 602, case 1
		if (R == OBIT_FINAL) { print "print final score rule"; return; } ! 603, case 1
		if (R == OBIT_DISP) { print "display final status line rule"; return; } ! 604, case 1
		if (R == R_9) { print "first when play begins rule"; return; } ! 605, case 2
		if (R == R_10) { print "A first turn sequence rule"; return; } ! 606, case 2
		if (R == R_11) { print "A first turn sequence rule"; return; } ! 607, case 2
		if (R == R_12) { print "A last turn sequence rule"; return; } ! 608, case 2
		if (R == R_13) { print "last scene changing rule"; return; } ! 609, case 2
		if (R == R_15) { print "last before rule"; return; } ! 610, case 2
		if (R == R_16) { print "first after rule"; return; } ! 611, case 2
		if (R == R_17) { print "first action-processing rule"; return; } ! 612, case 2
		if (R == R_18) { print "A last action-processing rule"; return; } ! 613, case 2
		if (R == R_19) { print "A last action-processing rule"; return; } ! 614, case 2
		if (R == R_20) { print "A last action-processing rule"; return; } ! 615, case 2
		if (R == R_21) { print "A last action-processing rule"; return; } ! 616, case 2
		if (R == R_22) { print "last action-specific rule"; return; } ! 617, case 2
		if (R == R_99) { print "Setting action variables for exiting"; return; } ! 618, case 2
		if (R == R_550) { print "When play begins"; return; } ! 619, case 2
		if (R == R_551) { print "When play begins"; return; } ! 620, case 2
		if (R == R_552) { print "Rule for deciding the concealed possessions of player"; return; } ! 621, case 2
		if (R == R_553) { print "Carry out time-checking"; return; } ! 622, case 2
		if (R == R_554) { print "Every turn when a random chance of 1 in 20 succeeds"; return; } ! 623, case 2
		if (R == I7ResetChooseObjects) { print "reset parser disambiguation rule"; return; } ! 624, case 1
		if (R == ProcessI7Timers) { print "timed events rule"; return; } ! 625, case 1
		if (R == TS1_R) { print "advance time rule"; return; } ! 626, case 1
		if (R == TS4_R) { print "update chronological records rule"; return; } ! 627, case 1
		if (R == TS5_R) { print "adjust light rule"; return; } ! 628, case 1
		if (R == TS6_R) { print "note object acquisitions rule"; return; } ! 629, case 1
		if (R == OIU_Scoped) { print "access to scoped objects rule"; return; } ! 630, case 1
		if (R == OIU_Barrier) { print "access through barriers rule"; return; } ! 631, case 1
		if (R == OIUB_RI) { print "can't reach inside rooms rule"; return; } ! 632, case 1
		if (R == OIUB_CCI) { print "can't reach inside closed containers rule"; return; } ! 633, case 1
		if (R == OIUB_CCO) { print "can't reach outside closed containers rule"; return; } ! 634, case 1
		if (R == CSITDR) { print "can't act in the dark rule"; return; } ! 635, case 1
		if (R == PA_R) { print "basic accessibility rule"; return; } ! 636, case 1
		if (R == CR_R) { print "carrying requirements rule"; return; } ! 637, case 1
		if (R == OBIT_HEAD) { print "print obituary headline rule"; return; } ! 638, case 1
		if (R == OBIT_FINAL) { print "print final score rule"; return; } ! 639, case 1
		if (R == OBIT_DISP) { print "display final status line rule"; return; } ! 640, case 1
		if (R == R_34) { print "can't take component parts rule"; return; } ! 641, case 1

		print "(nameless rule at address ", R, ")";
	}
#ifnot;
	if ((R>=0) && (R<356)) {
		print "(rulebook ", R, ")";
	} else {
		print "(rule at address ", R, ")";
	}
#endif;
];

[ DebugRulebooks subs par i;
	spaces(2*process_rulebook_count);
	print "[", (I7_RulePrintingRule) subs;
	if (par) print " / on O", par;
	print "]^";
];

! (vii) Used from calls compiled in to NI-generated rules, printing a trace
! of which rules are executed:

[ DB_Rule R blocked;
	if (R==0) return;
	print "@31[Rule ~", (I7_RulePrintingRule) R, "~ ";
	if (blocked == false) "applies.]";
	"does not apply.]";
];

! (viii) This the default value for the kind of value 'rule':

[ I7_DO_NOTHING; rfalse; ];

! End of Rulebooks.i6

! Actions.i6

[ _I6_ActionPrimitive;
	#ifdef TARGET_ZCODE;
	indirect(#actions_table-->action);
	#ifnot;
	indirect(#actions_table-->(action+1));
	#endif;
];

[ BeginActionProcessing;
	BeginFollowRulebook();
];
[ EndActionProcessing;
	EndFollowRulebook();
];

[ TestActionBitmap obj act i j k bitmap;
	if (obj == nothing) bitmap = ActionHappened;
	else {
		if (~~(obj provides action_bitmap)) rfalse;
		bitmap = obj.&action_bitmap;
	}
	for (i=0, k=1; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			return (((bitmap->j) & k) ~= 0);
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
	rfalse;
];
[ SetActionBitmap obj act i j k bitmap;
	for (i=0, k=1; i<ActionCount; i++) {
		if (act == ActionCoding-->i) {
			if (obj provides action_bitmap) {
				bitmap = obj.&action_bitmap;
				bitmap->0 = (bitmap->0) | 1;
				bitmap->j = (bitmap->j) | k;
			}
			ActionHappened->0 = (ActionHappened->0) | 1;
			ActionHappened->j = (ActionHappened->j) | k;
		}
		k = k*2; if (k == 256) { k = 1; j++; }
	}
];

Global trace_actions = 0;
[ ActionsOnSub; trace_actions = 1; "Actions listing on."; ];
[ ActionsOffSub; trace_actions = 0; "Actions listing off."; ];
[ ActionPrimitive sa sn rv p1 p2 p3 p4 p5 frame_id; ! 
	sa = action; sn = noun;
	self = noun;

	MStack_CreateRBVars(APROC_RB);

	if ((keep_silent == false) && (multiflag == false)) I7_DivideParagraph();
	I7_action_deciding_rule = 0;

	if (action == ##Consult or ##Ask or ##Tell or ##NotUnderstood or ##Answer) {
		inp2 = 1; second = consult_from + 256*consult_words;
		parsed_number = 100*consult_from + consult_words;
	}

	frame_id = -1;
	p1 = FindAction(action);
	if ((p1) && (ActionData-->(p1+9))) {
		frame_id = ActionData-->(p1+10);
		Mstack_Create_Frame(ActionData-->(p1+9), frame_id);
	}
	if (I7_VerifyNouns()) {
		if ((p1) && (ActionData-->(p1+9)))
			Mstack_Destroy_Frame(frame_id);
		MStack_DestroyRBVars(APROC_RB);
		return;
	}

	ProcessRulebook(SETACTIONVARS_RB);

	#IFDEF DEBUG;
	if ((trace_actions) && (FindAction(-1))) {
		print "["; p1=actor; p2=act_requester; p3=action; p4=noun; p5=second;
		DB_Action(p1,p2,p3,p4,p5);
		print "]^";
	}
	SetString31(++debug_rule_nesting);
	#ENDIF;
	TrackActions();
	BeginActionProcessing();
	if (meta) { _I6_ActionPrimitive(); say__p = 1; }
	else ProcessRulebook(APROC_RB);
	rv = rulechange_stack-->rulechange_sp;
	#IFDEF DEBUG;
	SetString31(--debug_rule_nesting);
	if ((trace_actions) && (FindAction(-1))) {
		print "["; DB_Action(p1,p2,p3,p4,p5); print " - ";
		switch (rv) {
			RS_SUCCEEDS: print "succeeded";
			RS_FAILS: print "failed";
				#IFNDEF I7_ECONOMY;
				if (I7_action_deciding_rule)
					print " the ",
						(I7_RulePrintingRule) I7_action_deciding_rule;
			    #ENDIF;
			default: print "ended without result";
		}
		print "]^";
		rulechange_stack-->rulechange_sp = rv; ! In case disturbed by activities
	}
	#ENDIF;
	if (rv == RS_SUCCEEDS) {
		SetActionBitmap(noun, action);
		if (action == ##Go) SetActionBitmap(location, ##Enter);
	}
	EndActionProcessing();
	if (frame_id ~= -1) Mstack_Destroy_Frame(frame_id);
	MStack_DestroyRBVars(APROC_RB);
	action = sa; noun = sn;
	TrackActions(1);
	if ((keep_silent == false) && (multiflag == false)) I7_DivideParagraph();
	if (rv == RS_SUCCEEDS) rtrue;
	rfalse;
];

[ DA_Name n; print (name) n; ];
[ DA_Topic ignore a b c d i;
	print "~";
	for (a=consult_from:d<consult_words:d++,a++) {
		wn = a; b = WordAddress(a); c = WordLength(a);
		for (i=b:i<b+c:i++) {
			print (char) 0->i;
		}
		if (d<consult_words-1) print " ";
	}
	print "~";
];
[ DA_Number n; print n; ];
[ FindAction fa t;
	if (fa == -1) fa = action;
	t = 1;
	while (t <= ActionData-->0) {
		if (fa == ActionData-->t) return t;
		t = t+11;
	}
	rfalse;
];
[ DB_Action ac acr act n s t l j v c;
	if (debug_rule_nesting > 0) print "(", debug_rule_nesting, ") ";
	if (ac ~= player) {
		if (acr) print "asking ", (the) ac, " to try ";
		else print (the) ac, " trying ";
	}
	t = 1;
	while (t <= ActionData-->0) {
		if (act == ActionData-->t) {
			l = t+9; t = t+4;
			while ((v = ActionData-->t) ~= I6_NULL) {
					if (v ofclass Routine) {
					  if (c==0) { (v)(n); }
					  else { (v)(s); }
					  c++;
					} else print (string) v;
					t++;
					if (t == l) break;
					if (ActionData-->t ~= I6_NULL) print " ";
			}
			if (keep_silent) print " - silently";
			return;
		}
		t = t+11;
	}
];
[ I7_TryAction req by ac n s;
	@push actor; @push act_requester; @push inp1; @push inp2; @push parsed_number;
	actor = by; if (req) act_requester = player; else act_requester = 0;
!  print inp1, inp2, "^";
	by = FindAction(ac);
	if (by) {
		if (ActionData-->(by+2) == I7_OBJECT_TY) inp1 = n;
		else { inp1 = 1; parsed_number = n; }
		if (ActionData-->(by+3) == I7_OBJECT_TY) inp2 = s;
		else { inp2 = 1; parsed_number = s; }
	}
!  print "Made by ITA: ", inp1, inp2, "^";
	InformLibrary.begin_action(ac, n, s);
!  <(ac) n s>;
!  print inp1, inp2, "^";
	@pull parsed_number; @pull inp2; @pull inp1; @pull act_requester; @pull actor;
	TrackActions(1);
];

[ I7_NPCA s;
	if ((actor == player) || (act_requester == nothing)) rfalse;
	s = say__p; say__p = FALSE; ProcessRulebook(PERSUADE_RB);
	if (rulechange_stack-->rulechange_sp ~= RS_SUCCEEDS) {
		if (say__p == FALSE) L__M(##Order, 1, actor);
		RulebookFails(); rtrue;
	}
	say__p = s; rfalse;
];

[ I7_VerifyNouns mask noun_subtype second_subtype at;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+1); noun_subtype = ActionData-->(at+2);
!print "at = ", at, " nst = ", noun_subtype, "^";
!print "consult_from = ", consult_from, " consult_words = ", consult_from, "^";
!print "inp1 = ", inp1, " noun = ", noun, "^";
!print "inp2 = ", inp2, " second = ", second, "^";
	if (mask & $$100000) { meta = 1; rfalse; }
	second_subtype = ActionData-->(at+3);
!print "sst = ", second_subtype, "^";
	if (noun_subtype == 57 or 73) {
	    if (inp1 ~= 1) { inp2 = inp1; second = noun; }
	    parsed_number = 100*consult_from + consult_words;
	    inp1 = 1; noun = consult_from + 256*consult_words;
	}
	if (second_subtype == 57 or 73) {
	    parsed_number = 100*consult_from + consult_words;
	    inp2 = 1; second = consult_from + 256*consult_words;
	}
	if (inp1 == 1) {
	    if (noun_subtype == 58) {
	        "You must name an object.^"; }
	} else {
	    if (noun_subtype ~= 58) {
	        "You may not name an object.^"; }
	    if ((mask & $$01000) && (noun == nothing)) {
	        CarryOutActivity(6); if (noun == nothing) {
	        if (say__p) rtrue;
	        "You must supply a noun.^"; } }
	    if (((mask & $$01000) == 0) && (noun ~= nothing)) {
	        "You may not supply a noun.^"; }
	}
	if (inp2 == 1) {
	    if (second_subtype == 58) {
	        "You must name an object.^"; }
	} else {
	    if (second_subtype ~= 58) {
	        "You may not name a second object.^"; }
	    if ((mask & $$10000) && (second == nothing)) {
	        CarryOutActivity(7); if (second == nothing) {
	        if (say__p) rtrue;
	        "You must supply a second noun.^"; } }
	    if (((mask & $$10000) == 0) && (second ~= nothing)) {
	        "You may not supply a second noun.^"; }
	}
	rfalse;
];

[ I7_TestActionMask match mask at; 
	at = FindAction(-1); 
	if (at == 0) rfalse; 
	mask = ActionData-->(at+1); 
	if (mask & match) rtrue; 
	rfalse; 
];
[ I7_NeedToCarryNoun; return I7_TestActionMask($$01000000); ];
[ I7_NeedToCarrySecondNoun; return I7_TestActionMask($$10000000); ];
[ I7_NeedToTouchNoun; return I7_TestActionMask($$00001); ];
[ I7_NeedToTouchSecondNoun; return I7_TestActionMask($$00010); ];
[ I7_NeedLightForAction; return I7_TestActionMask($$00100); ];

[ I7_ImplicitTake obj ks;
	ks = keep_silent; keep_silent = true;
	print "(";
	if (actor ~= player) print (the) actor, " ";
	print "first taking ", (the) obj, ")^"; say__p = 0;
	I7_TryAction(true, actor, ##Take, obj, nothing);
	keep_silent = ks;
	if (obj in actor) rtrue;
	rfalse;
];

! The can't see in the dark rule

[ CSITDR; if (location == thedark) { RulebookSucceeds(); rtrue; } rfalse; ];

! The primitive accessibility rule

[ PA_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+1);

	! print "actor = ", (the) actor, "inp1 = ", inp1, "; inp2 = ", inp2, "^";
	! print "Mask is ", mask, "^";

	if ((mask & $$00100) &&
		(actor == player) &&
		(ProcessRulebook(VISIBLE_RB)) &&
		((rulechange_stack-->rulechange_sp == RS_SUCCEEDS))) {
		BeginActivity(TOODARK_ACT);
		if (ForActivity(TOODARK_ACT)==false) L__M(##Miscellany, 17);
		EndActivity(TOODARK_ACT);
		I7_action_deciding_rule = CSITDR;
		RulebookFails();
		rtrue;
	}

	if ((mask & $$00001) && noun && (inp1 ~= 1)) {
		if (noun in compass) {
			RulebookFails();
			I7_action_deciding_rule = PA_R; 
			if (actor~=player) rtrue;
			"You must name something more substantial.^";
		}
		if (ObjectIsUntouchable(noun, (actor~=player), FALSE, actor)) {
			RulebookFails();
			I7_action_deciding_rule = PA_R;
			rtrue;
		}
	}

	if ((mask & $$00010) && second && (inp2 ~= 1)) {
		if (second in compass) {
			RulebookFails();
			I7_action_deciding_rule = PA_R;
			if (actor~=player) rtrue;
			"You must name something more substantial.^";
		}
		if (ObjectIsUntouchable(second, (actor~=player), FALSE, actor)) {
			RulebookFails();
			I7_action_deciding_rule = PA_R;
			rtrue;
		}
	}
	rfalse;
];

[ CR_R mask at;
	if (act_requester) rfalse;
	at = FindAction(-1);
	if (at == 0) rfalse;
	mask = ActionData-->(at+1);

	if ((mask & $$00001) && noun && (inp1 ~= 1)) {
		if ((mask & $$01000000) && (noun notin actor)) {
			BeginActivity(IMPLICITTAKE_ACT, noun);
            if (ForActivity(IMPLICITTAKE_ACT, noun)==false)
            	I7_ImplicitTake(noun);
            EndActivity(IMPLICITTAKE_ACT, noun);
			if (noun notin actor) {
				RulebookFails();
				I7_action_deciding_rule = CR_R;
				rtrue;
			}
		}
	}

	if ((mask & $$00010) && second && (inp2 ~= 1)) {
		if ((mask & $$10000000) && (second notin actor)) {
			BeginActivity(IMPLICITTAKE_ACT, second);
            if (ForActivity(IMPLICITTAKE_ACT, second)==false)
            	I7_ImplicitTake(second);
            EndActivity(IMPLICITTAKE_ACT, second);
			if (second notin actor) {
				RulebookFails();
				I7_action_deciding_rule = CR_R;
				rtrue;
			}
		}
	}
	rfalse;
];

[ I7_SnippetMatches snip top;
	wn=1;
	if (top == 0) rfalse;
	if (metaclass(top) == Routine) {
		if ((top)(snip/100, snip%100)~=GPR_FAIL) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_BADTOPIC);
	rfalse;
];

! End of Actions.i6

! Activities.i6 segment

Global activities_sp = 0;
Array activities_stack --> 25;
Array activities_ostack --> 25;
Global inhibit_flag = 0;
Global inhibit_dr = 0;
[ FixInhibitFlag n i_f;
	for (n=0:n<activities_sp:n++)
		if (activities_stack-->n <= 4) i_f = true;
	if ((inhibit_flag == false) && (i_f)) {
		inhibit_dr = debug_rules;
		debug_rules = 0;
	}
	if ((inhibit_flag) && (i_f == false)) {
		debug_rules = inhibit_dr;
	}
	inhibit_flag = i_f;
];
[ BeginActivity A o x;
!	print "Begin ", A, "^";
	if (activities_sp == 25) return RunTimeProblem(RTP_TOOMANYACTS);
	activities_ostack-->activities_sp = o;
	activities_stack-->(activities_sp++) = A;
	FixInhibitFlag();
	MStack_CreateAVVars(A);
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = FollowRulebookSelfed(Activity_before_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];
[ ForActivity A o x;
!	print "For ", A, "^";
	if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
	o = FollowRulebookSelfed(Activity_when_rulebooks-->A, o);
	if (Activity_atb_rulebooks->A) action = x;
	return o;
];
[ EndActivity A o rv x;
!	print "End ", A, "^";
	if (activities_sp == 0) jump BadEnd;
	if (activities_stack-->(activities_sp-1) == A) {
		if (Activity_atb_rulebooks->A) { x = action; action = action_to_be; }
		rv = FollowRulebookSelfed(Activity_after_rulebooks-->A, o);
		if (Activity_atb_rulebooks->A) action = x;
		activities_sp--; FixInhibitFlag();
!		print "Ended^";
		MStack_DestroyAVVars(A);
		return rv;
	}
	.BadEnd; return RunTimeProblem(RTP_CANTABANDON);
];
[ AbandonActivity A o;
	if (activities_sp == 0) jump BadEnd;
	if (activities_stack-->(activities_sp-1) == A) {
		activities_sp--; FixInhibitFlag();
		MStack_DestroyAVVars(A);
		return;
	}
	.BadEnd; return RunTimeProblem(RTP_CANTEND);
];
[ CarryOutActivity A o rv;
	BeginActivity(A,o); rv = ForActivity(A,o); EndActivity(A,o); return rv; ];
[ TestActivity A Pattern i;
	for (i=0:i<activities_sp:i++)
		if (activities_stack-->i == A) {
			if (Pattern == false) rtrue;
			if ((Pattern)(activities_ostack-->i)) rtrue;
		}
	rfalse;
];
[ I7_Amusing_Provided x;
	x = Activity_when_rulebooks-->AMUSING_ACT;
	if (((rulebooks_array-->x)-->0) == I6_NULL)
		rfalse;
	rtrue;
];

[ I7SpotPluralWord at n i w swn outcome;
	swn = wn; wn = at;
	for (i=0:i<n:i++) {
		w = NextWordStopped();
		if (w == 0 or THEN1__WD or COMMA_WORD or -1) break;
		! print "I: ", i, " ", w->#dict_par1, "^";
		if ((w->#dict_par1) & $$00000100) {
			parser_action = ##PluralFound;
			outcome = true;
		}
	}
	wn = swn;
	return outcome;
];

! End of Activities.i6

! Relations.i6 segment

[ I7_Now1to1 obj1 rel obj2 ol;
	if (obj2) objectloop (ol provides rel)
		if (ol.rel == obj2) ol.rel = nothing;
	if (obj1) obj1.rel = obj2;
];
[ I7_NowN1toV obj1 rel obj2;
	if (obj1.rel == obj2) obj1.rel = nothing;
];
[ I7_NowS1to1 obj1 rel obj2 ol;
	if (obj1 ofclass Object && obj2 ofclass Object &&
		obj1 provides rel && obj2 provides rel) {
		if (obj1.rel) { (obj1.rel).rel = 0; }
		if (obj2.rel) { (obj2.rel).rel = 0; }
		obj1.rel = obj2; obj2.rel = obj1;
	}
];
[ I7_NowSN1to1 obj1 rel obj2 ol;
	if (obj1 ofclass Object && obj2 ofclass Object &&
		obj1 provides rel && obj2 provides rel) {
		if (obj1.rel == obj2) { obj1.rel = 0; obj2.rel = 0; }
	}
];
[ I7_NowVtoV obj1 bp_id obj2 sym pr pr2 i1 i2;
!  I7_ShowVtoV(bp_id);
	if (sym && (obj2 ~= obj1)) { I7_NowVtoV(obj2, bp_id, obj1, false); }
	pr = bp_id-->0;
	pr2 = bp_id-->1;
	if (pr) {
		if ((obj1 ofclass Object) && pr && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, bp_id, 0);
	} else i1 = obj1-1;
	if (pr2) {
 	 if ((obj2 ofclass Object) && pr2 && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, bp_id, 0);
	} else i2 = obj2-1;
!  print "Setting relation", "(", i1, ",", i2, ")^";
	pr = i1*(bp_id-->3) + i2; i1 = 1; i2 = pr%16; while (i2) { i2--; i1=i1*2; }
	pr = pr/16 + 6;
	bp_id-->pr = (bp_id-->pr) | i1;
];
[ I7_NowNVtoV obj1 bp_id obj2 sym pr pr2 i1 i2;
!  I7_ShowVtoV(bp_id);
!  if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (sym && (obj2 ~= obj1)) { I7_NowNVtoV(obj2, bp_id, obj1, false); }
	pr = bp_id-->0;
	pr2 = bp_id-->1;
	if (pr) {
		if ((obj1 ofclass Object) && pr && (obj1 provides pr)) i1 = obj1.pr;
		else return RunTimeProblem(RTP_IMPREL, obj1, bp_id, 0);
	} else i1 = obj1-1;
	if (pr2) {
 	 if ((obj2 ofclass Object) && pr2 && (obj2 provides pr2)) i2 = obj2.pr2;
		else return RunTimeProblem(RTP_IMPREL, obj2, bp_id, 0);
	} else i2 = obj2-1;
!  print "Clearing relation", "(", i1, ",", i2, ")^";
	pr = i1*(bp_id-->3) + i2; i1 = 1; i2 = pr%16; while (i2) { i2--; i1=i1*2; }
	pr = pr/16 + 6;
	if ((bp_id-->pr) & i1) bp_id-->pr = bp_id-->pr - i1;
];
[ I7_NowEquiv obj1 prop obj2 big little;
	big = obj1.prop; little = obj2.prop;
	if (big == little) return;
	if (big < little) { little = obj1.prop; big = obj2.prop; }
	objectloop (obj1 provides prop)
		if (obj1.prop == big) obj1.prop = little;
];
[ I7_NowNEquiv obj1 prop obj2 old new;
	old = obj1.prop; new = obj2.prop;
	if (old ~= new) return;
	new = 0;
	objectloop (obj2 provides prop)
		if (obj2.prop > new) new = obj2.prop;
	new++;
	obj1.prop = new;
];
[ I7_TestVtoV obj1 bp_id obj2 sym pr pr2 i1 i2;
	pr = bp_id-->0;
	pr2 = bp_id-->1;
	if (sym && (obj2 > obj1)) { sym = obj1; obj1 = obj2; obj2 = sym; }
	if (pr) {
		if ((obj1 ofclass Object) && pr && (obj1 provides pr)) i1 = obj1.pr;
		else { RunTimeProblem(RTP_IMPREL, obj1, bp_id, 0); rfalse; }
	} else i1 = obj1-1;
	if (pr2) {
 	 if ((obj2 ofclass Object) && pr2 && (obj2 provides pr2)) i2 = obj2.pr2;
		else { RunTimeProblem(RTP_IMPREL, obj2, bp_id, 0); rfalse; }
	} else i2 = obj2-1;
	pr = i1*(bp_id-->3) + i2; i1 = 1; i2 = pr%16; while (i2) { i2--; i1=i1*2; }
	pr = pr/16 + 6;
	if ((bp_id-->pr) & i1) rtrue; rfalse;
];
[ I7_ShowVtoV bp_id sym x obj1 obj2 pr pr2 proutine1 proutine2;
	pr = bp_id-->0;
	pr2 = bp_id-->1;
	proutine1 = bp_id-->4;
	proutine2 = bp_id-->5;
 
	if (pr && pr2) {
		objectloop (obj1 provides pr)
		  objectloop (obj2 provides pr2) {
				if (sym && obj2 > obj1) continue;
				if (I7_TestVtoV(obj1, bp_id, obj2)) {
					if (x) { I7_ShowRHeader(x); x=0; }
					print "  ", (The) obj1;
					if (sym) print "  <=>  "; else print "  >=>  ";
					print (the) obj2, "^";
				}
		  }
		return;
	}
	if (pr && (pr2==0)) {
		objectloop (obj1 provides pr)
		  for (obj2=1:obj2<=bp_id-->3:obj2++) {
				if (I7_TestVtoV(obj1, bp_id, obj2)) {
					if (x) { I7_ShowRHeader(x); x=0; }
					print "  ", (The) obj1, "  >=>  ";
					(proutine2).call(obj2);
					print "^";
				}
		  }
		return;
	}
	if ((pr==0) && (pr2)) {
		for (obj1=1:obj1<=bp_id-->2:obj1++)
		  objectloop (obj2 provides pr2) {
				if (I7_TestVtoV(obj1, bp_id, obj2)) {
					if (x) { I7_ShowRHeader(x); x=0; }
					print "  ";
					(proutine1).call(obj1);
					print "  >=>  ", (the) obj2, "^";
				}
		  }
		return;
	}
	for (obj1=1:obj1<=bp_id-->2:obj1++)
		  for (obj2=1:obj2<=bp_id-->3:obj2++)
			if (I7_TestVtoV(obj1, bp_id, obj2)) {
				if (x) { I7_ShowRHeader(x); x=0; }
				print "  ";
				(proutine1).call(obj1);
				print "  >=>  ";
				(proutine2).call(obj2);
				print "^";
		  }
];
[ I7_ShowOtoO pr sym x obj1 obj2;
	objectloop (obj1 provides pr) {
			obj2 = obj1.pr;
			if (sym && obj2 < obj1) continue;
			if (obj2 == 0) continue;
		if (x) { I7_ShowRHeader(x); x=0; }
		print "  ", (The) obj1;
		if (sym) print "  ==  "; else print "  >=>  ";
		print (the) obj2, "^";
	}
];
[ I7_RShowOtoO pr sym x obj1 obj2;
	objectloop (obj1) {
		objectloop (obj2 provides pr) {
			if (obj2.pr ~= obj1) continue;
			if (x) { I7_ShowRHeader(x); x=0; }
			print "  ", (The) obj1;
			print "  >=>  ";
			print (the) obj2, "^";
		}
	}
];
[ I7_ShowEquiv pr obj1 obj2 v c somegroups;
!	objectloop (obj1 provides pr) print (name) obj1, " ", obj1.pr, "^";
	objectloop (obj1 provides pr) obj1.pr = -(obj1.pr);
	objectloop (obj1 provides pr) {
		if (obj1.pr < 0) {
			v = obj1.pr; c = 0;
			objectloop (obj2 has i7listflag) give obj2 ~i7listflag;
			objectloop (obj2 provides pr) {
				if (obj2.pr == v) {
					give obj2 i7listflag;
					obj2.pr = -v;
					c++;
				}
			}
			if (c>1) {
				somegroups = true;
				print "  { ";
				I7List(0);
				print " }^";
			} else obj1.pr = v;
		}
	}
	objectloop (obj2 has i7listflag) give obj2 ~i7listflag;
	c = 0; objectloop (obj1 provides pr) if (obj1.pr < 0) { c++; give obj1 i7listflag; }
	if (c == 0) return;
	if (somegroups) print "  and "; else print "  ";
	if (c < 4) { I7List(0); print " in"; }
	else print c;
	if (c == 1) print " a";
	print " single-member group";
	if (c > 1) print "s";
	print "^";
	objectloop (obj1 provides pr) if (obj1.pr < 0) obj1.pr = -(obj1.pr);
];

[ I7_ShowRHeader x rel_type;
	rel_type = RelationList-->(x+1);
	print (string) RelationList-->(x+2);
	if (rel_type == Relation_ByRoutine) ".";
	print ":^";
];

[ I7_ShowR rel_num rel_type x;
	x = rel_num*3;
	rel_type = RelationList-->(x+1);
	if (rel_type == Relation_Implicit) return;
	if (rel_type == Relation_ByRoutine) { I7_ShowRHeader(x); return; }
	switch(rel_type) {
		Relation_OtoO: I7_RShowOtoO(RelationList-->x, false, x); break;
		Relation_OtoV: I7_RShowOtoO(RelationList-->x, false, x); break;
		Relation_VtoO: I7_ShowOtoO(RelationList-->x, false, x); break;
		Relation_VtoV: I7_ShowVtoV(RelationList-->x, false, x); break;
		Relation_Sym_OtoO: I7_ShowOtoO(RelationList-->x, true, x); break;
		Relation_Sym_VtoV: I7_ShowVtoV(RelationList-->x, true, x); break;
		Relation_Equiv: I7_ShowRHeader(x); I7_ShowEquiv(RelationList-->x); break;
		Relation_ByRoutine: break;
	}
];

#ifdef TARGET_ZCODE;
Constant I7_ROUTE_HIGH_BIT = $8000;
#ifnot;
! This will fail if any object numbers (addresses) are past the 2 GB boundary.
Constant I7_ROUTE_HIGH_BIT = $80000000;
#endif;
[ I7_RouteTo from to filter use_doors obj dir in_direction progressed sl through_door;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	objectloop (obj ofclass K1_room) obj.vector = 0;
	to.vector = 1;
	!print "Routing from ", (the) from, " to ", (the) to, "^";
	while (true) {
		progressed = false;
		!print "Pass begins^";
		objectloop (obj && (obj ofclass K1_room) && ((filter == 0) || (filter(obj))))
			if (obj.vector == 0)
				objectloop (dir in compass)
					if (obj provides (dir.door_dir)) {
						in_direction = obj.(dir.door_dir);
						if (in_direction == nothing) continue;
						!print (the) obj, " > ", (the) dir, " > ", (the) in_direction, "^";
						if ((in_direction ofclass K1_room)
							&& (in_direction.vector > 0)
							&& ((filter == 0) || (filter(in_direction)))) {
							obj.vector = dir | I7_ROUTE_HIGH_BIT;
							!print "* ", (the) obj, " vector is ", (the) dir, "^";
							progressed = true;
							continue;
						}
						if (use_doors && (in_direction ofclass K4_door) &&
							((use_doors & 2) ||
							 (in_direction has open) ||
							 ((in_direction has openable) && (in_direction hasnt locked)))) {
							sl = location; location = obj;
							through_door = in_direction.door_to();
							location = sl;
							!print "Through door is ", (the) through_door, "^";
							if ((through_door ofclass K1_room) && (through_door.vector > 0)
								&& ((filter == 0) || (filter(through_door)))) {
								obj.vector = dir | I7_ROUTE_HIGH_BIT;
								!print "* ", (the) obj, " vector is ", (the) dir, "^";
								progressed = true;
								continue;
							}
						}
					}
		objectloop (obj ofclass K1_room)
			obj.vector = obj.vector &~ I7_ROUTE_HIGH_BIT;
		if (progressed == false) return from.vector;
	}
];
[ I7_CountRouteTo from to filter use_doors obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	if (from ofclass K1_room && to ofclass K1_room) {
		obj = I7_RouteTo(from,to,filter,use_doors);
		if (obj == nothing) return -1;
		i = 0; obj = from;
		while ((obj ~= to) && (i<1000)) { i++; obj = I7_RoomFrom(obj,obj.vector); }
		return i;
	}
	return -1;
];
[ I7_RelRouteTo relprop from to obj obj2 in_direction relkind progressed pr pr2;
	if (from == nothing) return nothing;
	if (to == nothing) return nothing;
	if (from == to) return nothing;
	if (relprop == 0) return nothing;
	relkind = RelationList-->(3*relprop+1);
	if (relkind == Relation_ByRoutine or Relation_Implicit) {
		RunTimeProblem(RTP_ROUTELESS);
		return nothing;
	}
	relprop = RelationList-->(3*relprop);
	if (relprop == 0) return nothing;
! print "Rel kind is ", relkind, "^";
	if (relkind == Relation_VtoO) {
		objectloop (obj ofclass Object && obj provides relprop) obj.vector = 0;
		to.vector = 1;
		while (true) {
			progressed = false;
			objectloop (obj ofclass Object && obj provides relprop)
				if (obj.vector == 0) {
					in_direction = obj.relprop;
					if ((in_direction ofclass Object && in_direction provides relprop)
						&& (in_direction.vector > 0)) {
						obj.vector = in_direction | I7_ROUTE_HIGH_BIT;
						progressed = true;
						continue;
					}
				}
			objectloop (obj ofclass Object && obj provides relprop)
				obj.vector = obj.vector &~ I7_ROUTE_HIGH_BIT;
			if (progressed == false) return from.vector;
		}
	}
	if (relkind == Relation_OtoV) {
		while (to->relprop) {
			if (to->relprop == from) return to;
			to = to->relprop;
		}
		return nothing;
	}
	pr = relprop-->0;
	pr2 = relprop-->1;
	objectloop (obj ofclass Object && obj provides vector) obj.vector = 0;
	to.vector = 1;
	while (true) {
		progressed = false;
		objectloop (obj ofclass Object && obj provides pr)
			if (obj.vector == 0) {
				objectloop (obj2 ofclass Object && obj2 provides pr2 && obj2.vector > 0) {
					if (I7_TestVtoV(obj, relprop, obj2)) {
						obj.vector = obj2 | I7_ROUTE_HIGH_BIT;
						progressed = true;
						continue;
					}
				}
			}
		objectloop (obj ofclass Object && obj provides vector)
			obj.vector = obj.vector &~ I7_ROUTE_HIGH_BIT;
		if (progressed == false) return from.vector;
	}
];
[ I7_CountRelRouteTo relprop from to obj i;
	if (from == nothing) return -1;
	if (to == nothing) return -1;
	if (from == to) return 0;
	i = 0; obj = from;
	if (I7_RelRouteTo(relprop,from,to) == nothing) return -1;
	while ((obj ~= to) && (i<1000)) { i++; obj = obj.vector; }
	return i;
];

! End of Relations.i6

! WorldModel.i6 segment


! Replaced from the I6 library:

Global untouchable_object;
Global untouchable_silence;
Global touch_persona;
[ ObjectIsUntouchable item silent_flag flag2 p save_sp;
	untouchable_object = item; untouchable_silence = silent_flag;
	touch_persona = p; if (p == actor) touch_persona = 0;
	if ((actor ~= player) &&
		((item ofclass K4_door) || (item ofclass K7_backdrop))) {
		untouchable_silence = 0;
		rfalse;
	}
	save_sp = say__p; say__p = 0;
	if (ProcessRulebook(ACCESS_RB, 0, 1)) {
		if (say__p) save_sp = true; else say__p = save_sp;
		if (rulechange_stack-->rulechange_sp == RS_SUCCEEDS) {
			untouchable_silence = 0;
 			rfalse; ! No barrier
		} else {
			untouchable_silence = 0;
 			rtrue; ! Barrier
		}
	}
	if (say__p) save_sp = true; else say__p = save_sp;
	! No decision is interpreted as no barrier to access:
	untouchable_silence = 0;
	rfalse;
];

[ OIU_Scoped i o;
!  i = ObjectScopedBySomething(untouchable_object);
!  if (i ~= 0) {
!		o = parameter_object;
!		if (ObjectIsUntouchable(i, 0, 0, touch_persona)) rtrue;
!		parameter_object = i;
!		return OIUB_CP();
!  }
	rfalse;
];

[ OIU_Core o;
	while (o && (o provides component_parent) && (o.component_parent))
		o = o.component_parent;
	return o;
];

[ OIU_Parent o;
	return OIU_Core(parent(OIU_Core(o)));
];

[ OIU_CommonAncestor o1 o2 i j;
	!  Find the nearest object indirectly containing o1 and o2,
	!  or return 0 if there is no common ancestor.

	o1 = OIU_Core(o1);
	o2 = OIU_Core(o2);
	i = o1;
	while (i ~= 0) {
		j = o2;
		while (j ~= 0) {
			if (j == i) return i;
			j = OIU_Parent(j);
		}
	  i = OIU_Parent(i);
	}
	return 0;
];

[ OIU_Barrier ancestor i j external p;
	p = touch_persona; if (p == 0) p = actor;

	ancestor = OIU_CommonAncestor(p, untouchable_object);
!  if (ancestor == 0) {
!		RulebookFails(); ! Wholly different locations
!		rtrue;
!  }
!  print "Doing OIU barriers for ", (the) p, " and ", (the) untouchable_object,
!		": common ancestor is ", (the) ancestor, ".^";

	! First, a barrier between the player and the ancestor.

	if (OIU_Core(p) ~= ancestor) {
		i = parent(OIU_Core(p)); j = OIU_Core(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false) && (ProcessRulebook(REACHOUT_RB, i))
			  && (rulechange_stack-->rulechange_sp == RS_FAILS)) rtrue; ! Barrier
			i = parent(OIU_Core(i)); j = OIU_Core(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	! Second, a barrier between the item and the ancestor.

	if (OIU_Core(untouchable_object) ~= ancestor) {
		i = parent(OIU_Core(untouchable_object)); j = OIU_Core(i); external = false;
		if (j ~= i) { i = j; external = true; }
		while (i~=ancestor && i) {
			if ((external == false) && (ProcessRulebook(REACHIN_RB, i))
			  && (rulechange_stack-->rulechange_sp == RS_FAILS)) rtrue; ! Barrier
			i = parent(OIU_Core(i)); j = OIU_Core(i); external = false;
			if (j ~= i) { i = j; external = true; }
		}
	}

	RulebookSucceeds(); ! No barrier
	rtrue;
];

[ OIUB_CCI;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ OIUB_CCO;
	if (parameter_object has container && parameter_object hasnt open) {
		if (touch_persona == 0) GL__M(##Take,9,parameter_object);
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ OIUB_RI;
! print parameter_object, "=", (the) parameter_object, "^";
	if (parameter_object && parameter_object ofclass K1_room) {
		if (touch_persona == 0) GL__M(##Take,14,parameter_object);
		RulebookFails();
		rtrue;
	}
	rfalse;
];

[ OIUB_CP;
	if ((noun provides component_parent) && (noun.component_parent)) {
!	  if (noun.component_parent has transparent)
			return GL__M(##Take,7,noun.component_parent);
	  return GL__M(##Take,8,noun.component_parent);
	}
	rfalse;
];



[ I7_parent o; if (o==0) return 0; return parent(o); ];

[ I7_WhetherIn obj;
	if (obj has enterable) {
		if (I7_IndirectlyContains(obj, player)) rtrue;
		rfalse;
	}
	if (obj ofclass K9_region) return I7_In(real_location, obj);
	if (obj ofclass K1_room) {
		if (obj == real_location) rtrue;
		rfalse;
	}
	RunTimeProblem(RTP_NOTINAROOM, obj);
	rfalse;
];
[ I7_PlayerTo X opt sa;
	sa = actor; actor = player; PlayerTo(X, opt); actor = sa;
];
[ I7_RoomOf p;
	while(p) {
		if (p ofclass K1_room) return p;
		if (parent(p)) { p = parent(p); continue; }
		if (p.component_parent) { p = p.component_parent; continue; }
		return nothing;
	}
	return nothing;
];
[ I7_ReckonLight R S df;
	df = OffersLight(S);
	if (df~=0) { location=S; real_location=S; lightflag=1; }
	else
	{   if (R == thedark)
		{   DarkToDark();
			if (deadflag~=0) rtrue;
		}
		real_location=S;
		location=thedark; lightflag=0;
	}
	rfalse;
];
[ I7_NoticeHeld x;
#IFNDEF MANUAL_PRONOUNS;
	objectloop(x in player) PronounNotice(x);
#ENDIF;
	x = 0; ! To prevent a "not used" error
	rfalse;
];
[ I7_RoomDescriptionForGoing;
	if (say__pc & PARA_COMPLETED == 0) new_line;
	LookSub_P(1);
];
[ I7_SurreptitiousMove F T; ! Used _only_ in one going rule: breaks world model rules
	if (F == player) move F to T; else I7_Move(F, T, 0, 0, 1);
	if (actor == player) location = T;
];
[ I7_Move F T opt ln going_mode was;
	if (F == nothing) return RunTimeProblem(RTP_CANTMOVENOTHING);
	if (F ofclass K7_backdrop) {
		if (T ofclass K9_region) {
			give F ~absent; F.found_in = T.regional_found_in;
			if (I7_In(I7_RoomOf(player), T)) move F to I7_RoomOf(player); else remove F;
			return; }
		return RunTimeProblem(RTP_BACKDROP, F, T, ln);
	}
	if (T ofclass K9_region) {
		return RunTimeProblem(RTP_NOTBACKDROP, F, T, ln);
	}
	if (F has worn) {
		give F ~worn;
		if (F in T) return;
	}
	I7_DetachPart(F, nothing);
!	print "F is ", (the) F, " T is ", (the) T, "^";
	if (F == player) {
		I7_PlayerTo(T, opt);
		return;
	}
	if ((going_mode==false) && (IndirectHolder(F, player)) &&
		(I7_Location(player) ~= I7_Location(T))) {
		was = parent(player);
		move player to real_location;
		move F to T;
		I7_PlayerTo(was, true);
		return;
	}
	move F to T;
];
[ I7_Remove F;
	if (F == false) return RunTimeProblem(RTP_CANTREMOVENOTHING);
	give F ~worn; I7_DetachPart(F, nothing);
	if (F ofclass K7_backdrop) give F absent;
	remove F;
];
[ I7_Wear F T opt;
	if (F == false) rfalse;
	if (F notin T) I7_Move(F, T, opt);
	give F worn;
];
[ I7_DetachPart P From Daddy O;
	Daddy = P.component_parent; P.component_parent = nothing;
	if (Daddy == nothing) { P.component_sibling = nothing; return; }
	if (Daddy.component_child == P) {
		Daddy.component_child = P.component_sibling;
			P.component_sibling = nothing; return;
		}
		for (O = Daddy.component_child: O: O = O.component_sibling)
			if (O.component_sibling == P) {
				O.component_sibling = P.component_sibling;
				P.component_sibling = nothing; return;
			}
];
[ I7_MakePart P Of First;
	if (parent(P)) remove P; give P ~worn;
	if (Of == nothing) { I7_DetachPart(P, nothing); return; }
	if (P.component_parent) I7_DetachPart(P);
	P.component_parent = Of;
	First = Of.component_child;
	Of.component_child = P; P.component_sibling = First;
];
[ I7_OnStage O x;
	if (O ofclass K1_room) rfalse;
	while (O) {
		if (O ofclass K1_room) rtrue;
		if (metaclass(O) ~= Object) rfalse;
		if (O ofclass K9_region) rfalse;
		if (O ofclass K4_door) rtrue;
		if (O ofclass K7_backdrop) { if (O has absent) rfalse; rtrue; }
		x = O.component_parent;
		if (x) { O = x; continue; }
		x = parent(O);
		if (x) { O = x; continue; }
		rfalse;
	}
	rfalse;
];
[ I7_InWhat obj p;
	if (obj ofclass K1_room) return obj.I7_Map_Region;
	p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K5_container) return p;
	if (p ofclass K1_room) return p;
	if (p ofclass K9_region) return p;
	return nothing;
];
[ I7_OnWhat obj p; p = parent(obj);
	if (p == nothing) return nothing;
	if (p ofclass K6_supporter) return p;
	return nothing;
];
[ I7_CarriedBy obj p; p = parent(obj);
	if (p && (p ofclass K8_person) && (obj hasnt worn)) return p;
	return nothing;
];
[ I7_HeldBy obj p; p = parent(obj);
	if (p) return p;
	p = obj.component_parent;
	if (p) return p;
	return nothing;
];
[ I7_WornBy obj p; p = parent(obj);
	if (p && (p ofclass K8_person) && (obj has worn)) return p;
	return nothing;
];
[ I7_HadBy obj p; p = parent(obj);
	if (p && (p ofclass K8_person)) return p;
	return nothing;
];
[ I7_Adjacent R1 R2 d pr;
	objectloop (d in compass) {
		pr = d.door_dir;
		if ((R1 provides pr) && (R2 == R1.pr)) rtrue;
	}
	rfalse;
];
[ I7_In obj region o;
	if ((obj == nothing) || (region == nothing)) rfalse;
	if (~~(obj ofclass K1_room))
		obj = I7_Location(obj);
	if (obj == nothing) rfalse;
	o = obj.I7_Map_Region;
	while (o) {
		if (o == region) rtrue;
		o = parent(o);
	}
	rfalse;
];
[ I7_CanSee A B erf;
	if (location == thedark) rfalse;
	if (I7_suppress_scope_loops) {
		if (erf) print "CanSee(", (the) A, ", ", (the) B, ")^";
		rtrue;
	}
	return TestScope(B, A);
];
[ I7_CanTouch A B;
	if (TestScope(B,A) == false) rfalse;
	if (ObjectIsUntouchable(B, 1, 0, A)) rfalse;
	rtrue;
];
[ I7_Conceals A B;
	if (A ofclass K2_thing && B ofclass K2_thing) {
		I7_concealed_item = B;
		if (CarryOutActivity(CONCEALMENT_ACT, A)) rtrue;
	}
	rfalse;
];
[ I7_RoomFrom obj dir use_doors in_direction sl through_door;
	use_doors = 2;
	if ((obj ofclass K1_room) && (dir in compass)) {
		if (obj provides (dir.door_dir)) {
			in_direction = obj.(dir.door_dir);
			if (in_direction ofclass K1_room) return in_direction;
			if (use_doors && (in_direction ofclass K4_door) &&
				((use_doors & 2) ||
				 (in_direction has open) ||
				 ((in_direction has openable) && (in_direction hasnt locked)))) {
				sl = location; location = obj;
				through_door = in_direction.door_to();
				location = sl;
				if (through_door ofclass K1_room) return through_door;
			}
		}	
	}
	return nothing;
];
[ I7_RoomOrDoorFrom obj dir use_doors in_direction sl through_door;
	if ((obj ofclass K1_room) && (dir in compass)) {
		if (obj provides (dir.door_dir)) {
			in_direction = obj.(dir.door_dir);
			if (in_direction ofclass K1_room) return in_direction;
			if (in_direction ofclass K4_door) return in_direction;
		}	
	}
	return nothing;
];
[ I7_OtherSide dr from sl rv;
	if (dr ofclass K4_door) {
		sl = location; location = I7_RoomOf(from);
		rv = dr.door_to();
		location = sl;
	}
	return rv;
];
[ I7_DirectionFrom dr from sl rv;
	if (dr ofclass K4_door) {
		sl = location; location = I7_RoomOf(from);
		rv = dr.door_dir();
		location = sl;
	}
	return rv;
];
[ I7_ChangeExit r1 dir r2 pr;
	pr = dir.door_dir;
	if (r1 provides pr) {
		if ((r1.pr == 0) || (r1.pr ofclass K1_room)) {
				r1.pr = r2;
				return;
		}
		if (r1.pr ofclass K4_door) {
			RunTimeProblem(RTP_EXITDOOR, r1, dir);
			return;
		}
	}
	RunTimeProblem(RTP_NOEXIT, r1, dir);
];
[ I7_ChangeNExit r1 dir r2 pr;
	pr = dir.door_dir;
	if (r1 ofclass K4_door) {
		RunTimeProblem(RTP_EXITDOOR, r1, dir);
		return;
	}
	if ((r1 provides pr) && (r1.pr == r2)) r1.pr = 0;
	return;
];
[ IndirectHolder A B;
	while (B) {
	  if (B==A) rtrue;
	  B = I7_Holder(B);
	}
	rfalse;
];
[ I7_Holder X;
	if (parent(X)) return parent(X);
	if (X.component_parent) return X.component_parent;
	rfalse;
];
[ I7_ChangePlayer O;
	if (O ofclass K27_player_character) return ChangePlayer(O);
	RunTimeProblem(RTP_CANTCHANGE);
];
[ I7_FrontSide D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->0;
	return parent(D);
];
[ I7_BackSide D; if (~~(D ofclass K4_door)) rfalse;
	if (D provides found_in) return (D.&found_in)-->1;
	rfalse;
];
[ I7_Location O;
	if (~~(O ofclass K2_thing)) rfalse;
	if (O ofclass K4_door) return I7_FrontSide(O);
	if (O ofclass K7_backdrop) rfalse;
	while (O && (~~(O ofclass K1_room))) {
		if (parent(O)) O = parent(O);
		else O = O.component_parent;
	}
	return O;
];
[ I7_IndirectlyContains o1 o2;
	!  Does o1 enclose o2?
	if ((o1==o2) || (o1 == 0) || (o2 == 0)) rfalse;
	if (o2 ofclass K4_door) {
		if (o1 == I7_FrontSide(o2)) rtrue;
		if (o1 == I7_BackSide(o2)) rtrue;
		rfalse;
	}
	if (o2 ofclass K7_backdrop) rfalse;
	while (o2) {
		if (o1==o2) rtrue;
		if (parent(o2)) o2 = parent(o2);
		else o2 = o2.component_parent;
	}
	rfalse;
];

[ I7_PlaceInScope O opts;
	if (opts) return PlaceInScope(O);
	if (O ofclass K2_thing) PlaceInScope(O);
	ScopeWithin(O);
];
[ I7_ScopeParts from obj saw;
!	print "I7_ScopeParts ", from, "^";
	saw = advance_warning; advance_warning = -1;
	if (from == 0) from = self;
	for (obj = from.component_child: obj: obj = obj.component_sibling)
		if ((from == actor) || (I7_Conceals(from, obj) == false)) {
			ScopeWithin_O(obj,0,scope_reason);
		}
	advance_warning = saw;
];

Global allow_abbreviated_look = 0;

[ LookSub_P allow_abbrev oact p1 frame_id; allow_abbreviated_look = allow_abbrev;
	oact = action; action = ##Look;
	p1 = FindAction(##Look);
	if ((p1) && (ActionData-->(p1+9))) {
		frame_id = ActionData-->(p1+10);
		Mstack_Create_Frame(ActionData-->(p1+9), frame_id);
		ProcessRulebook(SETACTIONVARS_RB);
		(MStack-->MstVO(frame_id, 0)) = oact;
	}
	LookSub();
	if (frame_id) Mstack_Destroy_Frame(frame_id);
	allow_abbreviated_look = 0;
	action = oact;
];
[ I7_Calculate_VC;
	if (actor ~= player) rfalse;
	if (parent(actor)==0) return RunTimeError(10);
	visibility_levels = 0;
	.MovedByInitial;
	if (location == thedark) { visibility_ceiling = thedark; NoteArrival(); }
	else
	{   visibility_levels = FindVisibilityLevels();
		if (visibility_ceiling == location)
		{   NoteArrival();
			if (visibility_ceiling ~= location) jump MovedByInitial;
		}
	} rfalse;
];
[ I7_RoomDescPara vc;
	if (lookmode<3 && vc==location)
	{   if ((allow_abbreviated_look~=1) || (lookmode==2) || (location hasnt visited))
		{   if (location.describe~=NULL) {
			    RunRoutines(location,describe);
			    say__p = 1;
			} else {
			    if (location.description==0) RunTimeError(11,location);
			    else {
					  if (location == thedark)
						  I7_PrintProp(thedark,description);
					  else {
						  if (I7_PrintProp(location,description)) say__p = 1;
						  else say__p = 0;
					  }
			    }
			}
		}
	}
];

! End of WorldModel.i6

! Time.i6 segment

[ RoundOffTime t1 t2; return ((t1+t2/2)/t2)*t2; ];

[ PrintTimeOfDay t h aop;
	if (t<0) { print "<no time>"; return; }
	if (t >= 60*12) { aop = "pm"; t=t-60*12; } else aop = "am";
	h = t/60; if (h==0) h=12;
	print h, ":";
	if (t%60<10) print "0"; print t%60, " ", (string) aop;
];

[ PrintTimeOfDayEnglish t h m dir aop;
	h = (t/60) % 12; m = t%60; if (h==0) h=12;
	if (m==0) { print (number) h, " o'clock"; return; }
	dir = "past";
	if (m > 30) { m = 60-m; h = (h+1)%12; if (h==0) h=12; dir = "to"; }
	switch(m) {
		15: print "quarter"; 30: print "half";
		default: print (number) m;
		    if (m%5 ~= 0) {
					if (m == 1) print " minute"; else print " minutes";
		    }
	}
	print " ", (string) dir, " ", (number) h;
];

Constant I7_TWELVE_HOURS = 720;

[ I7_HoursMinsWordToTime hour minute word x;
	if (hour >= 24) return -1;
	if (minute >= 60) return -1;
	x = hour*60 + minute; if (hour >= 13) return x;
	x = x%I7_TWELVE_HOURS; if (word == 'pm') x = x + I7_TWELVE_HOURS;
	if (word ~= 'am' or 'pm' && hour == 12) x = x + I7_TWELVE_HOURS;
	return x;
];

[ I7_ExtendedTryNumber wordnum i j;
	i = wn; wn = wordnum; j = NextWordStopped(); wn = i;
	switch (j) {
		'twenty-one': return 21;
		'twenty-two': return 22;
		'twenty-three': return 23;
		'twenty-four': return 24;
		'twenty-five': return 25;
		'twenty-six': return 26;
		'twenty-seven': return 27;
		'twenty-eight': return 28;
		'twenty-nine': return 29;
		'thirty': return 30;
		default: return TryNumber(wordnum);
	}
];

[ I7_TIME_TOKEN first_word second_word at length flag illegal_char offhour hr mn i;
	first_word = NextWordStopped();
	switch (first_word) {
		'midnight': parsed_number = 0; return GPR_NUMBER;
		'midday', 'noon': parsed_number = I7_TWELVE_HOURS;
		return GPR_NUMBER;
	}
	! Next try the format 12:02
	at = WordAddress(wn-1); length = WordLength(wn-1);
	for (i=0: i<length: i++) {
		switch (at->i) {
			':': if (flag == false && i>0 && i<length-1) flag = true;
			else illegal_char = true;
			'0', '1', '2', '3', '4', '5', '6', '7', '8', '9': ;
			default: illegal_char = true;
		}
	}
	if (length < 3 || length > 5 || illegal_char) flag = false;
	if (flag) {
		for (i=0: at->i~=':': i++, hr=hr*10) hr = hr + at->i - '0';
		hr = hr/10;
		for (i++: i<length: i++, mn=mn*10) mn = mn + at->i - '0';
		mn = mn/10;
		second_word = NextWordStopped();
		parsed_number = I7_HoursMinsWordToTime(hr, mn, second_word);
		if (parsed_number == -1) return GPR_FAIL;
		if (second_word ~= 'pm' or 'am') wn--;
		return GPR_NUMBER;
	}
	! Lastly the wordy format
	offhour = -1;
	if (first_word == 'half') offhour = 30;
	if (first_word == 'quarter') offhour = 15;
	if (offhour < 0) offhour = I7_ExtendedTryNumber(wn-1);
	if (offhour < 0 || offhour >= 60) return GPR_FAIL;
	second_word = NextWordStopped();
	switch (second_word) {
		! "six o'clock", "six"
		'o^clock', 'am', 'pm', -1:
			hr = offhour; if (hr > 12) return GPR_FAIL;
		! "quarter to six", "twenty past midnight"
		'to', 'past':
			mn = offhour; hr = I7_ExtendedTryNumber(wn);
			if (hr <= 0) {
				switch (NextWordStopped()) {
					'noon', 'midday': hr = 12;
					'midnight': hr = 0;
					default: return GPR_FAIL;
				}
			}
			if (hr >= 13) return GPR_FAIL;
			if (second_word == 'to') {
				mn = 60-mn; hr--; if (hr<0) hr=23;
			}
			wn++; second_word = NextWordStopped();
		! "six thirty"
		default:
			hr = offhour; mn = I7_ExtendedTryNumber(--wn);
			if (mn < 0 || mn >= 60) return GPR_FAIL;
			wn++; second_word = NextWordStopped();
	}
	parsed_number = I7_HoursMinsWordToTime(hr, mn, second_word);
	if (parsed_number < 0) return GPR_FAIL;
	if (second_word ~= 'pm' or 'am' or 'o^clock') wn--;
	return GPR_NUMBER;
];

[ SetI7Timer R t f i b;
	for (i=1: i<=(I7TimerTable-->0): i++) {
		if (R == I7TimerTable-->i) { b=i; jump SlotFound; }
		if ((b==0) && (I7TimerTable-->i == 0)) b=i;
	}
	if (b==0) return RunTimeProblem(RTP_TOOMANYEVENTS);
	.SlotFound;
	I7TimerTable-->b = R;
	if (f == 0) I7TimerTableTimes-->b = -t;
	else I7TimerTableTimes-->b = t;
];

[ ProcessI7Timers i t f r;
	for (i=1: i<=(I7TimerTable-->0): i++)
		if ((r=I7TimerTable-->i) ~= 0) {
			t = I7TimerTableTimes-->i; f = 0;
			if (t<0) {
					(I7TimerTableTimes-->i)++;
					if (I7TimerTableTimes-->i == 0) f=1;
			} else {
					if ((the_time >= t) && (the_time < t+30)) f=1;
			}
			if (f) {
					I7TimerTable-->i = 0;
					ProcessRulebook(r);
			}
		}
	rfalse;
];

! --- Turn sequence rules ---
[ TS1_R; AdvanceWorldClock(); rfalse; ];
[ TS2_R; RunTimersAndDaemons(); rfalse; ];
[ TS3_R; RunEachTurnProperties(); rfalse; ];
[ TS4_R; TimePasses(); rfalse; ];
[ TS5_R; AdjustLight(); rfalse; ];
[ TS6_R obj;
	NoteObjectAcquisitions();
	objectloop (obj in player)
		if (obj ofclass RUCKSACK_CLASS)
			SACK_OBJECT = obj;
	rfalse;
];

! End of Time.i6 segment

! Figures.i6

#IFDEF TARGET_GLULX;
#IFNDEF infglk_h; ! Standard Glulx definitions contributed by John Cater
Constant infglk_h;
!-------------------------------------------------------------------------------
!  infglk.h - an Inform library to allow easy access to glk functions
!    under glulx
!  Dynamically created by glk2inf.pl on 08/31/2006 at 19:20:21.
!  Send comments or suggestions to: katre@ruf.rice.edu
!-------------------------------------------------------------------------------
#Ifdef infglk_h;  ! remove "Constant declared but not used" warnings
#Endif;

Constant GLK_NULL 0;

! Constant definitions from glk.h
Constant gestalt_Version 0;
Constant gestalt_CharInput 1;
Constant gestalt_LineInput 2;
Constant gestalt_CharOutput 3;
Constant gestalt_CharOutput_CannotPrint 0;
Constant gestalt_CharOutput_ApproxPrint 1;
Constant gestalt_CharOutput_ExactPrint 2;
Constant gestalt_MouseInput 4;
Constant gestalt_Timer 5;
Constant gestalt_Graphics 6;
Constant gestalt_DrawImage 7;
Constant gestalt_Sound 8;
Constant gestalt_SoundVolume 9;
Constant gestalt_SoundNotify 10;
Constant gestalt_Hyperlinks 11;
Constant gestalt_HyperlinkInput 12;
Constant gestalt_SoundMusic 13;
Constant gestalt_GraphicsTransparency 14;
Constant gestalt_Unicode 15;
Constant evtype_None 0;
Constant evtype_Timer 1;
Constant evtype_CharInput 2;
Constant evtype_LineInput 3;
Constant evtype_MouseInput 4;
Constant evtype_Arrange 5;
Constant evtype_Redraw 6;
Constant evtype_SoundNotify 7;
Constant evtype_Hyperlink 8;
Constant keycode_Unknown $ffffffff;
Constant keycode_Left $fffffffe;
Constant keycode_Right $fffffffd;
Constant keycode_Up $fffffffc;
Constant keycode_Down $fffffffb;
Constant keycode_Return $fffffffa;
Constant keycode_Delete $fffffff9;
Constant keycode_Escape $fffffff8;
Constant keycode_Tab $fffffff7;
Constant keycode_PageUp $fffffff6;
Constant keycode_PageDown $fffffff5;
Constant keycode_Home $fffffff4;
Constant keycode_End $fffffff3;
Constant keycode_Func1 $ffffffef;
Constant keycode_Func2 $ffffffee;
Constant keycode_Func3 $ffffffed;
Constant keycode_Func4 $ffffffec;
Constant keycode_Func5 $ffffffeb;
Constant keycode_Func6 $ffffffea;
Constant keycode_Func7 $ffffffe9;
Constant keycode_Func8 $ffffffe8;
Constant keycode_Func9 $ffffffe7;
Constant keycode_Func10 $ffffffe6;
Constant keycode_Func11 $ffffffe5;
Constant keycode_Func12 $ffffffe4;
Constant keycode_MAXVAL 28;
Constant style_Normal 0;
Constant style_Emphasized 1;
Constant style_Preformatted 2;
Constant style_Header 3;
Constant style_Subheader 4;
Constant style_Alert 5;
Constant style_Note 6;
Constant style_BlockQuote 7;
Constant style_Input 8;
Constant style_User1 9;
Constant style_User2 10;
Constant style_NUMSTYLES 11;
Constant wintype_AllTypes 0;
Constant wintype_Pair 1;
Constant wintype_Blank 2;
Constant wintype_TextBuffer 3;
Constant wintype_TextGrid 4;
Constant wintype_Graphics 5;
Constant winmethod_Left $00;
Constant winmethod_Right $01;
Constant winmethod_Above $02;
Constant winmethod_Below $03;
Constant winmethod_DirMask $0f;
Constant winmethod_Fixed $10;
Constant winmethod_Proportional $20;
Constant winmethod_DivisionMask $f0;
Constant fileusage_Data $00;
Constant fileusage_SavedGame $01;
Constant fileusage_Transcript $02;
Constant fileusage_InputRecord $03;
Constant fileusage_TypeMask $0f;
Constant fileusage_TextMode $100;
Constant fileusage_BinaryMode $000;
Constant filemode_Write $01;
Constant filemode_Read $02;
Constant filemode_ReadWrite $03;
Constant filemode_WriteAppend $05;
Constant seekmode_Start 0;
Constant seekmode_Current 1;
Constant seekmode_End 2;
Constant stylehint_Indentation 0;
Constant stylehint_ParaIndentation 1;
Constant stylehint_Justification 2;
Constant stylehint_Size 3;
Constant stylehint_Weight 4;
Constant stylehint_Oblique 5;
Constant stylehint_Proportional 6;
Constant stylehint_TextColor 7;
Constant stylehint_BackColor 8;
Constant stylehint_ReverseColor 9;
Constant stylehint_NUMHINTS 10;
Constant stylehint_just_LeftFlush 0;
Constant stylehint_just_LeftRight 1;
Constant stylehint_just_Centered 2;
Constant stylehint_just_RightFlush 3;
Constant imagealign_InlineUp $01;
Constant imagealign_InlineDown $02;
Constant imagealign_InlineCenter $03;
Constant imagealign_MarginLeft $04;
Constant imagealign_MarginRight $05;

! The actual glk functions.
[ glk_exit _vararg_count ret;
! glk_exit ()
  ! And now the @glk call
  @glk 1 _vararg_count ret;
  return ret;
];

[ glk_set_interrupt_handler _vararg_count ret;
! glk_set_interrupt_handler (func)
  ! And now the @glk call
  @glk 2 _vararg_count ret;
  return ret;
];

[ glk_tick _vararg_count ret;
! glk_tick ()
  ! And now the @glk call
  @glk 3 _vararg_count ret;
  return ret;
];

[ glk_gestalt _vararg_count ret;
! glk_gestalt (sel val)
  ! And now the @glk call
  @glk 4 _vararg_count ret;
  return ret;
];

[ glk_gestalt_ext _vararg_count ret;
! glk_gestalt_ext (sel val arr arrlen)
  ! And now the @glk call
  @glk 5 _vararg_count ret;
  return ret;
];

[ glk_char_to_lower _vararg_count ret;
! glk_char_to_lower (ch)
  ! And now the @glk call
  @glk 160 _vararg_count ret;
  return ret;
];

[ glk_char_to_upper _vararg_count ret;
! glk_char_to_upper (ch)
  ! And now the @glk call
  @glk 161 _vararg_count ret;
  return ret;
];

[ glk_window_get_root _vararg_count ret;
! glk_window_get_root ()
  ! And now the @glk call
  @glk 34 _vararg_count ret;
  return ret;
];

[ glk_window_open _vararg_count ret;
! glk_window_open (split method size wintype rock)
  ! And now the @glk call
  @glk 35 _vararg_count ret;
  return ret;
];

[ glk_window_close _vararg_count ret;
! glk_window_close (win result)
  ! And now the @glk call
  @glk 36 _vararg_count ret;
  return ret;
];

[ glk_window_get_size _vararg_count ret;
! glk_window_get_size (win widthptr heightptr)
  ! And now the @glk call
  @glk 37 _vararg_count ret;
  return ret;
];

[ glk_window_set_arrangement _vararg_count ret;
! glk_window_set_arrangement (win method size keywin)
  ! And now the @glk call
  @glk 38 _vararg_count ret;
  return ret;
];

[ glk_window_get_arrangement _vararg_count ret;
! glk_window_get_arrangement (win methodptr sizeptr keywinptr)
  ! And now the @glk call
  @glk 39 _vararg_count ret;
  return ret;
];

[ glk_window_iterate _vararg_count ret;
! glk_window_iterate (win rockptr)
  ! And now the @glk call
  @glk 32 _vararg_count ret;
  return ret;
];

[ glk_window_get_rock _vararg_count ret;
! glk_window_get_rock (win)
  ! And now the @glk call
  @glk 33 _vararg_count ret;
  return ret;
];

[ glk_window_get_type _vararg_count ret;
! glk_window_get_type (win)
  ! And now the @glk call
  @glk 40 _vararg_count ret;
  return ret;
];

[ glk_window_get_parent _vararg_count ret;
! glk_window_get_parent (win)
  ! And now the @glk call
  @glk 41 _vararg_count ret;
  return ret;
];

[ glk_window_get_sibling _vararg_count ret;
! glk_window_get_sibling (win)
  ! And now the @glk call
  @glk 48 _vararg_count ret;
  return ret;
];

[ glk_window_clear _vararg_count ret;
! glk_window_clear (win)
  ! And now the @glk call
  @glk 42 _vararg_count ret;
  return ret;
];

[ glk_window_move_cursor _vararg_count ret;
! glk_window_move_cursor (win xpos ypos)
  ! And now the @glk call
  @glk 43 _vararg_count ret;
  return ret;
];

[ glk_window_get_stream _vararg_count ret;
! glk_window_get_stream (win)
  ! And now the @glk call
  @glk 44 _vararg_count ret;
  return ret;
];

[ glk_window_set_echo_stream _vararg_count ret;
! glk_window_set_echo_stream (win str)
  ! And now the @glk call
  @glk 45 _vararg_count ret;
  return ret;
];

[ glk_window_get_echo_stream _vararg_count ret;
! glk_window_get_echo_stream (win)
  ! And now the @glk call
  @glk 46 _vararg_count ret;
  return ret;
];

[ glk_set_window _vararg_count ret;
! glk_set_window (win)
  ! And now the @glk call
  @glk 47 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file _vararg_count ret;
! glk_stream_open_file (fileref fmode rock)
  ! And now the @glk call
  @glk 66 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory _vararg_count ret;
! glk_stream_open_memory (buf buflen fmode rock)
  ! And now the @glk call
  @glk 67 _vararg_count ret;
  return ret;
];

[ glk_stream_close _vararg_count ret;
! glk_stream_close (str result)
  ! And now the @glk call
  @glk 68 _vararg_count ret;
  return ret;
];

[ glk_stream_iterate _vararg_count ret;
! glk_stream_iterate (str rockptr)
  ! And now the @glk call
  @glk 64 _vararg_count ret;
  return ret;
];

[ glk_stream_get_rock _vararg_count ret;
! glk_stream_get_rock (str)
  ! And now the @glk call
  @glk 65 _vararg_count ret;
  return ret;
];

[ glk_stream_set_position _vararg_count ret;
! glk_stream_set_position (str pos seekmode)
  ! And now the @glk call
  @glk 69 _vararg_count ret;
  return ret;
];

[ glk_stream_get_position _vararg_count ret;
! glk_stream_get_position (str)
  ! And now the @glk call
  @glk 70 _vararg_count ret;
  return ret;
];

[ glk_stream_set_current _vararg_count ret;
! glk_stream_set_current (str)
  ! And now the @glk call
  @glk 71 _vararg_count ret;
  return ret;
];

[ glk_stream_get_current _vararg_count ret;
! glk_stream_get_current ()
  ! And now the @glk call
  @glk 72 _vararg_count ret;
  return ret;
];

[ glk_put_char _vararg_count ret;
! glk_put_char (ch)
  ! And now the @glk call
  @glk 128 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream _vararg_count ret;
! glk_put_char_stream (str ch)
  ! And now the @glk call
  @glk 129 _vararg_count ret;
  return ret;
];

[ glk_put_string _vararg_count ret;
! glk_put_string (s)
  ! And now the @glk call
  @glk 130 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream _vararg_count ret;
! glk_put_string_stream (str s)
  ! And now the @glk call
  @glk 131 _vararg_count ret;
  return ret;
];

[ glk_put_buffer _vararg_count ret;
! glk_put_buffer (buf len)
  ! And now the @glk call
  @glk 132 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream _vararg_count ret;
! glk_put_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 133 _vararg_count ret;
  return ret;
];

[ glk_set_style _vararg_count ret;
! glk_set_style (styl)
  ! And now the @glk call
  @glk 134 _vararg_count ret;
  return ret;
];

[ glk_set_style_stream _vararg_count ret;
! glk_set_style_stream (str styl)
  ! And now the @glk call
  @glk 135 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream _vararg_count ret;
! glk_get_char_stream (str)
  ! And now the @glk call
  @glk 144 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream _vararg_count ret;
! glk_get_line_stream (str buf len)
  ! And now the @glk call
  @glk 145 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream _vararg_count ret;
! glk_get_buffer_stream (str buf len)
  ! And now the @glk call
  @glk 146 _vararg_count ret;
  return ret;
];

[ glk_stylehint_set _vararg_count ret;
! glk_stylehint_set (wintype styl hint val)
  ! And now the @glk call
  @glk 176 _vararg_count ret;
  return ret;
];

[ glk_stylehint_clear _vararg_count ret;
! glk_stylehint_clear (wintype styl hint)
  ! And now the @glk call
  @glk 177 _vararg_count ret;
  return ret;
];

[ glk_style_distinguish _vararg_count ret;
! glk_style_distinguish (win styl1 styl2)
  ! And now the @glk call
  @glk 178 _vararg_count ret;
  return ret;
];

[ glk_style_measure _vararg_count ret;
! glk_style_measure (win styl hint result)
  ! And now the @glk call
  @glk 179 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_temp _vararg_count ret;
! glk_fileref_create_temp (usage rock)
  ! And now the @glk call
  @glk 96 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_name _vararg_count ret;
! glk_fileref_create_by_name (usage name rock)
  ! And now the @glk call
  @glk 97 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_by_prompt _vararg_count ret;
! glk_fileref_create_by_prompt (usage fmode rock)
  ! And now the @glk call
  @glk 98 _vararg_count ret;
  return ret;
];

[ glk_fileref_create_from_fileref _vararg_count ret;
! glk_fileref_create_from_fileref (usage fref rock)
  ! And now the @glk call
  @glk 104 _vararg_count ret;
  return ret;
];

[ glk_fileref_destroy _vararg_count ret;
! glk_fileref_destroy (fref)
  ! And now the @glk call
  @glk 99 _vararg_count ret;
  return ret;
];

[ glk_fileref_iterate _vararg_count ret;
! glk_fileref_iterate (fref rockptr)
  ! And now the @glk call
  @glk 100 _vararg_count ret;
  return ret;
];

[ glk_fileref_get_rock _vararg_count ret;
! glk_fileref_get_rock (fref)
  ! And now the @glk call
  @glk 101 _vararg_count ret;
  return ret;
];

[ glk_fileref_delete_file _vararg_count ret;
! glk_fileref_delete_file (fref)
  ! And now the @glk call
  @glk 102 _vararg_count ret;
  return ret;
];

[ glk_fileref_does_file_exist _vararg_count ret;
! glk_fileref_does_file_exist (fref)
  ! And now the @glk call
  @glk 103 _vararg_count ret;
  return ret;
];

[ glk_select _vararg_count ret;
! glk_select (event)
  ! And now the @glk call
  @glk 192 _vararg_count ret;
  return ret;
];

[ glk_select_poll _vararg_count ret;
! glk_select_poll (event)
  ! And now the @glk call
  @glk 193 _vararg_count ret;
  return ret;
];

[ glk_request_timer_events _vararg_count ret;
! glk_request_timer_events (millisecs)
  ! And now the @glk call
  @glk 214 _vararg_count ret;
  return ret;
];

[ glk_request_line_event _vararg_count ret;
! glk_request_line_event (win buf maxlen initlen)
  ! And now the @glk call
  @glk 208 _vararg_count ret;
  return ret;
];

[ glk_request_char_event _vararg_count ret;
! glk_request_char_event (win)
  ! And now the @glk call
  @glk 210 _vararg_count ret;
  return ret;
];

[ glk_request_mouse_event _vararg_count ret;
! glk_request_mouse_event (win)
  ! And now the @glk call
  @glk 212 _vararg_count ret;
  return ret;
];

[ glk_cancel_line_event _vararg_count ret;
! glk_cancel_line_event (win event)
  ! And now the @glk call
  @glk 209 _vararg_count ret;
  return ret;
];

[ glk_cancel_char_event _vararg_count ret;
! glk_cancel_char_event (win)
  ! And now the @glk call
  @glk 211 _vararg_count ret;
  return ret;
];

[ glk_cancel_mouse_event _vararg_count ret;
! glk_cancel_mouse_event (win)
  ! And now the @glk call
  @glk 213 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_lower_case_uni _vararg_count ret;
! glk_buffer_to_lower_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 288 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_upper_case_uni _vararg_count ret;
! glk_buffer_to_upper_case_uni (buf len numchars)
  ! And now the @glk call
  @glk 289 _vararg_count ret;
  return ret;
];

[ glk_buffer_to_title_case_uni _vararg_count ret;
! glk_buffer_to_title_case_uni (buf len numchars lowerrest)
  ! And now the @glk call
  @glk 290 _vararg_count ret;
  return ret;
];

[ glk_put_char_uni _vararg_count ret;
! glk_put_char_uni (ch)
  ! And now the @glk call
  @glk 296 _vararg_count ret;
  return ret;
];

[ glk_put_string_uni _vararg_count ret;
! glk_put_string_uni (s)
  ! And now the @glk call
  @glk 297 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_uni _vararg_count ret;
! glk_put_buffer_uni (buf len)
  ! And now the @glk call
  @glk 298 _vararg_count ret;
  return ret;
];

[ glk_put_char_stream_uni _vararg_count ret;
! glk_put_char_stream_uni (str ch)
  ! And now the @glk call
  @glk 299 _vararg_count ret;
  return ret;
];

[ glk_put_string_stream_uni _vararg_count ret;
! glk_put_string_stream_uni (str s)
  ! And now the @glk call
  @glk 300 _vararg_count ret;
  return ret;
];

[ glk_put_buffer_stream_uni _vararg_count ret;
! glk_put_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 301 _vararg_count ret;
  return ret;
];

[ glk_get_char_stream_uni _vararg_count ret;
! glk_get_char_stream_uni (str)
  ! And now the @glk call
  @glk 304 _vararg_count ret;
  return ret;
];

[ glk_get_buffer_stream_uni _vararg_count ret;
! glk_get_buffer_stream_uni (str buf len)
  ! And now the @glk call
  @glk 305 _vararg_count ret;
  return ret;
];

[ glk_get_line_stream_uni _vararg_count ret;
! glk_get_line_stream_uni (str buf len)
  ! And now the @glk call
  @glk 306 _vararg_count ret;
  return ret;
];

[ glk_stream_open_file_uni _vararg_count ret;
! glk_stream_open_file_uni (fileref fmode rock)
  ! And now the @glk call
  @glk 312 _vararg_count ret;
  return ret;
];

[ glk_stream_open_memory_uni _vararg_count ret;
! glk_stream_open_memory_uni (buf buflen fmode rock)
  ! And now the @glk call
  @glk 313 _vararg_count ret;
  return ret;
];

[ glk_request_char_event_uni _vararg_count ret;
! glk_request_char_event_uni (win)
  ! And now the @glk call
  @glk 320 _vararg_count ret;
  return ret;
];

[ glk_request_line_event_uni _vararg_count ret;
! glk_request_line_event_uni (win buf maxlen initlen)
  ! And now the @glk call
  @glk 321 _vararg_count ret;
  return ret;
];

[ glk_image_draw _vararg_count ret;
! glk_image_draw (win image val1 val2)
  ! And now the @glk call
  @glk 225 _vararg_count ret;
  return ret;
];

[ glk_image_draw_scaled _vararg_count ret;
! glk_image_draw_scaled (win image val1 val2 width height)
  ! And now the @glk call
  @glk 226 _vararg_count ret;
  return ret;
];

[ glk_image_get_info _vararg_count ret;
! glk_image_get_info (image width height)
  ! And now the @glk call
  @glk 224 _vararg_count ret;
  return ret;
];

[ glk_window_flow_break _vararg_count ret;
! glk_window_flow_break (win)
  ! And now the @glk call
  @glk 232 _vararg_count ret;
  return ret;
];

[ glk_window_erase_rect _vararg_count ret;
! glk_window_erase_rect (win left top width height)
  ! And now the @glk call
  @glk 233 _vararg_count ret;
  return ret;
];

[ glk_window_fill_rect _vararg_count ret;
! glk_window_fill_rect (win color left top width height)
  ! And now the @glk call
  @glk 234 _vararg_count ret;
  return ret;
];

[ glk_window_set_background_color _vararg_count ret;
! glk_window_set_background_color (win color)
  ! And now the @glk call
  @glk 235 _vararg_count ret;
  return ret;
];

[ glk_schannel_create _vararg_count ret;
! glk_schannel_create (rock)
  ! And now the @glk call
  @glk 242 _vararg_count ret;
  return ret;
];

[ glk_schannel_destroy _vararg_count ret;
! glk_schannel_destroy (chan)
  ! And now the @glk call
  @glk 243 _vararg_count ret;
  return ret;
];

[ glk_schannel_iterate _vararg_count ret;
! glk_schannel_iterate (chan rockptr)
  ! And now the @glk call
  @glk 240 _vararg_count ret;
  return ret;
];

[ glk_schannel_get_rock _vararg_count ret;
! glk_schannel_get_rock (chan)
  ! And now the @glk call
  @glk 241 _vararg_count ret;
  return ret;
];

[ glk_schannel_play _vararg_count ret;
! glk_schannel_play (chan snd)
  ! And now the @glk call
  @glk 248 _vararg_count ret;
  return ret;
];

[ glk_schannel_play_ext _vararg_count ret;
! glk_schannel_play_ext (chan snd repeats notify)
  ! And now the @glk call
  @glk 249 _vararg_count ret;
  return ret;
];

[ glk_schannel_stop _vararg_count ret;
! glk_schannel_stop (chan)
  ! And now the @glk call
  @glk 250 _vararg_count ret;
  return ret;
];

[ glk_schannel_set_volume _vararg_count ret;
! glk_schannel_set_volume (chan vol)
  ! And now the @glk call
  @glk 251 _vararg_count ret;
  return ret;
];

[ glk_sound_load_hint _vararg_count ret;
! glk_sound_load_hint (snd flag)
  ! And now the @glk call
  @glk 252 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink _vararg_count ret;
! glk_set_hyperlink (linkval)
  ! And now the @glk call
  @glk 256 _vararg_count ret;
  return ret;
];

[ glk_set_hyperlink_stream _vararg_count ret;
! glk_set_hyperlink_stream (str linkval)
  ! And now the @glk call
  @glk 257 _vararg_count ret;
  return ret;
];

[ glk_request_hyperlink_event _vararg_count ret;
! glk_request_hyperlink_event (win)
  ! And now the @glk call
  @glk 258 _vararg_count ret;
  return ret;
];

[ glk_cancel_hyperlink_event _vararg_count ret;
! glk_cancel_hyperlink_event (win)
  ! And now the @glk call
  @glk 259 _vararg_count ret;
  return ret;
];

#ENDIF;
#ENDIF;
! End of infglk.h inclusion

#IFDEF TARGET_GLULX;
Array I7_FigureFlags->(1+4);
#ENDIF;

[ I7_DisplayFigure resource_ID one_time;
#IFDEF TARGET_ZCODE;
! Do nothing if on the V5 or V8 Z-machine, but still compile and run
#IFTRUE #version_number == 6;
	print "V6: picture ", resource_ID, " here.^";
	@draw_picture resource_ID;
#ENDIF; ! Z-machine version 6
#IFNOT; ! Glulx, then:
	if (one_time) {
		if (I7_FigureFlags->resource_ID) return;
	}
	I7_FigureFlags->resource_ID = true;
	if (glk_gestalt(gestalt_Graphics, 0)) {
		glk_image_draw(gg_mainwin, resource_ID, imagealign_InlineCenter, 0);
	} else {
		print "[Picture number ", resource_ID, " here.]^";
	}
#ENDIF; ! TARGET_
];

! End of Figures.i6


[ I7_char_to_digit c n;
	n = c-'0';
	if ((n<0) || (n>9)) return -1;
	return n;
];

[ I7_Match test snippet w1 wlen i j;
	w1 = snippet/100; wlen = snippet%100;
	for (i=w1, j=wlen: j>0: i++, j--) {
		if (((test)(i, 0)) ~= GPR_FAIL) return i*100+wn-i;
	}
	rfalse;
];

[ I7_ParseToken x y;
	if (wn>WordCount()) return GPR_FAIL;
	return ParseToken(x,y);
];

[ I7_SeedRNG n; ! Seed the random number generator
	#ifdef TARGET_ZCODE;
	if (n > 0) n = -n;
	@random n -> n;
	#ifnot; ! TARGET_GLULX
	@setrandom n;
	#endif; ! TARGET_
];

[ I7_SceneChange chs sc ch;
  if (scene_status-->0 == 1) {
      if ((  (deadflag~=0)  )) { ch++;
          if (debug_scenes) print "[Scene 'Entire Game' ends]^";
          scene_status-->0 = 0; ProcessRulebook(34);
          scene_ended-->0 = the_time;
          scene_endings-->0 = (scene_endings-->0)|2;
          scene_latest_ending-->0 = 1;
      jump CScene; }
  }
  if (scene_status-->0 == 0) {
      if ((  (deadflag==0)  )) { ch++;
          if (debug_scenes) print "[Scene 'Entire Game' begins]^";
          scene_status-->0 = 1; ProcessRulebook(33);
          scene_started-->0 = the_time;
          scene_endings-->0 = (scene_endings-->0)|1;
          scene_latest_ending-->0 = 0;
      jump CScene; }
  }
  .CScene;
  if (chs>10) ">--> The scene change machinery is stuck.";

  if (ch>0) I7_SceneChange(++chs);

];


#IFDEF DEBUG;
[ I7_SceneStatus chs sc ch;
  if (scene_status-->0 == 1) {
      print "Scene 'Entire Game' playing (for ", the_time-(scene_started-->0), " mins now)^";
  } else {
      if (scene_latest_ending-->0 > 0) {
          print "Scene 'Entire Game' ended ";
          print "^";
      }
  }
];


#ENDIF;
Constant BR_0 = R_14;
Constant BR_1 = R_23;
Constant BR_2 = R_24;
Constant BR_3 = R_25;
Constant BR_4 = R_26;
Constant BR_5 = R_27;
Constant BR_6 = R_28;
Constant BR_7 = R_29;
Constant BR_8 = R_30;
Constant BR_9 = R_31;
Constant BR_10 = R_32;
Constant BR_11 = R_33;
Constant BR_12 = R_34;
Constant BR_13 = R_35;
Constant BR_14 = R_36;
Constant BR_15 = R_37;
Constant BR_16 = R_38;
Constant BR_17 = R_39;
Constant BR_18 = R_40;
Constant BR_19 = R_41;
Constant BR_20 = R_42;
Constant BR_21 = R_43;
Constant BR_22 = R_44;
Constant BR_23 = R_45;
Constant BR_24 = R_46;
Constant BR_25 = R_47;
Constant BR_26 = R_48;
Constant BR_27 = R_49;
Constant BR_28 = R_50;
Constant BR_29 = R_51;
Constant BR_30 = R_52;
Constant BR_31 = R_53;
Constant BR_32 = R_54;
Constant BR_33 = R_55;
Constant BR_34 = R_56;
Constant BR_35 = R_57;
Constant BR_36 = R_58;
Constant BR_37 = R_59;
Constant BR_38 = R_60;
Constant BR_39 = R_61;
Constant BR_40 = R_62;
Constant BR_41 = R_63;
Constant BR_42 = R_64;
Constant BR_43 = R_65;
Constant BR_44 = R_66;
Constant BR_45 = R_67;
Constant BR_46 = R_68;
Constant BR_47 = R_69;
Constant BR_48 = R_70;
Constant BR_49 = R_71;
Constant BR_50 = R_72;
Constant BR_51 = R_73;
Constant BR_52 = R_74;
Constant BR_53 = R_75;
Constant BR_54 = R_76;
Constant BR_55 = R_77;
Constant BR_56 = R_78;
Constant BR_57 = R_79;
Constant BR_58 = R_80;
Constant BR_59 = R_81;
Constant BR_60 = R_82;
Constant BR_61 = R_83;
Constant BR_62 = R_84;
Constant BR_63 = R_85;
Constant BR_64 = R_86;
Constant BR_65 = R_87;
Constant BR_66 = R_88;
Constant BR_67 = R_89;
Constant BR_68 = R_90;
Constant BR_69 = R_91;
Constant BR_70 = R_92;
Constant BR_71 = R_93;
Constant BR_72 = R_94;
Constant BR_73 = R_95;
Constant BR_74 = R_96;
Constant BR_75 = R_97;
Constant BR_76 = R_98;
Constant BR_77 = R_100;
Constant BR_78 = R_101;
Constant BR_79 = R_102;
Constant BR_80 = R_103;
Constant BR_81 = R_104;
Constant BR_82 = R_105;
Constant BR_83 = R_106;
Constant BR_84 = R_107;
Constant BR_85 = R_108;
Constant BR_86 = R_109;
Constant BR_87 = R_110;
Constant BR_88 = R_111;
Constant BR_89 = R_112;
Constant BR_90 = R_113;
Constant BR_91 = R_114;
Constant BR_92 = R_115;
Constant BR_93 = R_116;
Constant BR_94 = R_117;
Constant BR_95 = R_118;
Constant BR_96 = R_119;
Constant BR_97 = R_120;
Constant BR_98 = R_121;
Constant BR_99 = R_122;
Constant BR_100 = R_123;
Constant BR_101 = R_124;
Constant BR_102 = R_125;
Constant BR_103 = R_126;
Constant BR_104 = R_127;
Constant BR_105 = R_128;
Constant BR_106 = R_129;
Constant BR_107 = R_130;
Constant BR_108 = R_131;
Constant BR_109 = R_132;
Constant BR_110 = R_133;
Constant BR_111 = R_134;
Constant BR_112 = R_135;
Constant BR_113 = R_136;
Constant BR_114 = R_137;
Constant BR_115 = R_138;
Constant BR_116 = R_139;
Constant BR_117 = R_140;
Constant BR_118 = R_141;
Constant BR_119 = R_142;
Constant BR_120 = R_143;
Constant BR_121 = R_144;
Constant BR_122 = R_145;
Constant BR_123 = R_146;
Constant BR_124 = R_147;
Constant BR_125 = R_148;
Constant BR_126 = R_149;
Constant BR_127 = R_150;
Constant BR_128 = R_151;
Constant BR_129 = R_152;
Constant BR_130 = R_153;
Constant BR_131 = R_154;
Constant BR_132 = R_155;
Constant BR_133 = R_156;
Constant BR_134 = R_157;
Constant BR_135 = R_158;
Constant BR_136 = R_159;
Constant BR_137 = R_160;
Constant BR_138 = R_161;
Constant BR_139 = R_162;
Constant BR_140 = R_163;
Constant BR_141 = R_164;
Constant BR_142 = R_165;
Constant BR_143 = R_166;
Constant BR_144 = R_167;
Constant BR_145 = R_168;
Constant BR_146 = R_169;
Constant BR_147 = R_170;
Constant BR_148 = R_171;
Constant BR_149 = R_172;
Constant BR_150 = R_173;
Constant BR_151 = R_174;
Constant BR_152 = R_175;
Constant BR_153 = R_176;
Constant BR_154 = R_177;
Constant BR_155 = R_178;
Constant BR_156 = R_179;
Constant BR_157 = R_180;
Constant BR_158 = R_181;
Constant BR_159 = R_182;
Constant BR_160 = R_183;
Constant BR_161 = R_184;
Constant BR_162 = R_185;
Constant BR_163 = R_186;
Constant BR_164 = R_187;
Constant BR_165 = R_188;
Constant BR_166 = R_189;
Constant BR_167 = R_190;
Constant BR_168 = R_191;
Constant BR_169 = R_192;
Constant BR_170 = R_193;
Constant BR_171 = R_194;
Constant BR_172 = R_195;
Constant BR_173 = R_196;
Constant BR_174 = R_197;
Constant BR_175 = R_198;
Constant BR_176 = R_199;
Constant BR_177 = R_200;
Constant BR_178 = R_201;
Constant BR_179 = R_202;
Constant BR_180 = R_203;
Constant BR_181 = R_204;
Constant BR_182 = R_205;
Constant BR_183 = R_206;
Constant BR_184 = R_207;
Constant BR_185 = R_208;
Constant BR_186 = R_209;
Constant BR_187 = R_210;
Constant BR_188 = R_211;
Constant BR_189 = R_212;
Constant BR_190 = R_213;
Constant BR_191 = R_214;
Constant BR_192 = R_215;
Constant BR_193 = R_216;
Constant BR_194 = R_217;
Constant BR_195 = R_218;
Constant BR_196 = R_219;
Constant BR_197 = R_220;
Constant BR_198 = R_221;
Constant BR_199 = R_222;
Constant BR_200 = R_223;
Constant BR_201 = R_224;
Constant BR_202 = R_225;
Constant BR_203 = R_226;
Constant BR_204 = R_227;
Constant BR_205 = R_228;
Constant BR_206 = R_229;
Constant BR_207 = R_230;
Constant BR_208 = R_231;
Constant BR_209 = R_232;
Constant BR_210 = R_233;
Constant BR_211 = R_234;
Constant BR_212 = R_235;
Constant BR_213 = R_236;
Constant BR_214 = R_237;
Constant BR_641 = R_34;


! Tables.i6 segment

! A table T is represented by a "table" array: T-->0 holds the
! number of columns and T-->i is the address of column number i.
! Columns are therefore numbered from 1 to T-->0, but they are also
! identified by an ID number of 100 or more, with each different
! column name having its own ID number. Each column C is also a
! "table" array, with C-->1 holding the unique ID number for the
! column's name, and C-->2 up to C-->(C-->0) holding the entries.
! Except that C-->1 also contains two upper bit flags:

Constant I7_COLUMN_NUMBER $0fff;
Constant I7_COLUMN_SIGNED $4000;
Constant I7_COLUMN_TOPIC $2000;
Constant I7_COLUMN_DONTSORTME $1000;

Array T_empty_table --> 0 0;

[ TableFindCol tab col f i j n;
	j = tab-->0;
	for (i=1:i<=j:i++)
		if (col == ((tab-->i)-->1) & I7_COLUMN_NUMBER) return i;
	if (f) return RunTimeProblem(RTP_TABLE_NOCOL, tab);
	return 0;
];

! The columns in a table can be assumed all to have the same
! height (i.e., number of rows): thus the number of rows in T
! can be calculated as (T-->1)-->0 - 1.

[ TableRows tab; return ((tab-->1)-->0)-1; ];

! The following dummy value is invalid for most types and unlikely
! in the others, so is used to represent an empty cell.

#ifdef TARGET_ZCODE;
Constant I7_TABLE_NOVALUE $7fe3;
#ifnot; ! TARGET_GLULX
Constant I7_TABLE_NOVALUE $deadce11;
#endif; ! TARGET_

! TableRowCorr(T, C, V) returns the first row on which value V
! appears in column C of table T, or prints an error if it doesn't.

[ TableRowCorr tab lookup_col lookup_value i j;
	if (lookup_col >= 100) lookup_col=TableFindCol(tab, lookup_col, true);
	lookup_col = tab-->lookup_col;
	j = lookup_col-->0;
	for (i=2:i<=j:i++)
		if (lookup_col-->i == lookup_value) return i-1;
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

! ExistsTableRowCorr(T, C, V) returns the first row on which V
! appears in column C of table T, or 0 if V does not occur at all.

[ ExistsTableRowCorr tab col entry i k v f a b;
	if (col >= 100) col=TableFindCol(tab, col);
	f = ((tab-->col)-->1) & I7_COLUMN_TOPIC;
	if (col == 0) rfalse;
	k = ((tab-->1)-->0)-1;
	for (i=1:i<=k:i++) {
	! print "Checking row ", i, "^";
		v = (tab-->col)-->(i+1);
		if (v == I7_TABLE_NOVALUE) continue;
		if (f) {
			if ((entry >= 256) && (entry == consult_from + 256*consult_words)) {
				a = consult_from; b = consult_words;
			} else {
				a = entry/100; b = entry%100;
			}
			! print "a,b = ", a, ",", b, "^";
		    if ((v)(a, b) ~= GPR_FAIL)
				  return i;
		} else {
		    if (v == entry) return i;
		}
	}
	! print "Giving up^";
	return 0;
];

! TableLookUpCorr(T, C1, C2, V) finds the first row on which value
! V appears in column C2, and returns the corresponding value in C1,
! or prints an error if the value V cannot be found or has no
! corresponding value in C1.

[ TableLookUpCorr tab col lookup_col lookup_value write_flag write_value i j v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	if (lookup_col >= 100) lookup_col=TableFindCol(tab, lookup_col, true);
	col = tab-->col;
	lookup_col = tab-->lookup_col;
	j = lookup_col-->0;
	for (i=2:i<=j:i++)
		if (lookup_col-->i == lookup_value) {
		    if (write_flag) { col-->i = write_value; rfalse; }
			v = col-->i;
			if (v ~= I7_TABLE_NOVALUE) return v;
		}
	return RunTimeProblem(RTP_TABLE_NOCORR, tab);
];

! ExistsTableLookUpCorr(T, C1, C2, V) returns true if the operation
! TableLookUpCorr(T, C1, C2, V) can be done, false otherwise.

[ ExistsTableLookUpCorr tab col lookup_col lookup_value i j;
	if (col >= 100) col=TableFindCol(tab, col, false);
	if (lookup_col >= 100) lookup_col=TableFindCol(tab, lookup_col, false);
	if (col*lookup_col == 0) rfalse;
	col = tab-->col; lookup_col = tab-->lookup_col;
	j = lookup_col-->0;
	for (i=2:i<=j:i++)
		if ((lookup_col-->i == lookup_value)
		    && (col-->i ~= I7_TABLE_NOVALUE)) rtrue;
	rfalse;
];

! TableLookUpEntry(T, C, R) returns the value at column C, row R,
! printing an error if that doesn't exist.

[ TableLookUpEntry tab col index write_flag write_value v;
	if (col >= 100) col=TableFindCol(tab, col, true);
	if ((index < 1) || (index > (((tab-->col)-->0)-1)))
		return RunTimeProblem(RTP_TABLE_NOROW, tab, index);
	if (write_flag) {
		switch(write_flag) {
			1: (tab-->col)-->(index+1) = write_value;
			2: (tab-->col)-->(index+1) = ((tab-->col)-->(index+1)) + write_value;
			3: (tab-->col)-->(index+1) = ((tab-->col)-->(index+1)) - write_value;
		}
		rfalse;
	}
	v = ((tab-->col)-->(index+1));
	if (v == I7_TABLE_NOVALUE)
		return RunTimeProblem(RTP_TABLE_NOENTRY, tab, col, 0, index);
	return v;
];

! ExistsTableLookUpEntry(T, C, R) returns true if a value exists
! at column C, row R, false otherwise.

[ ExistsTableLookUpEntry tab col index v;
	if (col >= 100) col=TableFindCol(tab, col);
	if (col == 0) rfalse;
	if ((index<1) || (index > (((tab-->col)-->0)-1))) rfalse;
	v = ((tab-->col)-->(index+1));
	if (v == I7_TABLE_NOVALUE) rfalse;
	rtrue;
];

! TableRowIsBlank(T, R) returns true if row R of table T is blank.
! (R must be a legal row number.)

[ TableRowIsBlank tab j k;
	for (k=1:k<=tab-->0:k++)
	  if (((tab-->k)-->(j+1)) ~= I7_TABLE_NOVALUE) rfalse;
	rtrue;
];

! TableBlankOutRow(T, R) fills row R of table T with blanks.
! (R must be a legal row number.)

[ TableBlankOutRow tab j k;
	if (tab==0) return RunTimeProblem(RTP_TABLE_NOTABLE, tab);
	for (k=1:k<=tab-->0:k++) (tab-->k)-->(j+1) = I7_TABLE_NOVALUE;
];

! TableBlankRows(T) returns the number of blank rows in T.

[ TableBlankRows tab i j c;
	i = TableRows(tab); !print i, " rows^";
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) c++;
	!print c, " blank^";
	return c;
];

! TableFilledRows(T) returns the number of non-blank rows in T.

[ TableFilledRows tab;
	return TableRows(tab) - TableBlankRows(tab);
];

! TableBlankRow(T) finds the first blank row in T.

[ TableBlankRow tab i j;
	i = TableRows(tab);
	for (j=1:j<=i:j++)
		if (TableRowIsBlank(tab, j)) return j;
	RunTimeProblem(RTP_TABLE_NOMOREBLANKS, tab);
	return i;
];

! TableRandomRow(T) chooses a random non-blank row in T.

[ TableRandomRow tab i j k;
	i = TableRows(tab);
	j = TableFilledRows(tab);
	if (j==0) return RunTimeProblem(RTP_TABLE_NOROWS, tab);
	if (j>1) j = random(j);
	for (k=1:k<=i:k++) {
		if (TableRowIsBlank(tab, k) == false) j--;
		if (j==0) return k;
	}
];

! TableSwapRows(T, R1, R2) exchanges rows R1 and R2.

[ TableSwapRows tab i j k l m;
	if (i==j) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		m = (tab-->k)-->(i+1);
		(tab-->k)-->(i+1) = (tab-->k)-->(j+1);
		(tab-->k)-->(j+1) = m;
	}
];

[ TableMoveRowDown tab r1 r2 rx k l m;
	if (r1==r2) return;
	l = tab-->0;
	for (k=1:k<=l:k++) {
		m = (tab-->k)-->(r1+1);
		for (rx=r1:rx<r2:rx++)
			(tab-->k)-->(rx+1) = (tab-->k)-->(rx+2);
		(tab-->k)-->(r2+1) = m;
	}
];

! TableShuffle(T) sorts T into random row order.

[ TableShuffle tab i j k;
	k = ((tab-->1)-->0)-1;
	for (i=2:i<=k:i++) TableSwapRows(tab, i, random(i));
];

! TableNextRow(T, C, R, D) is used when scanning through a
! table in order of the values in column C: ascending order
! if D = 1, descending if D = -1. The current position is row R
! of column C, or R=0 if we have not yet found the first row.
! The return value is the row number for the next value, or 0
! if we are already at the final value. Note that if there
! are several equal values in the column, they will be run
! through in turn, in order of their physical row numbers -
! ascending if D = 1, descending if D = -1, so that using
! the routine with D = -1 always produces the exact reverse
! ordering from using it with D = 1 and the same parameters.
! Rows with blank entries in C are skipped.
!
! for (R=TableNextRow(T,C,0,D): R : R=TableNextRow(T,C,R,D)) ...
! will perform a loop of valid row numbers in order of column C.

[ TableNextRow tab col row dir i k val v dv min_dv min_at signed_arithmetic f;
	if (col >= 100) col=TableFindCol(tab, col, false);
	signed_arithmetic = ((tab-->col)-->1) & I7_COLUMN_SIGNED;
	#ifdef TARGET_ZCODE;
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $8000; else val = $7fff;
		} else {
		    if (dir == 1) val = 0; else val = $ffff;
		}
	} else val = (tab-->col)-->(row+1);
	if (signed_arithmetic) min_dv = $7fff; else min_dv = $ffff;
	#ifnot; ! TARGET_GLULX
	if (row == 0) {
		if (signed_arithmetic) {
		    if (dir == 1) val = $80000000; else val = $7fffffff;
		} else {
		    if (dir == 1) val = 0; else val = $ffffffff;
		}
	} else val = (tab-->col)-->(row+1);
	if (signed_arithmetic) min_dv = $7fffffff; else min_dv = $ffffffff;
	#endif; ! TARGET_
	k = ((tab-->1)-->0)-1;
	if (dir == 1) {
		for (i=1:i<=k:i++) {
		    v = (tab-->col)-->(i+1);
		    if (v == I7_TABLE_NOVALUE) continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i>row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i>row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	} else {
		for (i=k:i>=1:i--) {
		    v = (tab-->col)-->(i+1);
		    if (v == I7_TABLE_NOVALUE) continue;
		    dv = dir*v;
		    if (signed_arithmetic)
		    f = (((dv > dir*val) || ((v == val) && (i<row))) &&
				  (dv < min_dv));
		    else
		    f = (((UnsignedCompare(dv, dir*val) > 0) || ((v == val) && (i<row))) &&
				  (UnsignedCompare(dv, min_dv) < 0));
		    if (f) { min_dv = dv; min_at = i; }
		}
	}
	return min_at;
];

! TableCompareRows(T, C, R1, R2, D) returns:
! +1 if the entry at row R1 of column C is > the entry at row R2,
! 0 if they are equal, and
! -1 if entry at R1 < entry at R2.
! When D = +1, a blank value is > all other values, so that in
! an ascending sort the blanks come last; when D = -1, a blank
! value is < all others, so that once again blanks are last.
! Finally, a wholly blank row is always placed after a row in
! which the entry in C is blank but where other entries are not.

[ TableCompareRows tab col row1 row2 dir val1 val2;
	if (col >= 100) col=TableFindCol(tab, col, false);
	val1 = (tab-->col)-->(row1+1);
	val2 = (tab-->col)-->(row2+1);
	if (val1 == val2) {
		if (val1 ~= I7_TABLE_NOVALUE) return 0;
		if (TableRowIsBlank(tab, row1)) {
		    if (TableRowIsBlank(tab, row2)) return 0;
		    return -1*dir;
		}
		if (TableRowIsBlank(tab, row2)) return dir;
		return 0;
	}
	if (val1 == I7_TABLE_NOVALUE) return -1*dir;
	if (val2 == I7_TABLE_NOVALUE) return dir;
	if (((tab-->col)-->1) & I7_COLUMN_SIGNED) {
		if (val1 > val2) return 1;
		return -1;
	} else {
		if (UnsignedCompare(val1, val2) > 0) return 1;
		return -1;
	}
];

[ TableMoveBlanksToBack tab fromrow torow i fbl lnbl blc;
	if (torow<fromrow) return;
	fbl = 0; lnbl = 0;
	for (i=fromrow:i<=torow:i++)
		if (TableRowIsBlank(tab, i)) {
			if (fbl == -1) fbl = i;
			blc++;
		} else {
			lnbl = i;
		}
	if ((fbl>0) && (lnbl>0) && (fbl < lnbl)) {
		TableMoveRowDown(tab, fbl, lnbl); ! Move first blank just past last nonblank
		TableMoveBlanksToBack(tab, fbl+1, lnbl-1);
	}
	return torow-blc; ! Final non-blank row
];

[ TableSort tab col dir i j k f;
	for (i=1:i<=tab-->0:i++) {
		j = tab-->i; ! Address of column table
		if ((j-->1) & I7_COLUMN_DONTSORTME)
		    return RunTimeProblem(RTP_TABLE_CANTSORT, tab);
	}
	if (col >= 100) col=TableFindCol(tab, col, false);
	k = TableRows(tab);
	k = TableMoveBlanksToBack(tab, 1, k);
	f = true;
	while (f) {
		f = false;
		for (i=1:i<=k:i++)
		    for (j=i+1:j<=k:j++)
				  if (dir*TableCompareRows(tab, col, i, j, dir) > 0) {
						TableSwapRows(tab, i, j); f = true; break;
				  }
	}
];

#ifdef I7_RANKING_TABLE;
[ PrintRank i j v;
	print ", earning you the rank of ";
	j = TableRows(I7_RANKING_TABLE);
	for (i=j:i>=1:i--)
		if (score >= TableLookUpEntry(I7_RANKING_TABLE, 1, i)) {
		    v = TableLookUpEntry(I7_RANKING_TABLE, 2, i);
		    if (v ofclass String) print (string) v;
		    else v();
		    ".";
		}
	".";
];
#endif;

! End of Tables.i6


[ Adj_0 t_0 ct_0 ct_1; ! meaning of "adjacent"
  if (((t_0 ofclass K1_room))) return (((I7_Adjacent(real_location,t_0))));
  rfalse; ];

[ Adj_1 t_0 ct_0 ct_1; ! meaning of "visible"
  if (((t_0 ofclass K2_thing))) return (((I7_CanSee(player,t_0))));
  rfalse; ];

[ Adj_2 t_0 ct_0 ct_1; ! meaning of "touchable"
  if (((t_0 ofclass K2_thing))) return (((I7_CanTouch(player,t_0))));
  rfalse; ];

[ Adj_3 t_0 ct_0 ct_1; ! meaning of "invisible"
  if (((t_0 ofclass K2_thing))) return ((~~((I7_CanSee(player,t_0)))));
  rfalse; ];

[ Adj_4 t_0 ct_0 ct_1; ! meaning of "untouchable"
  if (((t_0 ofclass K2_thing))) return ((~~((I7_CanTouch(player,t_0)))));
  rfalse; ];

[ Adj_5 t_0 ct_0 ct_1; ! meaning of "concealed"
  if (((t_0 ofclass K2_thing))) return (((I7_Conceals(  (I7_Holder(t_0))  ,t_0))));
  rfalse; ];

[ Adj_6 t_0 ct_0 ct_1; ! meaning of "unconcealed"
  if (((t_0 ofclass K2_thing))) return ((~~((I7_Conceals(  (I7_Holder(t_0))  ,t_0)))));
  rfalse; ];

[ Adj_7 t_0 ct_0 ct_1; ! meaning of "on-stage"
  if (((t_0 ofclass K2_thing))) return ((  (I7_OnStage(t_0))  ));
  rfalse; ];

[ Adj_8 t_0 ct_0 ct_1; ! meaning of "off-stage"
  if (((t_0 ofclass K2_thing))) return ((  (I7_OnStage(t_0)==false)  ));
  rfalse; ];



[ MistakeActionSub;
  switch(I7_mistake_code) {
    default: "I didn't understand that sentence.";
  }
];



[ text_routine_0 say__c;
  say__c=0; say__p=1;  print (I7_string) SC_79;    print (PrintTimeOfDay) the_time;    print (I7_string) SC_14;   .L_Say93;
  rtrue;
];








Constant ActionCount = 81;
Array ActionData table
  ##Inv                               $$00000000  58 58 "taking inventory" I6_NULL I6_NULL I6_NULL I6_NULL  0 20000
  ##Take                              $$00001001  58 58 "taking" DA_Name I6_NULL I6_NULL I6_NULL  ANSTVC_1 20001
  ##Remove                            $$00011011  58 58 "removing" DA_Name "from" DA_Name I6_NULL  0 20002
  ##Drop                              $$00001001  58 58 "dropping" DA_Name I6_NULL I6_NULL I6_NULL  0 20003
  ##PutOn                             $$00011011  58 58 "putting" DA_Name "on" DA_Name I6_NULL  0 20004
  ##Insert                            $$00011011  58 58 "inserting" DA_Name "into" DA_Name I6_NULL  0 20005
  ##Eat                               $$01001001  58 58 "eating" DA_Name I6_NULL I6_NULL I6_NULL  0 20006
  ##Go                                $$00001000  58 58 "going" DA_Name I6_NULL I6_NULL I6_NULL  ANSTVC_7 20007
  ##Enter                             $$00001001  58 58 "entering" DA_Name I6_NULL I6_NULL I6_NULL  0 20008
  ##Exit                              $$00000000  58 58 "exiting" I6_NULL I6_NULL I6_NULL I6_NULL  ANSTVC_9 20009
  ##GetOff                            $$00001001  58 58 "getting off" DA_Name I6_NULL I6_NULL I6_NULL  0 20010
  ##Look                              $$00000000  58 58 "looking" I6_NULL I6_NULL I6_NULL I6_NULL  ANSTVC_11 20011
  ##Examine                           $$00001100  58 58 "examining" DA_Name I6_NULL I6_NULL I6_NULL  0 20012
  ##LookUnder                         $$00001100  58 58 "looking under" DA_Name I6_NULL I6_NULL I6_NULL  0 20013
  ##Search                            $$00001101  58 58 "searching" DA_Name I6_NULL I6_NULL I6_NULL  0 20014
  ##Consult                           $$00011001  58 73 "consulting" DA_Name "about" DA_Topic I6_NULL  0 20015
  ##Lock                              $$10011011  58 58 "locking" DA_Name "with" DA_Name I6_NULL  0 20016
  ##Unlock                            $$10011011  58 58 "unlocking" DA_Name "with" DA_Name I6_NULL  0 20017
  ##SwitchOn                          $$00001001  58 58 "switching on" DA_Name I6_NULL I6_NULL I6_NULL  0 20018
  ##SwitchOff                         $$00001001  58 58 "switching off" DA_Name I6_NULL I6_NULL I6_NULL  0 20019
  ##Open                              $$00001001  58 58 "opening" DA_Name I6_NULL I6_NULL I6_NULL  0 20020
  ##Close                             $$00001001  58 58 "closing" DA_Name I6_NULL I6_NULL I6_NULL  0 20021
  ##Wear                              $$01001001  58 58 "wearing" DA_Name I6_NULL I6_NULL I6_NULL  0 20022
  ##Disrobe                           $$01001001  58 58 "taking off" DA_Name I6_NULL I6_NULL I6_NULL  0 20023
  ##Give                              $$01011011  58 58 "giving" DA_Name "to" DA_Name I6_NULL  0 20024
  ##Show                              $$01011001  58 58 "showing" DA_Name "to" DA_Name I6_NULL  0 20025
  ##WakeOther                         $$00001001  58 58 "waking" DA_Name I6_NULL I6_NULL I6_NULL  0 20026
  ##ThrowAt                           $$01011001  58 58 "throwing" DA_Name "at" DA_Name I6_NULL  0 20027
  ##Attack                            $$00001001  58 58 "attacking" DA_Name I6_NULL I6_NULL I6_NULL  0 20028
  ##Kiss                              $$00001001  58 58 "kissing" DA_Name I6_NULL I6_NULL I6_NULL  0 20029
  ##Answer                            $$00011001  58 73 "answering" DA_Name "that" DA_Topic I6_NULL  0 20030
  ##Tell                              $$00011001  58 73 "telling" DA_Name "about" DA_Topic I6_NULL  0 20031
  ##Ask                               $$00011001  58 73 "asking" DA_Name "about" DA_Topic I6_NULL  0 20032
  ##AskFor                            $$00011011  58 58 "asking" DA_Name "for" DA_Name I6_NULL  0 20033
  ##Wait                              $$00000000  58 58 "waiting" I6_NULL I6_NULL I6_NULL I6_NULL  0 20034
  ##Touch                             $$00001001  58 58 "touching" DA_Name I6_NULL I6_NULL I6_NULL  0 20035
  ##Wave                              $$00001001  58 58 "waving" DA_Name I6_NULL I6_NULL I6_NULL  0 20036
  ##Pull                              $$00001001  58 58 "pulling" DA_Name I6_NULL I6_NULL I6_NULL  0 20037
  ##Push                              $$00001001  58 58 "pushing" DA_Name I6_NULL I6_NULL I6_NULL  0 20038
  ##Turn                              $$00001001  58 58 "turning" DA_Name I6_NULL I6_NULL I6_NULL  0 20039
  ##PushDir                           $$00011011  58 58 "pushing" DA_Name "to" DA_Name I6_NULL  0 20040
  ##Squeeze                           $$00001001  58 58 "squeezing" DA_Name I6_NULL I6_NULL I6_NULL  0 20041
  ##Yes                               $$00000000  58 58 "saying yes" I6_NULL I6_NULL I6_NULL I6_NULL  0 20042
  ##No                                $$00000000  58 58 "saying no" I6_NULL I6_NULL I6_NULL I6_NULL  0 20043
  ##Burn                              $$00001001  58 58 "burning" DA_Name I6_NULL I6_NULL I6_NULL  0 20044
  ##Wake                              $$00000000  58 58 "waking up" I6_NULL I6_NULL I6_NULL I6_NULL  0 20045
  ##Think                             $$00000000  58 58 "thinking" I6_NULL I6_NULL I6_NULL I6_NULL  0 20046
  ##Smell                             $$00001001  58 58 "smelling" DA_Name I6_NULL I6_NULL I6_NULL  0 20047
  ##Listen                            $$00001001  58 58 "listening to" DA_Name I6_NULL I6_NULL I6_NULL  0 20048
  ##Taste                             $$00001001  58 58 "tasting" DA_Name I6_NULL I6_NULL I6_NULL  0 20049
  ##Cut                               $$00001001  58 58 "cutting" DA_Name I6_NULL I6_NULL I6_NULL  0 20050
  ##Jump                              $$00000000  58 58 "jumping" I6_NULL I6_NULL I6_NULL I6_NULL  0 20051
  ##Tie                               $$00011011  58 58 "tying" DA_Name "to" DA_Name I6_NULL  0 20052
  ##Drink                             $$00001001  58 58 "drinking" DA_Name I6_NULL I6_NULL I6_NULL  0 20053
  ##Sorry                             $$00000000  58 58 "saying sorry" I6_NULL I6_NULL I6_NULL I6_NULL  0 20054
  ##Strong                            $$00000000  58 58 "swearing obscenely" I6_NULL I6_NULL I6_NULL I6_NULL  0 20055
  ##Mild                              $$00000000  58 58 "swearing mildly" I6_NULL I6_NULL I6_NULL I6_NULL  0 20056
  ##Swing                             $$00001001  58 58 "swinging" DA_Name I6_NULL I6_NULL I6_NULL  0 20057
  ##Rub                               $$00001001  58 58 "rubbing" DA_Name I6_NULL I6_NULL I6_NULL  0 20058
  ##SetTo                             $$00011001  58 73 "setting" DA_Name "to" DA_Topic I6_NULL  0 20059
  ##WaveHands                         $$00000000  58 58 "waving hands" I6_NULL I6_NULL I6_NULL I6_NULL  0 20060
  ##Buy                               $$00001001  58 58 "buying" DA_Name I6_NULL I6_NULL I6_NULL  0 20061
  ##Sing                              $$00000000  58 58 "singing" I6_NULL I6_NULL I6_NULL I6_NULL  0 20062
  ##Climb                             $$00001001  58 58 "climbing" DA_Name I6_NULL I6_NULL I6_NULL  0 20063
  ##Sleep                             $$00000000  58 58 "sleeping" I6_NULL I6_NULL I6_NULL I6_NULL  0 20064
  ##Score                             $$00100000  58 58 "requesting the score" I6_NULL I6_NULL I6_NULL I6_NULL  0 20065
  ##Quit                              $$00100000  58 58 "quitting the game" I6_NULL I6_NULL I6_NULL I6_NULL  0 20066
  ##Save                              $$00100000  58 58 "saving the game" I6_NULL I6_NULL I6_NULL I6_NULL  0 20067
  ##Restore                           $$00100000  58 58 "restoring the game" I6_NULL I6_NULL I6_NULL I6_NULL  0 20068
  ##Restart                           $$00100000  58 58 "restarting the game" I6_NULL I6_NULL I6_NULL I6_NULL  0 20069
  ##Verify                            $$00100000  58 58 "verifying the story file" I6_NULL I6_NULL I6_NULL I6_NULL  0 20070
  ##Version                           $$00100000  58 58 "requesting the story file version" I6_NULL I6_NULL I6_NULL I6_NULL  0 20071
  ##ScriptOn                          $$00100000  58 58 "switching the story transcript on" I6_NULL I6_NULL I6_NULL I6_NULL  0 20072
  ##ScriptOff                         $$00100000  58 58 "switching the story transcript off" I6_NULL I6_NULL I6_NULL I6_NULL  0 20073
  ##LMode3                            $$00100000  58 58 "preferring abbreviated room descriptions" I6_NULL I6_NULL I6_NULL I6_NULL  0 20074
  ##LMode2                            $$00100000  58 58 "preferring unabbreviated room descriptions" I6_NULL I6_NULL I6_NULL I6_NULL  0 20075
  ##LMode1                            $$00100000  58 58 "preferring sometimes abbreviated room descriptions" I6_NULL I6_NULL I6_NULL I6_NULL  0 20076
  ##Pronouns                          $$00100000  58 58 "requesting the pronoun meanings" I6_NULL I6_NULL I6_NULL I6_NULL  0 20077
  ##NotifyOn                          $$00100000  58 58 "switching score notification on" I6_NULL I6_NULL I6_NULL I6_NULL  0 20078
  ##NotifyOff                         $$00100000  58 58 "switching score notification off" I6_NULL I6_NULL I6_NULL I6_NULL  0 20079
  ##A80_time_checking                 $$00000000  58 58 "time-checking" I6_NULL I6_NULL I6_NULL I6_NULL  0 20080
;
[ ANSTVC_1 X;
  MStack-->X = nothing; X++;
  return 1;
];
[ ANSTVC_7 X;
  MStack-->X = O99_bluff; X++;
  MStack-->X = nothing; X++;
  MStack-->X = nothing; X++;
  MStack-->X = nothing; X++;
  MStack-->X = nothing; X++;
  return 5;
];
[ ANSTVC_9 X;
  MStack-->X = nothing; X++;
  return 1;
];
[ ANSTVC_11 X;
  MStack-->X = ##Wait; X++;
  MStack-->X = 0; X++;
  MStack-->X = nothing; X++;
  return 3;
];

Array ActionCoding -->
    ##Inv ##Take ##Remove ##Drop ##PutOn ##Insert ##Eat ##Go
    ##Enter ##Exit ##GetOff ##Look ##Examine ##LookUnder ##Search ##Consult
    ##Lock ##Unlock ##SwitchOn ##SwitchOff ##Open ##Close ##Wear ##Disrobe
    ##Give ##Show ##WakeOther ##ThrowAt ##Attack ##Kiss ##Answer ##Tell
    ##Ask ##AskFor ##Wait ##Touch ##Wave ##Pull ##Push ##Turn
    ##PushDir ##Squeeze ##Yes ##No ##Burn ##Wake ##Think ##Smell
    ##Listen ##Taste ##Cut ##Jump ##Tie ##Drink ##Sorry ##Strong
    ##Mild ##Swing ##Rub ##SetTo ##WaveHands ##Buy ##Sing ##Climb
    ##Sleep ##Score ##Quit ##Save ##Restore ##Restart ##Verify ##Version
    ##ScriptOn ##ScriptOff ##LMode3 ##LMode2 ##LMode1 ##Pronouns ##NotifyOn ##NotifyOff
    ##A80_time_checking;


Array ActionHappened --> 0 0 0 0 0 0;


[ InvSub; return GenericVerbSub(113,114,115,1); ];
[ TakeSub; return GenericVerbSub(116,117,118,1); ];
[ RemoveSub; return GenericVerbSub(119,120,121,1); ];
[ DropSub; return GenericVerbSub(122,123,124,1); ];
[ PutOnSub; return GenericVerbSub(125,126,127,1); ];
[ InsertSub; return GenericVerbSub(128,129,130,1); ];
[ EatSub; return GenericVerbSub(131,132,133,1); ];
[ GoSub; return GenericVerbSub(134,135,136,1); ];
[ EnterSub; return GenericVerbSub(137,138,139,1); ];
[ ExitSub; return GenericVerbSub(140,141,142,1); ];
[ GetOffSub; return GenericVerbSub(143,144,145,1); ];
[ LookSub; return GenericVerbSub(146,147,148,1); ];
[ ExamineSub; return GenericVerbSub(149,150,151,1); ];
[ LookUnderSub; return GenericVerbSub(152,153,154,1); ];
[ SearchSub; return GenericVerbSub(155,156,157,1); ];
[ ConsultSub; return GenericVerbSub(158,159,160,1); ];
[ LockSub; return GenericVerbSub(161,162,163,1); ];
[ UnlockSub; return GenericVerbSub(164,165,166,1); ];
[ SwitchOnSub; return GenericVerbSub(167,168,169,1); ];
[ SwitchOffSub; return GenericVerbSub(170,171,172,1); ];
[ OpenSub; return GenericVerbSub(173,174,175,1); ];
[ CloseSub; return GenericVerbSub(176,177,178,1); ];
[ WearSub; return GenericVerbSub(179,180,181,1); ];
[ DisrobeSub; return GenericVerbSub(182,183,184,1); ];
[ GiveSub; return GenericVerbSub(185,186,187,1); ];
[ ShowSub; return GenericVerbSub(188,189,190,1); ];
[ WakeOtherSub; return GenericVerbSub(191,192,193,1); ];
[ ThrowAtSub; return GenericVerbSub(194,195,196,1); ];
[ AttackSub; return GenericVerbSub(197,198,199,1); ];
[ KissSub; return GenericVerbSub(200,201,202,1); ];
[ AnswerSub; return GenericVerbSub(203,204,205,1); ];
[ TellSub; return GenericVerbSub(206,207,208,1); ];
[ AskSub; return GenericVerbSub(209,210,211,1); ];
[ AskForSub; return GenericVerbSub(212,213,214,1); ];
[ WaitSub; return GenericVerbSub(215,216,217,1); ];
[ TouchSub; return GenericVerbSub(218,219,220,1); ];
[ WaveSub; return GenericVerbSub(221,222,223,1); ];
[ PullSub; return GenericVerbSub(224,225,226,1); ];
[ PushSub; return GenericVerbSub(227,228,229,1); ];
[ TurnSub; return GenericVerbSub(230,231,232,1); ];
[ PushDirSub; return GenericVerbSub(233,234,235,1); ];
[ SqueezeSub; return GenericVerbSub(236,237,238,1); ];
[ YesSub; return GenericVerbSub(239,240,241,1); ];
[ NoSub; return GenericVerbSub(242,243,244,1); ];
[ BurnSub; return GenericVerbSub(245,246,247,1); ];
[ WakeSub; return GenericVerbSub(248,249,250,1); ];
[ ThinkSub; return GenericVerbSub(251,252,253,1); ];
[ SmellSub; return GenericVerbSub(254,255,256,1); ];
[ ListenSub; return GenericVerbSub(257,258,259,1); ];
[ TasteSub; return GenericVerbSub(260,261,262,1); ];
[ CutSub; return GenericVerbSub(263,264,265,1); ];
[ JumpSub; return GenericVerbSub(266,267,268,1); ];
[ TieSub; return GenericVerbSub(269,270,271,1); ];
[ DrinkSub; return GenericVerbSub(272,273,274,1); ];
[ SorrySub; return GenericVerbSub(275,276,277,1); ];
[ StrongSub; return GenericVerbSub(278,279,280,1); ];
[ MildSub; return GenericVerbSub(281,282,283,1); ];
[ SwingSub; return GenericVerbSub(284,285,286,1); ];
[ RubSub; return GenericVerbSub(287,288,289,1); ];
[ SetToSub; return GenericVerbSub(290,291,292,1); ];
[ WaveHandsSub; return GenericVerbSub(293,294,295,1); ];
[ BuySub; return GenericVerbSub(296,297,298,1); ];
[ SingSub; return GenericVerbSub(299,300,301,1); ];
[ ClimbSub; return GenericVerbSub(302,303,304,1); ];
[ SleepSub; return GenericVerbSub(305,306,307,1); ];
[ ScoreSub; return GenericVerbSub(308,309,310,1); ];
[ QuitSub; return GenericVerbSub(311,312,313,1); ];
[ SaveSub; return GenericVerbSub(314,315,316,1); ];
[ RestoreSub; return GenericVerbSub(317,318,319,1); ];
[ RestartSub; return GenericVerbSub(320,321,322,1); ];
[ VerifySub; return GenericVerbSub(323,324,325,1); ];
[ VersionSub; return GenericVerbSub(326,327,328,1); ];
[ ScriptOnSub; return GenericVerbSub(329,330,331,1); ];
[ ScriptOffSub; return GenericVerbSub(332,333,334,1); ];
[ LMode3Sub; return GenericVerbSub(335,336,337,1); ];
[ LMode2Sub; return GenericVerbSub(338,339,340,1); ];
[ LMode1Sub; return GenericVerbSub(341,342,343,1); ];
[ PronounsSub; return GenericVerbSub(344,345,346,1); ];
[ NotifyOnSub; return GenericVerbSub(347,348,349,1); ];
[ NotifyOffSub; return GenericVerbSub(350,351,352,1); ];
[ A80_time_checkingSub; return GenericVerbSub(353,354,355,1); ];


! Verbs.i6 segment

[ AllowPushDir i oldrm newrm infl;
	if ((noun ofclass K2_thing) && (noun hasnt pushable))
		return L__M(##PushDir,1,noun);
	if (parent(second)~=compass) return L__M(##PushDir,2,noun);
	if (second==u_obj or d_obj)  return L__M(##PushDir,3,noun);
	AfterRoutines(); i=noun;
	if (actor notin noun) { move i to actor; infl = true; }
	move_pushing = i;
	oldrm = I7_RoomOf(noun);
	<Go second>;
	newrm = I7_RoomOf(actor);
	move_pushing = nothing; move i to newrm;
	if (newrm ~= oldrm) {
		if (IndirectHolder(i, player)) I7_TryAction(0, player, ##Look, 0, 0);
		RulebookSucceeds();
	} else RulebookFails();
];

Global GVS_converted = -1;
[ GVS_Convert ac n s;
	GVS_converted = InformLibrary.begin_action(ac, n, s);
	rtrue;
];
[ GenericVerbSub ch co re any vis rv;
	@push GVS_converted;
	GVS_converted = -1;
	if (actor ~= player) {
		if (act_requester) {
			act_requester = nothing;
			if (ActionPrimitive() == false) {
				if (ProcessRulebook(UNABLE_RB) == false) {
					print (The) actor, " ", (IsOrAre) actor, " unable to do that.^^";
				}
		  }
			jump HappyEnding;
		}
		vis = I7_CanSee(player, actor);
		if ((noun ofclass K2_thing) && (~~(noun ofclass K7_backdrop)))
			vis = vis || (I7_CanSee(player, noun));
		if ((second ofclass K2_thing) && (~~(second ofclass K7_backdrop)))
			vis = vis || (I7_CanSee(player, second));
		if (rv=ProcessRulebook(GENERIC_CHECK_RB)) jump FailsUnlessConverted;
		if (any && (rv=ProcessRulebook(ch))) jump FailsUnlessConverted;
		if (ProcessRulebook(GENERIC_CARRYOUT_RB) == 0)
			if (any) ProcessRulebook(co);
		if (rv=ProcessRulebook(AFTER_RB)) jump HappyEnding;
		vis = vis || (I7_CanSee(player, actor));
		if ((noun ofclass K2_thing) && (~~(noun ofclass K7_backdrop)))
			vis = vis || (I7_CanSee(player, noun));
		if ((second ofclass K2_thing) && (~~(second ofclass K7_backdrop)))
			vis = vis || (I7_CanSee(player, second));
		if (keep_silent || (vis==false)) jump HappyEnding;
		if (rv=ProcessRulebook(GENERIC_REPORT_RB)) jump HappyEnding;
		if (any) rv=ProcessRulebook(re);
		jump HappyEnding;
	}
	if ((rv=ProcessRulebook(GENERIC_CHECK_RB)) || (rv=ProcessRulebook(ch)))
		jump FailsUnlessConverted;
	if (ProcessRulebook(GENERIC_CARRYOUT_RB) == 0) ProcessRulebook(co);
	if (meta) say__p = 0;
	if (rv=ProcessRulebook(AFTER_RB)) jump HappyEnding;
	if (keep_silent) jump HappyEnding;
	if (rv=ProcessRulebook(GENERIC_REPORT_RB)) jump HappyEnding;
	rv=ProcessRulebook(re);
	.HappyEnding;
	ActRulebookSucceeds(rv);
	@pull GVS_converted;
	rtrue;
	.FailsUnlessConverted;
	if (GVS_converted == 1) jump HappyEnding;
	ActRulebookFails(rv);
	@pull GVS_converted;
	rtrue;
];

[ GL__M a b c; if ((actor ~= player) || (untouchable_silence)) rtrue;
	return L__M(a,b,c); ];
[ HisHerTheir o; if (o has pluralname) { print "their"; return; }
	if (o has female) { print "her"; return; }
	print "his"; ];

! Object movements

Global ac_common_ancestor;
Global take_after_recipient;
[ TakeSub_C1;
	if (onotheld_mode==1 && noun in actor) {
		RulebookSucceeds(); rtrue; } rfalse; ];
[ TakeSub_C2;
	if (noun == actor) return GL__M(##Take,2); rfalse; ];
[ TakeSub_C3;
	if (noun has animate) return GL__M(##Take,3,noun); rfalse; ];
[ TakeSub_C4 i;
!  if (noun provides component_parent)
!		return GL__M(##Take,7,noun.component_parent);
	ac_common_ancestor = OIU_CommonAncestor(actor, noun);
	if (ac_common_ancestor == 0) {
		i = ObjectScopedBySomething(noun);
		if (i ~= 0) ac_common_ancestor = CommonAncestor(actor, i);
	} rfalse; ];

[ OIUB_AP i;
	if (noun ~= ac_common_ancestor) {
		i = OIU_Parent(noun);
		while (i~=ac_common_ancestor && i) {
			if (i has animate) return GL__M(##Take,6,i);
			i = OIU_Parent(i);
		}
	}
	rfalse;
];

![ TakeSub_C5;
!  if (ac_common_ancestor == 0) return GL__M(##Take,8,noun); rfalse; ];
[ TakeSub_C6;
	if (ac_common_ancestor == noun) return GL__M(##Take,4,noun); rfalse; ];
[ TakeSub_C7;
	if (noun in actor) return GL__M(##Take,5,noun); rfalse; ];
[ TakeSub_C8 i k;
	i=parent(noun); take_after_recipient = 0;
	if (i && (i ~= ac_common_ancestor) && (i has container || i has supporter))
	{   take_after_recipient=i;
		k=action; action=##LetGo;
		if (RunRoutines(i,before)~=0) { action=k; rtrue; }
		action=k;
	} rfalse; ];
[ TakeSub_C9;
	if (noun has scenery) return GL__M(##Take,10,noun); rfalse; ];
[ TakeSub_C10;
	if (noun has static)  return GL__M(##Take,11,noun); rfalse; ];
[ TakeSub_C11 j k ks;
	if (SACK_OBJECT == nothing || SACK_OBJECT notin actor) rfalse;
	k=0; objectloop (j in actor) if (j hasnt worn) k++;
	if (k >= ValueOrRun(actor,capacity)) {
		j=0;
		objectloop (k in actor) 
			if (k~=SACK_OBJECT && k hasnt worn && k hasnt light) j=k;
		if (j~=0) {
			GL__M(##Take,13,j);
			ks = keep_silent;
			keep_silent = 1; <Insert j SACK_OBJECT>; keep_silent = ks;
			if (j notin SACK_OBJECT) rtrue;
			rfalse;
		}
	} rfalse; ];
[ TakeSub_C12 j k;
	k=0; objectloop (j in actor) if (j hasnt worn) k++;
	if (k >= ValueOrRun(actor,capacity)) return GL__M(##Take,12);
	rfalse; ];
[ TakeSub_O1 rest i;
!  if ((noun provides component_parent) && (rest = (noun.component_parent))) {
!		noun.component_parent = nothing;
!		if (rest provides add_to_scope) {
!			for (i=0: i<(rest.#add_to_scope)/2: i++) {
!			    if ((rest.&add_to_scope)-->i == noun)
!					  (rest.&add_to_scope)-->i = nothing;
!			}
!		}
!  }
!  move noun to actor;
	I7_Move(noun, actor);
	rfalse; ];
[ TakeSub_O2 k;
	if (take_after_recipient) {
		k=action; action=##LetGo;
		if (RunRoutines(take_after_recipient,after)~=0) { action=k; rtrue; }
		action=k;
	} rfalse; ];
[ TakeSub_R1;
	if (actor == player) {
		notheld_mode=onotheld_mode;
		if (notheld_mode==1) { RulebookSucceeds(); rtrue; }
	}
	rfalse; ];
[ TakeSub_R2;
	if (player == actor) return GL__M(##Take, 1);
	print (The) actor, " picks up ", (the) noun, ".^^";
];

[ RemoveSub_C1 i;
	i=parent(noun);
	if (i has container && i hasnt open) return GL__M(##Remove,1,noun);
	rfalse; ];
[ RemoveSub_C2 i;
	i=parent(noun); if (i~=second) return GL__M(##Remove,2,noun);
	rfalse; ];
[ RemoveSub_C3 i;
	i=parent(noun); if (i has animate) return GL__M(##Take,6,i);
	rfalse; ];
[ RemoveSub_C4;
	return GVS_Convert(##Take, noun, 0);
];

[ DropSub_C1;
	if (noun == actor) return GL__M(##PutOn, 4); rfalse; ];
[ DropSub_C2;
	if (noun in parent(actor)) return GL__M(##Drop,1,noun); rfalse; ];
[ DropSub_C3;
	if (noun notin actor) return GL__M(##Drop,2,noun); rfalse; ];
[ DropSub_C4 k;
	if (noun has worn) { GL__M(##Drop,3,noun); say__p=0;
		k = keep_silent; keep_silent = 1; <Disrobe noun>;
		keep_silent = k;
		if (noun has worn && noun in actor) rtrue;
	} rfalse; ];
[ DropSub_C5 p;
	p = parent(actor);
	if (p ofclass K1_room) rfalse;
	if (children(p) < ValueOrRun(p,capacity)) rfalse;
	if (actor ~= player) rtrue;
	print "There is no more room ";
	if (p has supporter) print "on "; else print "in ";
	print (the) p, ".^^"; rtrue; ];

[ DropSub_O1; I7_Move(noun, parent(actor)); give noun ~worn; rfalse; ];
[ DropSub_R1;
	if (player == actor) return GL__M(##Drop,4,noun);
	print (The) actor, " puts down ", (the) noun, ".^^";
];

[ PutOnSub_C1;
	if (second == d_obj || actor in second) return GVS_Convert(##Drop, noun, 0);
	rfalse; ];
[ PutOnSub_C2;
	if (parent(noun)~=actor) return GL__M(##PutOn,1,noun); rfalse; ];
[ PutOnSub_C3;
	if (OIU_Core(noun) == OIU_Core(second)) return GL__M(##PutOn,2,noun);
	ac_common_ancestor = OIU_CommonAncestor(noun, second);
	if (ac_common_ancestor == noun) return GL__M(##PutOn,2,noun); rfalse; ];
[ PutOnSub_C4;
	if (second ~= ac_common_ancestor)
	{   action=##Receive; receive_action=##PutOn;
		if (RunRoutines(second,before)~=0) { action=##PutOn; return; }
		action=##PutOn;
	} rfalse; ];
[ PutOnSub_C5;
	if (second hasnt supporter) return GL__M(##PutOn,3,second); rfalse; ];
[ PutOnSub_C6;
	if (ac_common_ancestor == actor) return GL__M(##PutOn,4); rfalse; ];
[ PutOnSub_C7 k;
	if (noun has worn) { GL__M(##PutOn,5,noun); say__p=0;
		k = keep_silent; keep_silent = 1; <Disrobe noun>; keep_silent = k;
		if (noun has worn) rtrue; } rfalse; ];
[ PutOnSub_C8;
	if (children(second)>=ValueOrRun(second,capacity))
		return GL__M(##PutOn,6,second); rfalse; ];
[ PutOnSub_O1; move noun to second; give noun ~worn; rfalse; ];
[ PutOnSub_O2;
	if (second ~= ac_common_ancestor)
	{   action=##Receive;
		if (RunRoutines(second,after)~=0) { action=##PutOn; return; }
		action=##PutOn;
	} rfalse; ];
[ PutOnSub_R1;
	if (player == actor) {
		if (multiflag==1) return GL__M(##PutOn,7);
		return GL__M(##PutOn,8,noun);
	} else {
		print (The) actor, " puts ", (the) noun, " on ", (the) second, ".^^";
		rtrue;
	}
];

[ InsertSub_C1;
	if (second==d_obj || actor in second) return GVS_Convert(##Drop, noun, 0);; rfalse; ];
[ InsertSub_C2;
	if (parent(noun)~=actor) return GL__M(##Insert,1,noun); rfalse; ];
[ InsertSub_C3;
	if (OIU_Core(noun) == OIU_Core(second)) return GL__M(##Insert, 5, noun);
	ac_common_ancestor = OIU_CommonAncestor(noun, second);
	if (ac_common_ancestor == noun) return GL__M(##Insert, 5, noun); rfalse; ];
[ InsertSub_C4;
	if (second ~= ac_common_ancestor) {
		action=##Receive; receive_action = ##Insert;
		if (RunRoutines(second,before)~=0) { action=##Insert; rtrue; }
		action=##Insert;
	} rfalse; ];
[ InsertSub_C5;
	if (second ~= ac_common_ancestor) {
		if (second has container && second hasnt open)
			return GL__M(##Insert,3,second);
	} rfalse; ];
[ InsertSub_C6;
	if (second hasnt container) return GL__M(##Insert,2,second); rfalse; ];
[ InsertSub_C7 k;
	if (noun has worn) {
		GL__M(##Insert,6,noun);
		say__p=0; k = keep_silent; keep_silent = 1; <Disrobe noun>;
		keep_silent = k; if (noun has worn) rtrue;
	} rfalse; ];
[ InsertSub_C8;
	if (children(second) >= ValueOrRun(second,capacity))
		return GL__M(##Insert,7,second); rfalse; ];
[ InsertSub_O1; move noun to second; give noun ~worn; rfalse; ];
[ InsertSub_O2;
	if (second ~= ac_common_ancestor) {
		action=##Receive;
		if (RunRoutines(second,after)~=0) { action=##Insert; rtrue; }
		action=##Insert;
	} rfalse; ];
[ InsertSub_R1;
	if (actor == player) {
		if (multiflag==1) return GL__M(##Insert,8,noun);
		GL__M(##Insert,9,noun);
	} else {
		print (The) actor, " puts ", (the) noun, " into ", (the) second, ".^^";
	}
	rtrue; ];


[ ScoreSub_O1;
	if (actor ~= player) rfalse;
	#ifdef I7_NOSCORE; "[There is no numerical score.]";
	#ifnot; GL__M(##Score); PrintRank();
	#endif;
];
[ FullScoreSub_O1 i;
	if (actor ~= player) rfalse;
	ScoreSub_O1();
	#ifndef I7_NOSCORE;
	if (score==0 || TASKS_PROVIDED==1) rfalse;
	new_line;
	GL__M(##FullScore,1);

	for (i=0:i<NUMBER_TASKS:i++)
		if (task_done->i==1)
		{   PANum(task_scores->i);
			PrintTaskName(i);
		}
	
	if (things_score~=0)
	{   PANum(things_score); GL__M(##FullScore,2); }
	if (places_score~=0)
	{   PANum(places_score); GL__M(##FullScore,3); }
	new_line; PANum(score); GL__M(##FullScore,4);
	#endif;
];

#ifdef TARGET_ZCODE;

[ QuitSub_O1; if (actor ~= player) rfalse;
	GL__M(##Quit,2); if (YesOrNo()~=0) quit; ];

[ RestartSub_O1;
	if (actor ~= player) rfalse;
	GL__M(##Restart,1);
	if (YesOrNo()~=0) { @restart; GL__M(##Restart,2); }
];

[ RestoreSub_O1;
	if (actor ~= player) rfalse;
	restore Rmaybe;
	return GL__M(##Restore,1);
	.RMaybe; GL__M(##Restore,2);
];

[ SaveSub_O1 flag;
	if (actor ~= player) rfalse;
	#IFV5;
	@save -> flag;
	switch (flag) {
		0: GL__M(##Save,1);
		1: GL__M(##Save,2);
		2: GL__M(##Restore,2);
	}
	#IFNOT;
	save Smaybe;
	return GL__M(##Save,1);
	.SMaybe; GL__M(##Save,2);
	#ENDIF;
];

[ VerifySub_O1;
	if (actor ~= player) rfalse;
	@verify ?Vmaybe;
	jump Vwrong;
	.Vmaybe; return GL__M(##Verify,1);
	.Vwrong;
	GL__M(##Verify,2);
];

[ ScriptOnSub_O1;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode) return GL__M(##ScriptOn,1);
	@output_stream 2;
	if (((0-->8) & 1) == 0) return GL__M(##ScriptOn,3);
	GL__M(##ScriptOn,2); VersionSub();
	transcript_mode = true;
];

[ ScriptOffSub_O1;
	if (actor ~= player) rfalse;
	transcript_mode = ((0-->8) & 1);
	if (transcript_mode == false) return GL__M(##ScriptOff,1);
	GL__M(##ScriptOff,2);
	@output_stream -2;
	if ((0-->8) & 1) return GL__M(##ScriptOff,3);
	transcript_mode = false;
];

#ifnot; ! TARGET_GLULX

[ QuitSub_O1;
	if (actor ~= player) rfalse;
	GL__M(##Quit, 2); if (YesOrNo()~=0) quit; ];

[ RestartSub_O1;
	if (actor ~= player) rfalse;
	GL__M(##Restart, 1);
	  if (YesOrNo() ~= 0) {
		  @restart;
		  GL__M(##Restart, 2);
	  }
];

[ RestoreSub_O1 res fref;
	if (actor ~= player) rfalse;
	fref = glk($0062, $01, $02, 0); ! fileref_create_by_prompt
	  if (fref == 0) jump RFailed;
	  gg_savestr = glk($0042, fref, $02, GG_SAVESTR_ROCK); ! stream_open_file
	  glk($0063, fref); ! fileref_destroy
	  if (gg_savestr == 0) jump RFailed;
	  @restore gg_savestr res;
	  glk($0044, gg_savestr, 0); ! stream_close
	  gg_savestr = 0;
	.RFailed;
	  GL__M(##Restore, 1);
];

[ SaveSub_O1 res fref;
	if (actor ~= player) rfalse;
	fref = glk($0062, $01, $01, 0); ! fileref_create_by_prompt
	  if (fref == 0) jump SFailed;
	  gg_savestr = glk($0042, fref, $01, GG_SAVESTR_ROCK); ! stream_open_file
	  glk($0063, fref); ! fileref_destroy
	  if (gg_savestr == 0) jump SFailed;
	  @save gg_savestr res;
	  if (res == -1) {
		  ! The player actually just typed "restore". We're going to print
		  !  GL__M(##Restore,2); the Z-Code Inform library does this correctly
		  ! now. But first, we have to recover all the Glk objects; the values
		  ! in our global variables are all wrong.
		  GGRecoverObjects();
		  glk($0044, gg_savestr, 0); ! stream_close
		  gg_savestr = 0;
		  return GL__M(##Restore, 2);
	  }
	  glk($0044, gg_savestr, 0); ! stream_close
	  gg_savestr = 0;
	  if (res == 0) return GL__M(##Save, 2);
	.SFailed;
	  GL__M(##Save, 1);
];

[ VerifySub_O1 res;
	if (actor ~= player) rfalse;
	@verify res;
	  if (res == 0) return GL__M(##Verify, 1);
	  GL__M(##Verify, 2);
];

[ ScriptOnSub_O1;
	if (actor ~= player) rfalse;
	if (gg_scriptstr ~= 0) return GL__M(##ScriptOn, 1);
	  if (gg_scriptfref == 0) {
		  ! fileref_create_by_prompt
		  gg_scriptfref = glk($0062, $102, $05, GG_SCRIPTFREF_ROCK);
		  if (gg_scriptfref == 0) jump S1Failed;
	  }
	  ! stream_open_file
	  gg_scriptstr = glk($0042, gg_scriptfref, $05, GG_SCRIPTSTR_ROCK);
	  if (gg_scriptstr == 0) jump S1Failed;
	  glk($002D, gg_mainwin, gg_scriptstr); ! window_set_echo_stream
	  GL__M(##ScriptOn, 2);
	  VersionSub();
	  return;
	.S1Failed;
	  GL__M(##ScriptOn, 3);
];

[ ScriptOffSub_O1;
	if (actor ~= player) rfalse;
	if (gg_scriptstr == 0) return GL__M(##ScriptOff,1);
	  GL__M(##ScriptOff, 2);
	  glk($0044, gg_scriptstr, 0); ! stream_close
	  gg_scriptstr = 0;
];

#endif; ! TARGET_

[ VersionSub_O1 ix;
	if (actor ~= player) rfalse;
	Banner();
	  #ifdef NI_BUILD_COUNT;
	  print "Identification number: ";
	  for (ix=6: ix <= UUID_ARRAY->0: ix++) print (char) UUID_ARRAY->ix;
	  print "^";
	  #endif; ! NI_BUILD_COUNT
	  #Ifdef TARGET_ZCODE;
	  ix = 0; ! shut up compiler warning
	  if (standard_interpreter > 0) {
		  print "Standard interpreter ", standard_interpreter/256, ".", standard_interpreter%256,
			  " (", HDR_TERPNUMBER->0;
		  #Iftrue (#version_number == 6);
		  print (char) '.', HDR_TERPVERSION->0;
		  #Ifnot;
		  print (char) HDR_TERPVERSION->0;
		  #Endif;
		  print ") / ";
		  }
	  else {
		  print "Interpreter ", HDR_TERPNUMBER->0, " Version ";
		  #Iftrue (#version_number == 6);
		  print HDR_TERPVERSION->0;
		  #Ifnot;
		  print (char) HDR_TERPVERSION->0;
		  #Endif;
		  print " / ";
	  }

	  #Ifnot; ! TARGET_GLULX;
	  @gestalt 1 0 ix;
	  print "Interpreter version ", ix / $10000, ".", (ix & $FF00) / $100,
	  ".", ix & $FF, " / ";
	  @gestalt 0 0 ix;
	  print "VM ", ix / $10000, ".", (ix & $FF00) / $100, ".", ix & $FF, " / ";
	  #Endif; ! TARGET_;
	  print "Library serial number ", (string) LibSerial, "^";
	  #Ifdef LanguageVersion;
	  print (string) LanguageVersion, "^";
	  #Endif; ! LanguageVersion
	  #ifdef I7ExtensionVersions;
	  I7ExtensionVersions();
	  #endif;
];

[ NotifyOnSub_O1;
	if (actor ~= player) rfalse;
	#ifdef I7_NOSCORE; ScoreSub_O1(); #ifnot;
	notify_mode=1; GL__M(##NotifyOn); #endif; ];
[ NotifyOffSub_O1;
	if (actor ~= player) rfalse;
	#ifdef I7_NOSCORE; ScoreSub_O1(); #ifnot;
	notify_mode=0; GL__M(##NotifyOff); #endif; ];
[ LMode1Sub_O1;
	if (actor ~= player) rfalse;
	lookmode=1; print (string) Story; GL__M(##LMode1); ];  ! Brief

[ LMode2Sub_O1;
	if (actor ~= player) rfalse;
	lookmode=2; print (string) Story; GL__M(##LMode2); ];  ! Verbose

[ LMode3Sub_O1;
	if (actor ~= player) rfalse;
	lookmode=3; print (string) Story; GL__M(##LMode3); ];  ! Superbrief
[ PronounsSub_O1 x y c d;
	if (actor ~= player) rfalse;
	GL__M(##Pronouns, 1);

	c = (LanguagePronouns-->0)/3;
	if (player ~= selfobj) c++;

	if (c==0) return GL__M(##Pronouns, 4);

	for (x = 1, d = 0 : x <= LanguagePronouns-->0: x = x+3)
	{   print "~", (address) LanguagePronouns-->x, "~ ";
		y = LanguagePronouns-->(x+2);
		if (y == NULL) GL__M(##Pronouns, 3);
		else { GL__M(##Pronouns, 2); print (the) y; }
		d++;
		if (d < c-1) print ", ";
		if (d == c-1) print (string) AND__TX;
	}
	if (player ~= selfobj)
	{   print "~", (address) ME1__WD, "~ "; GL__M(##Pronouns, 2);
		c = player; player = selfobj;
		print (the) c; player = c;
	}
	".";
];

! End of Verbs.i6

	
! --- List together routines ---


[ Initialise pp;
	CreatePropertyOffsets();
  location = O99_bluff;
  the_time = 540;

	#ifdef I7_LOOKMODE; lookmode = I7_LOOKMODE; #endif;
	InformLibrary.end_turn_sequence = TurnEndPrimitive;
	TimePasses(); TS6_R();
	print "^^";
	! ensure that visibility, etc., is correct for when play begins rules
	move player to location;
	real_location = location;
	I7_uninitialised = true;
	FollowRulebook(GAME_BEGINS_RB);
	pp = parent(player);
	if (pp ofclass K1_room) location = pp;
	else if (pp ofclass K2_thing) location = pp;
	if (pp) remove player; ! let the I6 library reposition the player
	I7_uninitialised = false;
];

[ DeathMessage;
	if (deadflag ofclass Routine) (deadflag)();
	if (deadflag ofclass String) print (string) deadflag;
];

[ AfterLife;
	FollowRulebook(GAME_ENDS_RB);
];

[ TimePasses;
	ChronologyTurnEnd();
];

[ ParserError error_type;
	if (error_type ofclass String) print_ret (string) error_type;
	if (error_type ofclass Routine) { error_type.call(); new_line; rtrue; }
	rfalse;
];

! ChooseObjects.i6 segment

!Constant COBJ_DEBUG;

Constant MATCH_LIST_WORDS = (MATCH_LIST_SIZE/2);
Constant COBJ_BITS_SIZE = (MATCH_LIST_WORDS*MATCH_LIST_WORDS/8);

! the highest value returned by I7_CheckDPMR (see the Standard Rules)
Constant HIGHEST_DPMR_SCORE = 4;

Array alt_match_list --> (MATCH_LIST_WORDS+1);

#ifdef TARGET_GLULX;
[ COBJ__Copy words from to  i;
	for (i=0: i<words: i++)
		to-->i = from-->i;
];
#ifnot;
[ COBJ__Copy words from to  bytes;
	bytes = words * 2;
	@copy_table from to bytes;
];
#endif;

! swap alt_match_list with match_list/number_matched
[ COBJ__SwapMatches i x;
	! swap the counts
	x = number_matched;
	number_matched = alt_match_list-->0;
	alt_match_list-->0 = x;
	! swap the values
	if (x < number_matched) x = number_matched;
	for (i=x: i>0: i--) {
		x = match_list-->(i-1);
		match_list-->(i-1) = alt_match_list-->i;
		alt_match_list-->i = x;
	}
];

[ ChooseObjects obj code  l i swn spcount;
	if (code<2) rfalse;

	if (cobj_flag == 1) {
		.CodeOne;
		if (parameters > 0) {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (second)]^";
			#endif;
			return ScoreDabCombo(inputobjs-->2, obj);
		} else {
			#ifdef COBJ_DEBUG;
			print "[scoring ", (the) obj, " (first) in ",
				alt_match_list-->0, " combinations]^";
			#endif;
			l = 0;
			for (i=1: i<=alt_match_list-->0: i++) {
				spcount = ScoreDabCombo(obj, alt_match_list-->i);
				if (spcount == HIGHEST_DPMR_SCORE) {
					#ifdef COBJ_DEBUG;
					print "[scored ", spcount, " - best possible]^";
					#endif;
					return spcount;
				}
				if (spcount>l) l = spcount;
			}
			return l;
		}
	}
	if (cobj_flag == 2) {
		.CodeTwo;
		#ifdef COBJ_DEBUG;
		print "[scoring ", (the) obj, " (simple)]^";
		#endif;
		if (parameters==0)
			return ScoreDabCombo(obj, 0);
		else
			return ScoreDabCombo(inputobjs-->2, obj);
	}

	#ifdef COBJ_DEBUG;
	print "[choosing a cobj strategy: ";
	#endif;
	swn = wn;
	if (line_ttype-->pcount == PREPOSITION_TT) {
		spcount = pcount;
		while (line_ttype-->pcount == PREPOSITION_TT) pcount++;
		if ((line_ttype-->pcount == ELEMENTARY_TT) && (line_tdata-->pcount == NOUN_TOKEN)) {
			! Advance past the last preposition
			while (wn < num_words) {
				l = NextWord();
				if ( l && (l->#dict_par1) &8 ) {	! if preposition
					if (l == ALL1__WD or ALL2__WD or ALL3__WD or ALL4__WD or ALL5__WD) continue;
					SafeSkipDescriptors();
					! save the current match state
					@push match_length; @push match_from; @push placed_in_flag;
					alt_match_list-->0 = number_matched;
					COBJ__Copy(number_matched, match_list, alt_match_list+WORDSIZE);
					! now get all the matches for the second noun
					match_length = 0; number_matched = 0; match_from = wn; placed_in_flag = 0;
					SearchScope(actor, actors_location, line_tdata-->pcount);
					#ifdef COBJ_DEBUG;
					print number_matched, " possible second nouns]^";
					#endif;
					wn = swn;
					cobj_flag = 1;
					! restore match variables
					COBJ__SwapMatches();
					@pull placed_in_flag; @pull match_from; @pull match_length;
					pcount = spcount;
					jump CodeOne;
				}
			}
		}
		pcount = spcount;
	}
	wn = swn;	
	
	#ifdef COBJ_DEBUG;
	print "nothing interesting]^";
	#endif;
	cobj_flag = 2;
	jump CodeTwo;
];

[ SafeSkipDescriptors;
	@push indef_mode; @push indef_type; @push indef_wanted;
	@push indef_guess_p; @push indef_possambig; @push indef_owner;
	@push indef_cases; @push indef_nspec_at;
	
	Descriptors();
	
	@pull indef_nspec_at; @pull indef_cases;
	@pull indef_owner; @pull indef_possambig; @pull indef_guess_p;
	@pull indef_wanted; @pull indef_type; @pull indef_mode;
];

[ ScoreDabCombo a b  result;
	@push action; @push noun; @push second;
	action = action_to_be;
	if (action_reversed) {
		noun = b; second = a;
	} else {
		noun = a; second = b;
	}
	result = I7_CheckDPMR();
	@pull second; @pull noun; @pull action;
	#ifdef COBJ_DEBUG;
	print "[", (the) a, " / ", (the) b, " => ", result, "]^";
	#endif;
	return result;
];

! End of ChooseObjects.i6 segment


[ I7ReadUseOption UO;
  if (UO == 1) rtrue;
  if (UO == 2) rtrue;
  rfalse;
];




! Chronology.i6 segment


[ TrackActions adjust ct_0 ct_1;

];

[ ChronologyTurnEnd pt; ! Called from TimePasses()
	for (pt=0:pt<NO_PAST_TENSES:pt++) ChronologyRecord(0, pt, true);
	ChronologyPoint();
];

[ ChronologyPoint pt;
	for (pt=0:pt<NO_PAST_TENSES:pt++) past_tense-->pt = present_tense-->pt;
];

[ ChronologyRecord tense pt turn_end wanted old new trips consecutives ct_0 ct_1;
	if (tense == 1) {
		new = (past_tense-->pt) & 1;
		trips = ((past_tense-->pt) & $$11111110)/2;
		consecutives = ((past_tense-->pt) & $$111111100000000)/256;
	} else {
		! print "PT-->pt = ", (present_tense-->pt), "^";
		old = (present_tense-->pt) & 1;
		trips = ((present_tense-->pt) & $$11111110)/2;
		consecutives = ((present_tense-->pt) & $$111111100000000)/256;
		switch(pt) {

		}
		! print pt,":o=",old," n=",new," t=",trips," c=",consecutives,"^";
		if ((old == 0) && (new == 1)) {
			trips++;
			if (trips > 127) trips = 127;
		}
		if (new == 0) consecutives=0;
		if ((new == 1) && (turn_end)) {
			consecutives++;
			if (consecutives > 127) consecutives = 127;
		}
		present_tense-->pt = new + 2*trips + 256*consecutives;
	}
	if ((wanted < 8) && (new == 0)) return 0;
	switch(wanted%8) { 0: return new;
		1: return trips;
		2: return consecutives;
	}
];

Constant NO_PAST_TENSES 0;
Constant NO_PAST_ACTIONS 0;


Array TimesActionHasHappened-->(NO_PAST_ACTIONS+1);
Array TurnsActionHasBeenHappening-->(NO_PAST_ACTIONS+1);

Array past_tense-->(NO_PAST_TENSES+1);
Array present_tense-->(NO_PAST_TENSES+1);

! End of Chronology.i6 segment





Constant SUPPRESS_ACTION_GRAMMAR;

#IFTRUE (0 == 1);
[ UnknownVerb;
	verb_wordnum = 0; return 'no.verb';
];
[ PrintVerb v;
	if (v == 'no.verb') { print "do something to"; rtrue; }
	rfalse;
];
#ENDIF;

Include "Grammar";





[ I7_NUMBER_TOKEN wnc wna r n wa wl sign base digit digit_count;
	wnc = wn;

	wn = wnc;
	r = I7_ParseToken(ELEMENTARY_TT, NUMBER_TOKEN);
	if ((r == GPR_NUMBER) && (parsed_number ~= 10000)) return r;
	wn = wnc;
	wa = WordAddress(wn);
	wl = WordLength(wn);
	sign = 1; base = 10; digit_count = 0;
	if (wa->0 ~= '-' or '$' or '0' or '1' or '2' or '3' or '4'
		or '5' or '6' or '7' or '8' or '9')
		return GPR_FAIL;
	if (wa->0 == '-') { sign = -1; wl--; wa++; }
	if (wl == 0) return GPR_FAIL;
	n = 0;
	while (wl > 0) {
		if (wa->0 >= 'a') digit = wa->0 - 'a' + 10;
		else digit = wa->0 - '0';
		digit_count++;
		switch (base) {
			2:  if (digit_count == 17) return GPR_FAIL;
			10: if (digit_count == 6) return GPR_FAIL;
				if (digit_count == 5) {
					if (n > 3276) return GPR_FAIL;
					if (n == 3276) {
						if (sign == 1 && digit > 7) return GPR_FAIL;
						if (sign == -1 && digit > 8) return GPR_FAIL;
					}
				}
			16: if (digit_count == 5) return GPR_FAIL;
		}
		if (digit >= 0 && digit < base) n = base*n + digit;
		else return GPR_FAIL;
		wl--; wa++;
	}
	parsed_number = n*sign; wn++;
	return GPR_NUMBER;
];




[ Noun_Filter_0 x; x=noun;
  return ((noun ofclass K3_direction)); ];
[ Noun_Filter_1 x; x=noun;
  return ((noun ofclass K3_direction)); ];
[ Noun_Filter_2 x; x=noun;
  return ((noun ofclass K3_direction)); ];



Verb 'take//' 'carry//' 'hold//'
   * 'inventory//'  -> Inv
   * multi  -> Take
   * 'off//' noun  -> Disrobe
   * multiinside 'from//' noun  -> Remove
   * multiinside 'off//' noun  -> Remove
;
Verb 'get//'
   * 'out//' / 'off//' / 'up//'  -> Exit
   * multi  -> Take
   * 'in//' / 'into//' / 'on//' / 'onto//' noun  -> Enter
   * 'off//' noun  -> GetOff
   * multiinside 'from//' noun  -> Remove
;
Verb 'pick//'
   * 'up//' multi  -> Take
   * multi 'up//'  -> Take
;
Verb 'stand//'
   *  -> Exit
   * 'up//'  -> Exit
   * 'on//' noun  -> Enter
;
Verb 'remove//'
   * held  -> Disrobe
   * multiinside 'from//' noun  -> Remove
;
Verb 'shed//' 'doff//' 'disrobe//'
   * held  -> Disrobe
;
Verb 'wear//' 'don//'
   * held  -> Wear
;
Verb 'put//'
   * 'on//' held  -> Wear
   * 'down//' multiheld  -> Drop
   * multiheld 'down//'  -> Drop
   * multiexcept 'in//' / 'inside//' / 'into//' noun  -> Insert
   * multiexcept 'on//' / 'onto//' noun  -> PutOn
;
Verb 'insert//'
   * multiexcept 'in//' / 'into//' noun  -> Insert
;
Verb 'drop//' 'throw//' 'discard//'
   * multiheld  -> Drop
   * held 'at//' / 'against//' / 'on//' / 'onto//' noun  -> ThrowAt
   * multiexcept 'in//' / 'into//' / 'down//' noun  -> Insert
   * multiexcept 'on//' / 'onto//' noun  -> PutOn
;
Verb 'give//' 'pay//' 'offer//' 'feed//'
   * creature held  -> Give reverse
   * held 'to//' creature  -> Give
;
Verb 'show//' 'present//' 'display//'
   * creature held  -> Show reverse
   * held 'to//' creature  -> Show
;
Verb 'go//' 'walk//' 'leave//' 'run//'
   *  -> Go
   * noun=Noun_Filter_0  -> Go
   * noun  -> Enter
   * 'into//' / 'in//' / 'inside//' / 'through//' noun  -> Enter
;
Verb 'inventory//' 'i//' 'inv//'
   *  -> Inv
;
Verb 'look//' 'l//'
   *  -> Look
   * 'at//' noun  -> Examine
   * 'inside//' / 'in//' / 'into//' / 'through//' noun  -> Search
   * 'under//' noun  -> LookUnder
   * 'up//' topic 'in//' noun  -> Consult reverse
;
Verb 'consult//'
   * noun 'on//' / 'about//' topic  -> Consult
;
Verb 'open//' 'unwrap//' 'uncover//'
   * noun  -> Open
   * noun 'with//' held  -> Unlock
;
Verb 'close//' 'shut//' 'cover//'
   * noun  -> Close
   * 'up//' noun  -> Close
   * 'off//' noun  -> SwitchOff
;
Verb 'enter//' 'cross//'
   * noun  -> Enter
;
Verb 'sit//'
   * 'on//' / 'in//' / 'inside//' noun  -> Enter
   * 'on//' 'top//' 'of//' noun  -> Enter
;
Verb 'exit//' 'out//'
   *  -> Exit
;
Verb 'examine//' 'x//' 'watch//' 'describe//' 'check//'
   * noun  -> Examine
;
Verb 'read//'
   * noun  -> Examine
   * 'about//' topic 'in//' noun  -> Consult reverse
   * topic 'in//' noun  -> Consult reverse
;
Verb 'yes//' 'y//'
   *  -> Yes
;
Verb 'no//'
   *  -> No
;
Verb 'sorry//'
   *  -> Sorry
;
Verb 'shit//' 'fuck//' 'damn//'
   *  -> Strong
;
Verb 'bother//' 'curses//' 'drat//' 'darn//'
   *  -> Mild
;
Verb 'search//'
   * noun  -> Search
;
Verb 'wave//'
   *  -> WaveHands
   * noun  -> Wave
;
Verb 'set//' 'adjust//'
   * noun 'to//' topic  -> SetTo
;
Verb 'pull//' 'drag//'
   * noun  -> Pull
;
Verb 'push//' 'move//' 'shift//' 'clear//' 'press//'
   * noun  -> Push
   * noun noun=Noun_Filter_1  -> PushDir
   * noun 'to//' noun=Noun_Filter_2  -> PushDir
;
Verb 'turn//' 'rotate//' 'twist//' 'unscrew//' 'screw//'
   * noun  -> Turn
   * noun 'on//'  -> SwitchOn
   * 'on//' noun  -> SwitchOn
   * noun 'off//'  -> SwitchOff
   * 'off//' noun  -> SwitchOff
;
Verb 'switch//'
   * noun  -> SwitchOn
   * noun 'on//'  -> SwitchOn
   * noun 'off//'  -> SwitchOff
   * 'off//' noun  -> SwitchOff
;
Verb 'lock//'
   * noun 'with//' held  -> Lock
;
Verb 'unlock//'
   * noun 'with//' held  -> Unlock
;
Verb 'attack//' 'break//' 'smash//' 'hit//' 'fight//' 'torture//' 'wreck//' 'crack//' 'destroy//' 'murder//' 'kill//' 'punch//' 'thump//'
   * noun  -> Attack
;
Verb 'wait//' 'z//'
   *  -> Wait
;
Verb 'answer//' 'say//' 'shout//' 'speak//'
   * topic 'to//' creature  -> Answer reverse
;
Verb 'tell//'
   * creature 'about//' topic  -> Tell
;
Verb 'ask//'
   * creature 'for//' noun  -> AskFor
   * creature 'about//' topic  -> Ask
;
Verb 'eat//'
   * held  -> Eat
;
Verb 'sleep//' 'nap//'
   *  -> Sleep
;
Verb 'sing//'
   *  -> Sing
;
Verb 'climb//' 'scale//'
   * noun  -> Climb
   * 'up//' / 'over//' noun  -> Climb
;
Verb 'buy//' 'purchase//'
   * noun  -> Buy
;
Verb 'squeeze//' 'squash//'
   * noun  -> Squeeze
;
Verb 'swing//'
   * noun  -> Swing
   * 'on//' noun  -> Swing
;
Verb 'wake//' 'awake//' 'awaken//'
   *  -> Wake
   * 'up//'  -> Wake
   * creature  -> WakeOther
   * creature 'up//'  -> WakeOther
   * 'up//' creature  -> WakeOther
;
Verb 'kiss//' 'embrace//' 'hug//'
   * creature  -> Kiss
;
Verb 'think//'
   *  -> Think
;
Verb 'smell//' 'sniff//'
   *  -> Smell
   * noun  -> Smell
;
Verb 'listen//'
   *  -> Listen
   * 'to//' noun  -> Listen
;
Verb 'hear//'
   * noun  -> Listen
;
Verb 'taste//'
   * noun  -> Taste
;
Verb 'touch//' 'feel//'
   * noun  -> Touch
;
Verb 'rub//' 'shine//' 'polish//' 'sweep//' 'clean//' 'dust//' 'wipe//' 'scrub//'
   * noun  -> Rub
;
Verb 'tie//' 'attach//' 'fix//' 'fasten//'
   * noun 'to//' noun  -> Tie
;
Verb 'burn//' 'light//'
   * noun  -> Burn
;
Verb 'drink//' 'swallow//' 'sip//'
   * noun  -> Drink
;
Verb 'cut//' 'slice//' 'prune//' 'chop//'
   * noun  -> Cut
;
Verb 'jump//' 'skip//' 'hop//'
   *  -> Jump
;
Verb 'score//'
   *  -> Score
;
Verb 'quit//'
   *  -> Quit
;
Verb 'q//'
   *  -> Quit
;
Verb 'save//'
   *  -> Save
;
Verb 'restart//'
   *  -> Restart
;
Verb 'restore//'
   *  -> Restore
;
Verb 'verify//'
   *  -> Verify
;
Verb 'version//'
   *  -> Version
;
Verb 'script//'
   *  -> ScriptOn
   * 'on//'  -> ScriptOn
   * 'off//'  -> ScriptOff
;
Verb 'transcript//'
   *  -> ScriptOn
   * 'on//'  -> ScriptOn
   * 'off//'  -> ScriptOff
;
Verb 'superbrief//'
   *  -> LMode3
;
Verb 'short//'
   *  -> LMode3
;
Verb 'verbose//'
   *  -> LMode2
;
Verb 'long//'
   *  -> LMode2
;
Verb 'brief//'
   *  -> LMode1
;
Verb 'normal//'
   *  -> LMode1
;
Verb 'nouns//'
   *  -> Pronouns
;
Verb 'pronouns//'
   *  -> Pronouns
;
Verb 'notify//'
   *  -> NotifyOn
   * 'on//'  -> NotifyOn
   * 'off//'  -> NotifyOff
;
Verb 'time//'
   *  -> A80_time_checking
;
[ Parse_Name_GV82
    original_wn  ! first word of text parsed
    group_wn  ! first word matched against A/B/C/... disjunction
    try_from_wn  ! position to try matching from
    n  ! number of words matched
    f  ! flag: sufficiently good match found to justify success
    w  ! for use by individual grammar lines
    rv  ! for use by individual grammar lines
    g  ! temporary: success flag for parsing visibles
    ss  ! temporary: saves 'self' in distinguishing visibles
    pass  ! pass counter (1 or 2)
    pass1_n  ! value of n recorded during pass 1
    ;
  if (parser_trace >= 3)
      print "Two-pass parse_name called^";
  original_wn = wn;
  for (pass = 1: pass <= 2: pass++) {
  wn = original_wn;
  try_from_wn = wn; f = false; n = 0;
  ! On pass 1 only, advance wn past name property words
  ! (but do not do this for ##TheSame, when wn is undefined)
  if ((parser_action ~= ##TheSame) && (pass == 1)) {
      while (WordInProperty(NextWordStopped(), self, name))
          f = true;
      wn--;
  }
  ! On pass 2 only, match name property words at end
  if (pass == 2)
  while (WordInProperty(NextWordStopped(), self, name))
      n++;
  if ((f) || (n>0)) n = n + try_from_wn - original_wn;
  if (pass == 1) pass1_n = n;
  } ! End of pass loop
  if (parser_trace >= 3)
      print "Pass 1: ", pass1_n, " Pass 2: ", n, "^";
  if (pass1_n > n) n = pass1_n;
  wn = original_wn + n; if (n == 0) return -1;
  I7SpotPluralWord(original_wn, n); return n;
];


#IFDEF DEBUG;

! Tests.i6 segment
! Should only be included if DEBUG is defined.

Verb meta "test"
	* -> TestScript
	* special -> TestScript;

#IFDEF TEST_SCENARIOS_EXIST;

[ TestScriptSub;
	switch(special_word) {

	default:
		print ">--> The following tests are available:^";

	}
];

Array test_stack --> 15;
Global test_sp = 0;
[ TestStart T R k;
	if (test_sp == 15) ">--> Testing too many levels deep";
	test_stack-->test_sp = T;
	test_stack-->(test_sp+1) = 1;
	test_sp = test_sp + 3;
	if ((R-->0) && (R-->0 ~= real_location)) {
	     print "(first moving to ", (name) R-->0, ")^";
	     PlayerTo(R-->0, 1);
	}
	k=1;
	while (R-->k) {
	    if (R-->k notin player) {
	        print "(first acquiring ", (the) R-->k, ")^";
	        move R-->k to player;
	    }
	    k++;
	}
	print "(Testing.)^";
];
[ KeyboardPrimitive a_buffer a_table p i j l spaced;
	if (test_sp == 0) {
	    test_stack-->2 = 1;
	    return KeyboardPrimitive__(a_buffer, a_table);
	}
	else {
	    p = test_stack-->(test_sp-3);
	    i = test_stack-->(test_sp-2);
	    print "[";
	    print test_stack-->2;
	    print "] ";
	    test_stack-->2 = 
	        test_stack-->2+1;
	    style bold;
	    while ((i <= p->0) && (p->i ~= '/')) {
	        if (spaced || (p->i ~= ' ')) {
	            a_buffer->(j+WORDSIZE) = p->i;
	            print (char) p->i;
	            i++; j++;
	            spaced = true;
	        } else i++;
	    }
	    style roman;
	    print "^";
	    #ifdef TARGET_ZCODE;
	    a_buffer->1 = j;
	    #ifnot; ! TARGET_GLULX
	    a_buffer-->0 = j;
	    #endif;
	    Tokenise__(a_buffer, a_table);
	    if (p->i == '/') i++;
	    if (i > p->0) {
	        test_sp = test_sp - 3;
	    } else test_stack-->(test_sp-2) = i;
	}
];

#IFNOT; ! TEST_SCENARIOS_EXIST

[ TestScriptSub;
	">--> No test scripts exist for this game.";
];

#ENDIF; ! TEST_SCENARIOS_EXIST

! End of Tests.i6 segment

! Debugging.i6 segment
! Should only be included if DEBUG is defined.

! Not all of these commands are documented; this is intentional. They may
! be changed in name or function. But this is all of the grammar defined
! in the segments except for the TEST command, which is in Tests.i6.

Constant NO_DEBUGGABLES = 30;
Array debuggable_states -> NO_DEBUGGABLES;
[ DebugRbOffSub state i c;
	if ((noun >= 0) && (noun < NO_DEBUGGABLES)) {
		debuggable_states->noun = state;
		print "Now tracing rulebooks: ";
		for (i=0:i<NO_DEBUGGABLES:i++)
			if (debuggable_states->i) { c++; print i, " "; }
		if (c==0) "none";
		new_line; return;
	}
	"Rulebook number out of range.";
];
[ DebugRbSub; DebugRbOffSub(true); ];
[ AdjustDbr s;
	if ((s>=0) && (s<NO_DEBUGGABLES)) debugging_rules = debuggable_states->s;
];

[ RulesOnSub;
	debug_rules = 1;
	"Rules tracing now switched on. Type ~rules off~ to switch it off again,
	 or ~rules all~ to include even rules which do not apply.";
];
[ RulesAllSub;
	debug_rules = 2;
	"Rules tracing now switched to ~all~. Type ~rules off~ to switch it off again.";
];
[ RulesOffSub;
	debug_rules = 0;
	"Rules tracing now switched off. Type ~rules~ to switch it on again.";
];

[ ScenesOnSub;
	debug_scenes = 1;
	I7_SceneStatus();
	"(Scene monitoring now switched on. Type ~scenes off~ to switch it off again.)";
];
[ ScenesOffSub;
	debug_scenes = 0;
	"(Scene monitoring now switched off. Type ~scenes~ to switch it on again.)";
];

[ ShowRLocation obj top;
	if (obj ofclass K1_room) return;
	print " ";
	if (parent(obj)) {
		if (obj has worn) print "worn by ";
		else {
			if (parent(obj) has animate) print "carried by ";
			if (parent(obj) has container) print "in ";
			if (parent(obj) ofclass K1_room) print "in ";
			if (parent(obj) has supporter) print "on ";
		}
		print (the) parent(obj);
		ShowRLocation(parent(obj));
	} else {
		if (obj.component_parent) {
			if (top == false) print ", which is ";
			print "part of ", (the) obj.component_parent;
			ShowRLocation(obj.component_parent);
		}
		else print "out of play";
	}
];
[ ShowMeSub;
 	if (noun == nothing) noun = real_location;
 	if (ShowMeRecursively(noun, 0, (noun == real_location))) {
 		if (noun == real_location)
			print "* denotes things which are not in scope^";
	}
 	if (noun ofclass K2_thing) {
 		print "location:";
 		ShowRLocation(noun, true);
		print "^";
 	}
];
[ ShowMeRecursively obj depth f c i k;
	spaces(2*depth);
	if (f && (depth > 0) && (TestScope(obj, player) == false)) { print "*"; c = true; }
	print (name) obj;
	if (depth > 0) {
		if (obj.component_parent) print " (part of ", (name) obj.component_parent, ")";
		if (obj has worn) print " (worn)";
	}
	if (obj provides i7_kind) {
		k = obj.&i7_kind-->0;
		if ((k ~= K2_thing) || (depth==0)) {
			print " - ";
			if (k == K4_door or K5_container) {
				if (obj has transparent) print "transparent ";
				if (obj has locked) print "locked ";
				else if (obj has open) print "open ";
				else print "closed ";
			}
			print (I7_Kind_Name) k;
		}
	}
	print "^";
	if (obj.component_child) c = c | ShowMeRecursively(obj.component_child, depth+2, f);
	if ((depth>0) && (obj.component_sibling))
		c = c | ShowMeRecursively(obj.component_sibling, depth, f);
	if (child(obj)) c = c | ShowMeRecursively(child(obj), depth+2, f);
	if ((depth>0) && (sibling(obj))) c = c | ShowMeRecursively(sibling(obj), depth, f);
	return c;
];

Constant RELATIONS_CREATED;

#IFDEF RELATIONS_CREATED;
[ ShowRelationsSub rc;
	for (rc=0:rc<98:rc++)
		I7_ShowR(rc);
];
#IFNOT; ! RELATIONS_CREATED
[ ShowRelationsSub;
	"No new relations have been created.";
];
#ENDIF; ! RELATIONS_CREATED

Verb meta "dbrb"
	* number -> DebugRb
	* number "off" -> DebugRbOff;
Verb meta "rules"
	* -> RulesOn
	* "all" -> RulesAll
	* "off" -> RulesOff;
Verb meta "scenes"
	* -> ScenesOn
	* "off" -> ScenesOff;
Verb meta "showme"
	* -> ShowMe
	* multi -> ShowMe;
Verb meta "relations"
	* -> ShowRelations;

! End of Debugging.i6

#ENDIF; ! DEBUG



 
[ I7_CheckDPMR result;
	if (FollowRulebook( 30 ) && RulebookSucceeded()) {
		result = ResultOfRule();
		if (result == RBNO_6 ) return 4;
		if (result == RBNO_7 ) return 3;
		if (result == RBNO_8 ) return 2;
		if (result == RBNO_9 ) return 1;
		if (result == RBNO_10 ) return 0;
	}
	return 2;
];
 




! The falsity proposition represents the empty set
[ Prop_Falsity reason obj; return 0; ];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_CarriedBy(x)) ]
[ Prop_0  const_0 x counter;
  objectloop (x in const_0) if (I7_CarriedBy(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! True or false?
! [ exists x: called(x)='sack' ^ K10'player's holdall'(x) ^ is(const_0,I7_CarriedBy(x)) ]
[ Prop_1  const_0 x ;
  objectloop (x in const_0) if (I7_CarriedBy(x)==parent(x))
    if ((x ofclass K10_player_s_holdall))
      {I7_CS-->0 = x; if (true) rtrue; }
  rfalse;
];

! Find next x in a loop over all x such that:
! [ K2'thing'(x) ^ is(const_0,I7_CarriedBy(x)) ]
[ Prop_2  const_0 x ;
  if (x) jump NextOuterLoop_0;
  objectloop (x in const_0) if (I7_CarriedBy(x)==parent(x)) {
    if ((x ofclass K2_thing))
      return x;  
    .NextOuterLoop_0;
  }
  return nothing;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_CarriedBy(x)) ]
[ Prop_3  const_0 x counter;
  objectloop (x in const_0) if (I7_CarriedBy(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_OnWhat(x)) ]
[ Prop_4  const_0 x counter;
  objectloop (x in const_0) if (I7_OnWhat(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_InWhat(x)) ]
[ Prop_5  const_0 x counter;
  objectloop (x in const_0) if (I7_InWhat(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! True or false?
! [ cardinality(== 0)x: K6'supporter'(x) => is(const_0,x) ]
[ Prop_6  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=nothing: x: ) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_OnWhat(x)) ]
[ Prop_7  const_0 x counter;
  objectloop (x in const_0) if (I7_OnWhat(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! True or false?
! [ cardinality(== 0)x: K5'container'(x) => is(const_0,x) ]
[ Prop_8  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K5_First: x: x=x.K5_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! How many x satisfy this?
! [ K2'thing'(x) ^ is(const_0,I7_InWhat(x)) ]
[ Prop_9  const_0 x counter;
  objectloop (x in const_0) if (I7_InWhat(x)==parent(x)) {
    if ((x ofclass K2_thing))
      {counter++; jump NextOuterLoop_0;
}    .NextOuterLoop_0;
  }
  return counter;
];

! True or false?
! [ cardinality(== 0)x: K2'thing'(x) => is(const_0,x) ]
[ Prop_10  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K2_First: x: x=x.K2_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K5'container'(x) => is(const_0,x) ]
[ Prop_11  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K5_First: x: x=x.K5_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K6'supporter'(x) => is(const_0,x) ]
[ Prop_12  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=nothing: x: ) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ exists x: K2'thing'(x) ^ p24_described(x) ^  NOT  [ scenery(x) ]  ^ is(const_0,I7_InWhat(x)) ]
[ Prop_13  const_0 x ;
  objectloop (x in const_0) if (I7_InWhat(x)==parent(x))
    if ((x ofclass K2_thing) && (I7GetEitherOr(x,concealed)==false))
      if (~~((I7GetEitherOr(x,scenery))))
        rtrue;  
  rfalse;
];

! True or false?
! [ exists x: K2'thing'(x) ^ p24_described(x) ^  NOT  [ scenery(x) ]  ^ is(const_0,I7_OnWhat(x)) ]
[ Prop_14  const_0 x ;
  objectloop (x in const_0) if (I7_OnWhat(x)==parent(x))
    if ((x ofclass K2_thing) && (I7GetEitherOr(x,concealed)==false))
      if (~~((I7GetEitherOr(x,scenery))))
        rtrue;  
  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K2'thing'(x) => is(const_0,x) ]
[ Prop_15  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K2_First: x: x=x.K2_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K8'person'(x) => is(const_0,x) ]
[ Prop_16  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K8_First: x: x=x.K8_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];

! True or false?
! [ cardinality(== 0)x: K8'person'(x) => is(const_0,x) ]
[ Prop_17  const_0 x qcy_0 qcn_0 ;
  if (true) {  qcy_0 = 0; for (x=K8_First: x: x=x.K8_Link) 
    { qcn_0++;
      if ((const_0 == x))
        qcy_0++; }
      if (qcy_0 == 0)       rtrue;  
 }  rfalse;
];


[ Resolver_0 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction))) && (((t_1 ofclass K1_room)))) { return   I7_RoomOrDoorFrom(t_1,t_0)  ; }
Runtime_Type_Error(filename, line);
  rfalse; ];
[ Resolver_1 t_0 t_1 filename line;
if ((((t_0 ofclass K4_door))) && (((t_1 ofclass K1_room)))) { return   I7_OtherSide(t_0,t_1)  ; }
Runtime_Type_Error(filename, line);
  rfalse; ];
[ Resolver_2 t_0 filename line;
if ((((t_0 ofclass K8_person)))) {   HisHerTheir(t_0);   rtrue; }
  rfalse; ];
[ Resolver_3 t_0 t_1 filename line;
if ((((t_0 ofclass K1_room))) && (((t_1 ofclass K1_room)))) {   return I7_ReckonLight(t_0, t_1);   rtrue; }
Runtime_Type_Error(filename, line);
  rfalse; ];
[ Resolver_4 t_0 t_1 filename line;
if ((((t_0 ofclass K3_direction))) && (((t_1 ofclass K1_room)))) { return   I7_RoomFrom(t_1,t_0,2)  ; }
Runtime_Type_Error(filename, line);
  rfalse; ];
[ Resolver_5 t_0 t_1 filename line;
if ((((t_1 ofclass K1_room)))) { return   I7_RoomOrDoorFrom(t_1,t_0)  ; }
Runtime_Type_Error(filename, line);
  rfalse; ];

Constant SC_43 = " ";
Constant SC_32 = " arrives from ";
Constant SC_23 = " arrives";
Constant SC_30 = " at ";
Constant SC_37 = " away";
Constant SC_59 = " closes ";
Constant SC_60 = " closes.";
Constant SC_21 = " eats ";
Constant SC_24 = " from ";
Constant SC_40 = " gets ";
Constant SC_45 = " gets off ";
Constant SC_44 = " gets out of ";
Constant SC_65 = " gives ";
Constant SC_22 = " goes ";
Constant SC_31 = " goes through	";
Constant SC_33 = " in ";
Constant SC_36 = " in front";
Constant SC_35 = " in front, and you along too";
Constant SC_38 = " in";
Constant SC_20 = " into ";
Constant SC_52 = " locks ";
Constant SC_46 = " looks around.";
Constant SC_51 = " looks at ";
Constant SC_48 = " looks closely at ";
Constant SC_11 = " looks through ";
Constant SC_49 = " looks under ";
Constant SC_56 = " off.";
Constant SC_19 = " on ";
Constant SC_55 = " on.";
Constant SC_57 = " opens ";
Constant SC_58 = " opens.";
Constant SC_13 = " picks up ";
Constant SC_12 = " possessions.";
Constant SC_73 = " pulls ";
Constant SC_74 = " pushes ";
Constant SC_18 = " puts ";
Constant SC_17 = " puts down ";
Constant SC_61 = " puts on ";
Constant SC_50 = " searches ";
Constant SC_76 = " squeezes ";
Constant SC_54 = " switches ";
Constant SC_62 = " takes off ";
Constant SC_64 = " to ";
Constant SC_68 = " touches	";
Constant SC_71 = " touches ";
Constant SC_75 = " turns ";
Constant SC_53 = " unlocks ";
Constant SC_67 = " waits.";
Constant SC_72 = " waves ";
Constant SC_34 = ", pushing ";
Constant SC_39 = ", taking you along.";
Constant SC_14 = ".";
Constant SC_10 = ":";
Constant SC_8 = "A distant wind blows, echoing over the valley.";
Constant SC_1 = "A really cool game.";
Constant SC_5 = "A wide-brimmed hat to protect you from the sun, and to clearly advertise yourself as a denizen of the plains.";
Constant SC_4 = "As good-looking as ever.";
Constant SC_2 = "Ben Collins-Sussman and David Anderson";
Constant SC_3 = "Here is an introductory paragraph.  Make it clear that we're in rural Wyoming in 1870... just one year after the first transcontinental railway was completed, and 3 years after the invention of dynamite.  Dynamite is a new thing.  Player is an anti-hero, attempting to rob a train.
";
Constant SC_0 = "InfoComp Game Entry";
Constant SC_79 = "It's a rusty wind-up timepiece, handed down from your uncle.  It currently reads ";
Constant SC_16 = "There is no more room in ";
Constant SC_15 = "There is no more room on ";
Constant SC_63 = "You give ";
Constant SC_78 = "You have no way of checking the time.";
Constant SC_47 = "You see nothing unexpected in that direction.";
Constant SC_9 = "You'll have to say
which compass direction to go in.";
Constant SC_7 = "You're standing on a bluff, overlooking a combination of sun-blasted plains and craggy hills.";
Constant SC_77 = "Your pocketwatch reads ";
Constant SC_25 = "above";
Constant SC_26 = "below";
Constant SC_6 = "blah blah";
Constant SC_29 = "down";
Constant SC_69 = "herself";
Constant SC_70 = "himself";
Constant SC_41 = "into";
Constant SC_42 = "onto";
Constant SC_27 = "the ";
Constant SC_28 = "up";
Constant SC_66 = "you";

#ifndef I7_Map_Region; Constant I7_Map_Region = 0; #endif;
#ifndef description; Constant description = 0; #endif;
#ifndef short_name; Constant short_name = 0; #endif;
#ifndef initial; Constant initial = 0; #endif;
#ifndef plural; Constant plural = 0; #endif;
#ifndef invent; Constant invent = 0; #endif;
#ifndef article; Constant article = 0; #endif;
#ifndef with_key; Constant with_key = 0; #endif;
#ifndef door_to; Constant door_to = 0; #endif;
#ifndef capacity; Constant capacity = 0; #endif;
#ifndef p10_opposite; Constant p10_opposite = 0; #endif;
#ifndef p11_inform_property; Constant p11_inform_property = 0; #endif;
#ifndef p12_inform_object; Constant p12_inform_object = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef visited; Constant visited = 0; #endif;
#ifndef enterable; Constant enterable = 0; #endif;
#ifndef light; Constant light = 0; #endif;
#ifndef edible; Constant edible = 0; #endif;
#ifndef transparent; Constant transparent = 0; #endif;
#ifndef concealed; Constant concealed = 0; #endif;
#ifndef static; Constant static = 0; #endif;
#ifndef scenery; Constant scenery = 0; #endif;
#ifndef clothing; Constant clothing = 0; #endif;
#ifndef moved; Constant moved = 0; #endif;
#ifndef pushable; Constant pushable = 0; #endif;
#ifndef door; Constant door = 0; #endif;
#ifndef container; Constant container = 0; #endif;
#ifndef supporter; Constant supporter = 0; #endif;
#ifndef switchable; Constant switchable = 0; #endif;
#ifndef animate; Constant animate = 0; #endif;
#ifndef male; Constant male = 0; #endif;
#ifndef workflag; Constant workflag = 0; #endif;
#ifndef I7_mentioned; Constant I7_mentioned = 0; #endif;
#ifndef initially_carried; Constant initially_carried = 0; #endif;
#ifndef open; Constant open = 0; #endif;
#ifndef openable; Constant openable = 0; #endif;
#ifndef lockable; Constant lockable = 0; #endif;
#ifndef locked; Constant locked = 0; #endif;
#ifndef on; Constant on = 0; #endif;
#ifndef female; Constant female = 0; #endif;
#ifndef neuter; Constant neuter = 0; #endif;
#ifndef p55_specification; Constant p55_specification = 0; #endif;
#ifndef score; Constant score = 0; #endif;
#ifndef score; Constant score = 0; #endif;
#ifndef worn; Constant worn = 0; #endif;
Constant I7_FBNA = 10000;

#IFNDEF I7_cap_short_name;
Constant I7_cap_short_name = short_name;
#ENDIF;

Constant I7_BOXES = 1;



! End of automatically generated I6 source
! --------------------------------------------------------------------------
